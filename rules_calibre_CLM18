// *****************************************************************************
// * 0.18um/0.16um/0.152um Calibre DRC COMMAND FILE - CLM18_LM16_LM152_6M.215a (01/31/2018) *
// * FOR TSMC 0.18UM CMOS LOGIC/MS/RF AND 0.16UM/0.152UM CMOS LOGIC/MS 1P6M PROCESS DESIGN RULE*
// *          (CL018G/LV/LP, CM018G, CR018G, CL016G, CM016G, CL0152G, CM0152)  *
// * (DESIGN RULE DOCUMENT: T-018-LO-DR-001 Rev 2.15)                          *
// * (DRC COMMAND FILE DOCUMENT: T-018-LO-DR-001-C1 Rev 2.15a)         	       *
// *****************************************************************************

//************************************************************************************
//* TSMC developed this deck using Mentor Graphics proprietary SVRF and TVF formats.
//* The deck is to be used only in Calibre tools.
//************************************************************************************
//
//  DISCLAIMER
//
//  The information contained herein is provided by TSMC on an "AS IS" basis
//  without any warranty, and TSMC has no obligation to support or otherwise
//  maintain the information.  TSMC disclaims any representation that the
//  information does not infringe any intellectual property rights or proprietary
//  rights of any third parties.  There are no other warranties given by TSMC,
//  whether express, implied or statutory, including, without limitation, implied
//  warranties of merchantability and fitness for a particular purpose.
//
//  STATEMENT OF USE
//
//  This information contains confidential and proprietary information of TSMC.
//  No part of this information may be reproduced, transmitted, transcribed,
//  stored in a retrieval system, or translated into any human or computer
//  language, in any form or by any means, electronic, mechanical, magnetic,
//  optical, chemical, manual, or otherwise, without the prior written permission
//  of TSMC.  This information was prepared for informational purpose and is for
//  use by TSMC's customers only.  TSMC reserves the right to make changes in the
//  information at any time and without notice.
//
//-------------------------------------------------------------------------------------------
//
//  NOTICE: (Read Me First!)
//
//  1. If the input GDS file does not include all the layers in the
//     INPUT LAYER BLOCK, for example, they are generated by logic
//     operations, please make sure the consistence with original
//     layer definition.
//
//  2. The runset is tested and developed on Calibre v2010.4_26.16 (Dec. 2010), please use 
//     this or newer TSMC qualified version of Calibre to execute this runset.
//


//----------------------------------------------------------------------------------------
//
// REVISION:
// 2.0a 04/27/00 T.C.Chiang
//	1) add NW resistor space to NW
//	2) PO.R.1 modofied
//	3) combine implant check such like N2V.C.4/N2V.E.5 -> N2V.C.4
//	4) CO.S.2 relax to be applied larger than 3x3
//	5) CO.C.2  0.21 -> 0.20
//	6) IO ESD guideline  ESD.4/ESD.5
//	7) ESD.S.2/ESD.C.1/ESD.C.4
//	8) Add RPO.C.6
//	9) Add fuse rule
//	10) remove CB rules - only check basic CB rule
// 2.0b 06/20/00 T.C.Chiang
//	1) modify N2V/P2V/N3V/P3V as drawn layers
//	2) revise wide metal check Mx.S.2
//	3) rename input layer names as document T-018-LO-LE-003
//	4) revise PO.R.1B
//	5) revise N2V.C.1/N3V.C.1/P2V.C.1/P3V.C.1/NP.C.1/PP.C.1
//	6) add option to set different grid check
//	7) NTAP definition exclude well resistor OD
// 2.0c 08/04/00 T.C.Chiang
//	1) revise N3V.E.1
//	2) remove undefined check N3V.E.2
//	3) revise ESD.C.4
//	4) rename NT_N.E.2 to NT_N.PO.1
//	5) revise PO.R.2 check
// 2.1a 09/28/00 Kevin Liu
//      Rule Changed: NWR.C.2/OD.W.3/PO.R.2/FUSE.M/LAT.2/ESD.5/ESD.9
//      Layer Removed: N2V/N3V/P2V/P3V
//      Revise Checked:
//	1) LAT.3P/LAT.3N
//	2) OD2.E.2
//	3) IO ESD rules
//	4) nwel space check by connectivity
//      Added Check: metal slot rule
// 2.1b 10/17/00 Kevin Liu
//	Check Added: FUSE.J
// 2.1c 11/15/00 Kevin Liu
// 	Check revised: ESD.5.WARN.2 / LAT.3P / LAT.3N / ESD.6 / RPO.C.3
//	Revise Layer: DMN2V   184
// 2.1d 02/12/01 Kevin Liu
//	Revise check: AM.W.1.Mx_AM.W.2.Mx, MxHOB Logic operation
// 2.1e 04/12/01 C.W.Wei
//	Revise check: AM.W.3.Mx (x = 1~6)
//      Revised PP.E.3..4/PP.E.3..4 to avoid false errors caused by EXCL layer
//      Revised CO.S.2 rule checks
//	Revised check: AM.L.1.Mx (x = 1~6) 
// 2.1f 05/07/01 C.W.Wei
//	Revise check: AM.W.3.Mx (x = 1~6)
// 2.2a 05/28/01 Kevin Liu
//	1) Remove all layers V-Notches check.
//	2) Change layers NWELL/NP/PP/Metal2~Metal6/VIA2~VIA5 methodology to solve SRAM
//	   using NOT INSIDE EXCL
//	3) Rule change: NP.E.6/PP.E.6 added (RPO AND POLY) NOT IMP
//	4) FUSE rules are removed by this deck
//	5) Dummy Pad & Power Line remove Contact check
//	6) LAT.3N & LAT.3P methodology change
// 2.2b 08/14/2001 Kevin Liu
//	1) Adding layer FWI(235); LWI(63;2)
//	2) Revise derived layer RNGX = PMDMY NOT ( CB OR FW OR LW)
//	3) Revise metal density report file Mx_DENSITY.log (x=1~6)
//	4) " DRC MAXIMUM RESULTS ALL "
// 2.3a 10/05/2001 C.S.Yang 
//	Revise check : latch-up rule
// 2.3b 01/31/2002 Brad Pu
//	check revised:
//	1) NT_N.E.1: Using the definition of SIZE to check maximum and minimum.
//	2) ADP.W.3: width 80um is a good pattern.
//	3) Modify the resolution value of environment setup to 5
//	4) Remove LAYER RESOLUTION
//	5) Add two layers CBDi(169) and MDi(168), and related metal slot uncheck features.
//	6) ESD.6 check to EGTE not poly
// 2.3c 11/11/2002 - G.S.Chang
//	1) Revise Mx.S.2, employ OPPOSITE metrics to the spacing check of the small metal
//	   piece with length less than 1um and connected to wide metal.
//	2) Modify LAT.2 to check the whole active area inside SDI region 
//	3) Recognize each ESD devices for ESD rules with dummy layers instead of connections
//	4) Modify PP.E.3/PP.E.4/PP.C.2/PP.C.3/PP.E.1 (same as NP) to highlight the butted edge
//	   of OD and PP(NP) but without coincident with NP(PP).
//	5) Change the method to pickup bent poly in rule NTN.I.4
//	6) Create metal slot and chip-corner rules for RDL layers (MD). 
//	7) Create options of HIGH_VOLTAGE and CORE_VOLTAGE for slections of different core or I/O
//	   voltages and execute DRC with proper rules.
//	8) Add checks for warning if there is not any option for HIGH_VOLTAGE and CORE_VOLTAGE specified.
//	9) Apply new option INNER EMPTY in metal slot checks.
// 2.3d 03/11/2003 - G.S.Chang
//	1) Revise Mx.S.2, correct false errors between branches of wide metals.
//	2) Add 5V HIGH_VOLTAGE option for concatenation of 5V DRC module.
// 2.4a 07/01/2003 - Yating Chuang
//	1) Revise PO.R.2, fix false error from sizing step.
//	2) Relax butted edges between active and pickup for OD2.E.1.
//	3) Use NWELL to define active and pick-up od instead of PWELL.
//	4) Revise NWR.O.1, remove inside NWELL. Add check overlap of RPO to NP.
//	5) Add NWR.E.3, consider extension of NP beyond NPOD in NW resistor under STI.
//	6) Modified the definition of RDL pad area for metal slot exclusion.
//	7) Revise LAT.3P/N with more precisely sizing stepping.   
// 2.4b 12/16/2003 - Yating Chuang
//	1) Revise PO.R.2, fix missing error from definition of long poly.    
// 2.5a 03/04/2004 - C.T.Yao, Yating Chuang
//	1) Add option "#DEFINF CUP" for choosing wire bond structure.
//	2) Modify mslot and via rule to check circuit under CUP.
//	3) Revise connection layer in NW rule.     
//	4) Revise all metal slot dimension rules as guidelines and add AMS.DN.1.Mx. 
//	5) Refine ESD rules, add ESD.11, relax ESD.5B,ESD.5H,ESD.5I. 
//	6) Relax NT_N.W.1: 0.86um -> 0.74um.
//	7) Add ADP.R.0C, VIA1,3,5 and VIA2,4,6 should not overlap in dummy pad structure.  
//	8) Add ADP.R.0D, VIA1,3,5 and VIA2,4,6 should not overlap in power line structure. 
// 2.5b 07/05/2004 - C.T.Yao
//	1) Create switch CHECK_SRAM_EXCL to check M2 and upward layers inside layer EXCL also. 
//	2) Add HRI.WARN to check RLPPDMY interact OD.
//	3) Modify the checking methodology of the rule Mx.S.2 for checking exactly.
//	4) Replace OVERLAP, INSIDE ALSO, OUTSIDE ALSO options with AND, NOT, CUT operations.
//	5) Relax AM.W.1.Mx, at least one branch width >= 10um.
//	6) Revise ESD.5H, ESD.5I to be ">=", not "==" 0.25um, enhance ESD.6. 
// 2.5c 02/14/2005 - H.M.Tseng
//	1) Add "TRUNCATE" option to fix false error in "SIZE UNDEROVER".
//	2) Add "ENCLOSE RECTANGLE" to fix false error in seeking wide metal.
//	3) Remove the the switch of CUP and add WBDMY (183) layer for seperating CUP and NON-CUP.
// 2.5d 04/12/2005 - J.Y.Li
//	1) Fix false error in ESD.11: exclude pick-up not between diffusion of ESD.       
//	2) Enhance LAT.3P LAT.3N to ignore filler cell violation.
// 2.6a 04/26/2006 - Allen Tsai
//	1) Add NP.R.3, PP.R.3.
//	2) Refine RPO.C.4, RPO.C.5.
//	3) Modify PO.R.3.
//	4) Refine OD.W.3 and NT_N.I.3:Follow DRM revision.
//	5) Refine NT_N.E.1: Modify checking region from OD to NPOD.
// 2.6a 05/04/2006 - Y.J. Chuang
//	6) Revise Mx.S.2 for wide metal space check.
//	7) Add MD and VIAD rules follow MT and VIAT.
// 2.6b.pre 08/25/2006 - Harry Yeh
//	1) Revise OD2.E.1/OD2.C.1, modify check region from {Active OD} to {Active OD or GATE}.
//	2) Revise OD2.E.2, check source/drain direction only.
//	3) Add an option "CHECK_DUMMY_ODPO" to switch dummy OD&PO rule check.
// 2.7a.pre 04/15/2008 - Y.M. Zhang
//      Merge the following design rules into T-018-LO-DR-001.
//             C018G Logic 1.8/5V design rule (T-018-LO-DR-011)
//             C018LV Logic 1.5/3.3V design rule (T-018-LO-DR-003)
//             C018LV Logic 1.5/2.5V design rule (T-018-LO-DR-008)
//             C018LP Logic 1.8/3.3V design rule (T-018-LO-DR-009)
//             C018LP Logic 1.8/5V design rule (T-018-CL-DR-001)
//             C018 MM_RF design rule (T-018-MM-DR-001)
//             C016 Logic/MM design rule (T-016-CL-DR-001) 
//      1) Add LOGO rules        
//      2) Add 40KA UTM rules for 0.18um 1.8V/3.3V MM/RF process only
//      3) Add 2fF MIMCAP device for 0.18um 1.8V/3.3V process only and add A.R.MIM.5 for it in antenna part 
//      4) Add VTM_P.R.3 with design rule
//      5) Remove AM.W.1 with design rule.
//      6) Remove RES.8 with design rule.
//      7) Remove native device rule in mixed signal section due to duplicate with logic section 4.5.3.
//                The extra rule NT_N.I.6 in mixed signal can be covered by NT_N.I.4 & NT_N.E.1.
//      8) Rename rules for DNW.I.X, VTM_N.I.X, VTM_P.I.X,RES.X, CTM.E.3
//            From DNW.I.X(X=5,6,7) to DNW.R.X(X=3,4,5);From VTM_N.I.X, VTM_P.I.X(X=195) to VTM_N.R.X, VTM_P.R.X(X=195) 
//            PO.W.1 to PO.W.1_HRI and RES.x to RES.HRI.x,MIM_Mx.E.3 to CTM.E.3,RPO.O.1 to RPO.O.1_HRI for HRI only   
//      10) Remove rules for NT_N.I.6, VIAx.0, VIAx.C.1, VIAn.C.1.
//      11) Refine ESD guideline and remove old 1.8V high voltage tolerant device.
//      12) Refine and re-structure latch-up guideline rules 
//      13) Modify DNW.C.1. check DNW to NWEL with DNW.  
//      14) Modify HRI.E.1.
// 2.7a.pre 04/16/2008 - Y.M. Zhang
//      1) Add logo ruls check.
//      2) Add ESD implant rules check for 5V process 
// 2.7a.pre 04/21/2008 - Y.M. Zhang
//      1) Modify NT_N.W.2 to check CL018G too 
//      2) Add ADP.C.1 and change ADP.S.4 to ADP.S.1_PL
// 2.7a 04/21/2008 - Y.M. Zhang
//      Official release.
// 2.7b 07/23/08 - Y.M. Zhang
//      1) Remove DRC UNSELECT CHECK.  
//      2) Modify PO.W.1_HR to enable check more exactly.  
//      3) Change ADP.C.3 to ADP.C.1 and ADP.C.2 to align design rule. 
//      4) Modify some rule name to align design rule.
//                Change VTMP.X.X to VTM_P.X.X,
//                Change VTMN.X.X to VTM_N.X.X,
//                Change NT_N.W.3 to NTN.W.3 in C016 process.
//      5) Modify CURRENT STATUS part.
// 2.7c 12/23/2008 - M.Feng
//	1) Change the rule name from NT_N.W.2 to NT_N.W.2_LV
//	2) Change the rule writing of the ESD.24g, ESD.28g
//	3) Change the rule check of LUP.5.4 according to design rule owner's comment.
//	4) Change the rule check of MIMVIA.S.1 and MIMVIA.S.2 according to design rule owner's comment.
// 2.8a 06/25/2009 - M.Feng
//	1) Change the rule writing of rule NT_N.I.4, NP.R.3, PP.R.3,PP.O.1,PP.E.1,RPO.C.3,CO.W.1,CO.E.3,VIAx.W.1,
//	   VIAn.W.1,DNW.E.1,CTM.W.4,ESD.20g,ESD.21g,LOGO.R.1 according to the DRM
//	2) Add the new rules NWR.R.3,NWR.R.4,NWR.R.5,NWR.R.6,RES.9,RES.10,RES.11,DNW.S.2,IMD crack rules,ESD.35g
//	   SBD rules according to the DRM.
//	3) Delete the rules VTM_N.R.1,VTM_P.R.1,DNW.C.2,DNW.C.3 according to the DRM
//	4) Change the layer definition of the EXCL for LOGO.R.2.
//	5) Change the recognition method for I/O device according to the advance process.
//	6) Change the rule name from ESD.8 to ESD.8g,ADP.S.2 to ADP.S.2g, ADP.W.3 to ADP.W.3g, ADP.W.4 to ADP.W.4g
//	   LUP rules according to the DRM.
//	7) Put the VIAD rules and the M6/MD density rules into the normal top metal option. 
//	8) Add the warning for the ESD implant (ESD.WARN.3) according to the DRM owner's comment.
//	9) Change the UTM20K.C.1, UTM40K.C.1 to recomendation rules according to the design rule change.
// 2.8b 12/10/2009 - Q.Q. Tong
//      1) Change the layer definition for Latch-up rule  
//      2) Change the switch CHECK_SRAM_EXCL as turn on according to the RCCB comment
//      3) Allow HRI in the 0.16um process according to the DRM   
// 2.9a 05/25/2012 - Franky Chen
//	1) Add rules: NW.S.3-4, NWR.R.7, PO.C.3-4, PO.R.4, DRM.R.1, RES.8, RES.12-15, RES.HRI.8-10, VIAx.E.3, VIAn.E.3,
//                UTM20K.I.3, UTM40K.I.3, UTM40K.W.2, ESD.3g, ESD.5g, ESDIMP related rules, DOD/DPO related rules and SEALRING related rules.
//  2) Modify rules: PP.E.6, RES.2, RES.HRI.1, ESD.28g, LUP.1g, LOGO.S.1, UTM20K.E.3, UTM40K.E.3,
//  3) Modify chip corner definition for DOD/DPO check.
//  4) Modify connection for latchup & adopt RES200 to recognize resistor with 200ohm or above
//     Modify latchup device recognition through connection only & remove SDI-covered device
//	   Add CONNECT_ALL_RESISTOR & DISCONNECT_ALL_RESISTOR switch to control connection for latchup rule check.
//  5) Merge CL0152G & CM0152 process & offer non-shrinkable rules in C0152 switch.
// 2.10a 09/20/2012 - Franky Chen
//  1) Modify rules: NWR.R.7, ESD.3g, ESD.5g and IMD Crack related rules 
//  2) Add rules: AN.R.40, AN.R.41
//	3) Remove rule: UTM40K.W.2
//  4) Waive PP.E.1/PP.E.3/NP.E.1/RPO.E.1/RPO.C.4 in SEALRING (126;0) region
// 2.11a 05/23/2014 - Yvonne Cao
//	1) Add rules: NW.R.1, RES.HRI.11, RES.HRI.12, CO.R.4, M1.S.2.1.a, M1.S.2.1.b, Mx.S.2.1.a, Mx.S.2.1.b, Mn.S.2.1.a, Mn.S.2.1.b,
//	   			  CB.W.3, FPAD.R.1, UTM40K.A.2, UTM40K.R.2 and UTM40K.R.3, ESD.1g, ESD.7g, ESD.9g and ESD.10g
//	2) Modify rules: AN.R.40m and AN.R.41m
//	3) Waive in SEALRING region: RES.3_OD, RES.4_OD and PP.E.1_NP.E.1
//	4) Remove Recommend switch of DOD.R.1
//	5) Enhance definition of PACTc
// 2.12a 06/11/2015 - Y.H. Yu
//	1) Add rules: OD.C.7, OD2.W.1, VIAx.S.6, VIAx.S.7, VIAx.S.8, VIAx.S.9, VIAx.S.10, Mx.S.3, Mx.S.4, Mx.S.5, Mx.S.6, and CTM.R.6 
//	2) Modify rules: VIAx.S.5 and CB.W.3 
//	3) Modify SEALRING region definition
//  4) Waive violations in SEALRING region for RPO.C.1 rule
// 2.13a_pre083116 08/31/2016 - K.Zhu
//  1) Add rules:3DMIM.A.2,	3DMIM.DN.1,	3DMIM.EX.1,	3DMIM.EX.2,	3DMIM.EX.3,	3DMIM.EX.4,	3DMIM.S.1,	3DMIM.S.2,	3DMIM.S.3, 3DMIM.S.8	
//               3DMIM.S.4,	3DMIM.S.5,	3DMIM.S.6,	3DMIM.S.7,	3DMIM.W.1,	3DMIM.W.3,	3DMIM.W.4,	3DMIM.W.5,	3DMIM.W.6, 3DMIM.S.9
//               3DMIM.S.10	,MOM.A.1, MOM.R.1,	MOM.R.2,	MOM.S.2,	ANALOGDMY.A.1,	ANALOGDMY.EX.1,	ANALOGDMY.EX.2,	ANALOGDMY.R.1,	
//               ANALOGDMY.S.1, ANALOGDMY.S.2,	ANALOGDMY.S.3,	ANALOGDMY.S.4,	ANALOGDMY.W.1,	MIM_Mx.O.1,	MIM_Mx.R.1,	OD.EX.1	,OD.R.5,
//             	 RPO.A.2, 3DMIM.R.10, 3DMIM.EX.5		
// 2.13a 10/18/2016 - K.Zhu
//  1) Official release
//  2) modify ENSD_SOURCE and EPSD_SOURCE definition
// 2.14a 12/02/2016 -W.Pan
//  1) Modify 3DMIM CTM_3D CBM_3D and 2DMIM CTM CBM definition
// 2.15a 01/31/2018 - L.L.Cao 
//	1) Add switch : DEFINE ALL_AREA_IO 
//	2) Modify rules : ESD.5g, ESD.18g_2.5V_P, ESD.10g, ESD.WARN.2, LUP.2g, LUP.3.1g_1.8V, LUP.3.1g_1.5V, LUP.3.2g_2.5V, LUP.3.3g_3.3V, LUP.3.4g_5V, 
//					  LUP.5.1g_1.8V, LUP.5.1g_1.5V, LUP.5.2g_2.5V, LUP.5.3g_3.3V, LUP.5.4g_5V, LUP.10g__LUP.13g, LUP.14g,
//				      OD.EX.1, ANALOGDMY.W.1, ESD.40g, OD.R.5, MIM_Mx.R.1, MIM_Mx.O.1, DNW.S.2, ESD.10g
//  3) Add rules : ESD.5.1g, ESD.WARN.4, ESD.WARN.5, ESD.40g, HIA.1g, HIA.2g, HIA.3g, HIA.4g, HIA.9g, HIA.17g, HIA.18g, LUP.WARN.1, 
//                 NT_N.S.2, OD.S.3, OD.S.4, OD2.R.1, DOD.DN.1, DOD.DN.2,ULLNW.S.1, ULLNW.S.2, ULLNW.S.3, ULLNW.S.4, ULLNW.W.1, ULLNW.W.2,
//                 ODLL.A.1, ODLL.E.1, ODLL.E.2, ODLL.E.3, ODLL.O.1, ODLL.R.1, ODLL.S.1, ODLL.S.2, ODLL.S.3,
//				   ODLL.S.4, ODLL.S.5, ODLL.S.6, ODLL.S.7, ODLL.W.1
//  4) Delete rules: MIM_Mx.O.1, MIM_Mx.R.1
//  5) Add MD pin text
//  6) Modify layer definition : NTAPux, PTAPux, POST_DRIVER_ACT, PAD_EXD
//  7) Modify connectivity: connect PWEL/RW with PTAP for i, j, k, u connectivity, deleted duplicated connectivity i for IFNEF C0152, remove metal slot area for connectivity 



//-------------------------------------------------------------------------------------------


//-------------------------------------------------------------------------------------------
//
// DUMMY LAYER REQUIRED:
//
//  1) HOTWL   - Hot N-Well
//               N-Well not connected to the most positive voltage Vdd is defined as Hot N-Well. 
//               It must follow different width and space rules from the N-Well connected to 
//               Vdd (Cold N-Well). Use "HOTWL" layer to exactly cover the Hot N-Well area for 
//               correct N-Well DRC.
//
//  2) EXCL    - UN-DRC area
//               If there's any area with different rules and not to be checked in this run, 
//               use the "EXCL" layer to exactly cover the area to be excluded.
//
//  3) SDI     - I/O ESD Protection Circuit
//               For I/O guidance rule checking, use "SDI" layer to designate the ESD area to 
//               checked. The whole ESD devices should be covered by "SDI".
//
//  4) DPDMY   - Dummy Pad area
//               For chip corner dummy pad, use "DPDUMMY" layer to cover dummy pad area.
//
//  5) PLDMY   - Power Line
//               For chip corner power line, use "PLDUMMY" layer to cover whole power line area.
//
//  6) RWDMY   - NWell Resistor
//               The N-Well region covered by both RWDMY and RPO is the NW within OD resistor.
//               The N-Well region covered by only RWDMY is the NW under STI resistor.
//
//  7) DRCDMY  - TSMC reserved layer.
// 
//  8) ESD1DMY - IO ESD region dummy layer, RPO must enclose whole gate.
//     ESD2DMY - RPO enclose gate 0.05 for 3.3V.
//	   RES200  - 200ohm resistor dummy layer
//
//  9) DMN2V   - Dummy layer to ensure N2V in N+ poly/od resistor.
//     DMP2V   - Dummy layer to ensure P2V in P+ poly/od resistor.
//
// 10) RLPPDMY - LPP high resistance poly resistor
//               Use "RLPPDMY" to exactly cover LPP high resistance poly resistor area.
//
// 11) WBDMY   - Dummy layer to cover the CUP pad.
//
// 12) CTMDMY  - Capacitor bottom plate
//               Use "CTMDMY" to cover capacitor bottom plate in mixed-signal process.
// 13) INDDMY  - Dummy layer for inductor recognition in mixed-signal process.
//
// 14) LUPWDMY - DRC dummy layer to waive Latch-Up rules for verified IP. 
//
// 15) SBDDMY   - dummy layer to fully cover schottky barrier diode.
//
// 16) VSSDMY   - dummy layer to cover VSS PAD
//
// 17) VDDDMY   - dummy layer to cover VDD PAD
//-------------------------------------------------------------------------------------------
//
//                      CURRENT STATUS
//
//  RULES NOT IMPLEMENTED:
//
//  The following rules are not coded in this rule file:
//
//  rule                      description/explanation/alternate file
//  ------------------------  ----------------------------------------------------
//  Part I recommendations    Not coded (page 3 of spec.)
//
//  Antenna rules             Please refer to Antenna DRC deck.
//
//  Passivation rules         Please refer to Bond PAD DRC deck.
//
//  Metal Fuse rules          Please refer to Metal Fuse DRC deck.
//
//  SRAM rules                Not coded.
//
//  Chip Corner Power Line    Only ADP.W.1, ADP.W.2, ADP.S.1, ADP.E.1, ADP.E.2, ADP.C.1 and ADP.C.2 are coded.
//  and Dummy PAD             
//

//  Un-Checkable rules        RES.1(R), DNW.R.3(R), DNW.R.6, RES.HRI.6(R), SBD.R.7(R), CTM.R.4(R), 
//							  MIMVIA.S.1/S.2(R), MIMVIA.R.1(R), DOD.C.3(R) and DPO.C.3(R) 
//
//  * Guidelines implemented :
//
//    1) Partial I/O ESD GuideLines are implemented: 1,3-10,18-39
//       Others are not implemented because of guideline.
//
//    2) Partial LatchUp GuideLines are implemented: 1-6
//       Others are not implemented because of guideline.
//
//    3) Dummy PAD Guidlines implemented: ADP.S.2, ADP.W.3 and ADP.W.4
//
//    4) Metal stress relief guideline rules are not implemented.
//





//-------------------------------------------------------------------------------------------
//	
//  * To correctly use this DRC deck, the following settings are very important in
//    this DRC command file:
//	
//  (0) Calibre v2010.4_26.16 (Dec. 2010) is used to develop and QA this command file. 
//      Please execute the DRC with this or newer TSMC qualified version of Calibre.
//
//==================================================================================================================
//
//
//  Pay attention to!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
//     
//     Pls turn on switch (#DEFINE C016) if you use 0.16um process, Otherwise, It will cause a big risk.        
//     Pls turn on switch (#DEFINE C0152) if you use 0.152um process, Otherwise, It will cause a big risk.
//
//
//
//
//******************************************************************************************************************
//  This drc deck can be used to do check for C018 and C016 process as below:
//     
//       a. For 0.18um process
// 
//             1) C018 logic 1.8V/3.3V process (general purpose)     
//             2) C018 logic 1.8V/3.3V process (low power)           
//             3) C018 logic 1.8V/5V process   (general purpose)     
//             4) C018 logic 1.8V/5V process   (low power)           
//             5) C018 logic 1.5V/3.3V process (low voltage)         
//             6) C018 logic 1.5V/2.5V process (low voltage)         
//             7) C018 Mixed-Singal/RF 1.8V/3.3V process              
//	           8) C018 RF SBD 1.8V/3.3V process
//
//       b. For 0.16um process
// 
//             1) C016 logic/Mixed-Singal 1.8V/3.3V process          
//
//       c. For 0.152um process
// 
//             1) C0152 logic/Mixed-Singal 1.8V/3.3V process          
//
//     Note: The default of this DRC command file is for 0.18um logic 1.8V/3.3V(general purpose) design rule
//           you can turn on/off relted switch correctly if other process are used,.
//                  
//                    turn on in calibre drc  means remove "//" in the front of "#DEFINE XXXX"
//                    turn off in calibre drc means add "//" in the front of "#DEFINE XXXX"  
//
//********************************************************************************************************************
// 
//  There are some MUST switchs and OPTIONAL switchs in this drc deck. You must keep MUST switch turn on or trun off correctly.
//  Otherwise, you could not check drc correctly. As to OPTIONAL switch, you can turn on/off according to you requirement.
//  The default of this DRC command file is for 0.18um logic 1.8V/3.3V(general purpose) design rule
//  
//
//   MUST switch: 
//              
//     #DEFINE 3.3V 	    // turn on only when HIGH_VOLTAGE is 3.3V,otherwise please turn off it.
//   //#DEFINE 2.5V 	    // turn on only when HIGH_VOLTAGE is 2.5V,otherwise please turn off it
//   //#DEFINE 5V 	    // turn on only when HIGH_VOLTAGE is 5V  ,otherwise please turn off it
//     
//     #DEFINE 1.8V         // turn on only when CORE_VOLTAGE is 1.8V,otherwise please turn off it
//   //#DEFINE 1.5V 	    // turn on only when CORE_VOLTAGE is 1.5V,otherwise please turn off it
//
//   //#DEFINE LP           // turn on only when you use Low Power process,otherwise please turn off it 
//   //#DEFINE C016         // turn on only when you use 0.16um process,otherwise please turn off it
//   //#DEFINE C0152        // turn on only when you use 0.152um process,otherwise please turn off it
//   //#DEFINE MIX_MODE     // turn on only when you use Mixed-Singal/RF process,otherwise please turn off it
//                 
//   //#DEFINE THICK_40K    // turn on only when 40KA Thick Top Metal is used.otherwise please turn off it
//   //#DEFINE THICK_20K    // turn on only when 20KA Thick Top Metal is used.otherwise please turn off it   

//                          
// OPTIONAL switch:
//
//   //#DEFINE CHECK_SRAM_EXCL  // turn on  when M2 and upward layers in SRAM region covered by EXCL are checked.
//     #DEFINE CHECK_ALRDL      // turn off when MD&VIAD rules are not checked.

//     #DEFINE CHECK_DUMMY_ODPO // turn off when Dummy OD&PO are not checked.
//   //#DEFINE Recommend        // turn on  when Recommended rules are checked.
//     #DEFINE GUIDELINE_LUP    // turn off when you don't want check latchup guideline rules.   
//     #DEFINE GUIDELINE_ESD    // turn off when you don't want check ESD guideline rules.
//   //#DEFINE CHECK_LATCHUP_BY_TEXT        	// Turn on to recognize IO PAD by following text
//
// For example:
//  
//    1) If your design use 0.18um Mixed-Singal/RF 1.8V/3.3V process.
// 
// Please turn on MUST switchs (#DEFINE 3.3V ; #DEFINE 1.8V; #DEFINE MIX_MODE; #DEFINE THICK_40K or #DEFINE THICK_20K) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//    
//    2) If your design use 0.18um logic 1.8V/5V Low Power process.
// 
// Please turn on MUST switchs (#DEFINE 5V; #DEFINE 1.8V; #DEFINE LP ) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//
//    3) If your design use 0.18um logic 1.5V/3.3V low voltage process.
// 
// Please turn on MUST switchs (#DEFINE 1.5V; #DEFINE 3.3V ). 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement
//
//    
//    4) If your design use 0.16um logic 1.8V/3.3V process.
// 
// Please turn on MUST switchs (#DEFINE 3.3V ; #DEFINE 1.8V; #DEFINE C016 ) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//
//    5) If your design use 0.16um Mixed-Singal 1.8V/3.3V process.
// 
// Please turn on MUST switchs (#DEFINE 3.3V ; #DEFINE 1.8V; #DEFINE C016; #DEFINE MIX_MODE ) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//    
//    6) If your design use 0.152um Mixed-Singal 1.8V/3.3V process.
// Please turn on MUST switchs (#DEFINE 3.3V ; #DEFINE 1.8V; #DEFINE C0152; #DEFINE MIX_MODE ) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//
//********************************************************************************************************************
//
//  (1) Process selection:
//      
//      The default of this DRC command file is for 0.18um logic 1.8V/3.3V(general purpose) design rule(T-018-LO-DR-001)
//      If other process are used, Pls turn on you use process switch and turn off other process switch.
//
//              //#DEFINE LP       // turn on only when you use Low Power process,otherwise please turn off it  
//              //#DEFINE C016     // turn on only when you use 0.16um process,otherwise please turn off it
//              //#DEFINE C0152     // turn on only when you use 0.152um process,otherwise please turn off it

//  (2) Variable for High Voltage:
//
//	The default of this DRC command file assumes 3.3V is used as high (I/O) voltage.
//	If other high voltages are used, please DEFINE other variables. For example,
//	if 2.5V is used as high voltage, then the settings should be:
//
//		//#DEFINE 3.3V 	// when HIGH_VOLTAGE is 3.3V
//		#DEFINE 2.5V 	// when HIGH_VOLTAGE is 2.5V
//		//#DEFINE 5V 	// when HIGH_VOLTAGE is 5V
//	
//
//  (3) Variable for Core Voltage:
//
//	The default of this DRC command file assumes 1.8V is used as core voltage.
//	If other core voltages are used, please DEFINE other variables. For example,
//	if 1.5V is used as core voltage, then the settings should be:
//
//		//#DEFINE 1.8V 	// when CORE_VOLTAGE is 1.8V
//		#DEFINE 1.5V 	// when CORE_VOLTAGE is 1.5V
//
//  (4) Variable for High Voltage & Core Voltage:
//
//	Please choose proper voltages for the core and I/O devices in the logic section.
//	The setting should be:
//
//		#DEFINE 3.3V 	// when HIGH_VOLTAGE is 3.3V
//		//#DEFINE 2.5V 	// when HIGH_VOLTAGE is 2.5V
//		//#DEFINE 5V 	// when HIGH_VOLTAGE is 5V
//		#DEFINE 1.8V 	// when CORE_VOLTAGE is 1.8V
//		//#DEFINE 1.5V 	// when CORE_VOLTAGE is 1.5V
//
//	To execute the runset with I/O voltage equals 3.3V and core voltage as 1.8V.
//

//  (5) Variable for check SRAM inside layer EXCL:
//
//	By default, we include DRC check inside SRAM region covered by exclude layer "EXCL(55)".
//	However, customers could turn off this option to check M2 and upward layers inside EXCL
//	in order to check logic rules inside SRAM.
//	Please notice that by default, this option will disable the waiving function of EXCL, 
//	and the region covered by EXCL will be examined with M2 and upward layers' rules.
//	Please add // to this option:
//
//		//#DEFINE CHECK_SRAM_EXCL
//
//  (6) Sealring option: 
//  By default, this option is enable for whole chip layout with sealring structure.
//  Chip corner, Sealring, Assembly isolation, chip edge, and exclusion for density check will be affected 
//  by this options. If sealring is not assembled in chip layout, please turn off this option.     
//  If the option "FULL_CHIP" is disable, this option does not work.
//		//#DEFINE WITH_SEALRING
//
//  (7) Variable for MD&VIAD rule checking:
//
//	By default, MD&VIAD rules are checked in this deck. If MD&VIAD rules are not required
//	to check, please add // to this option:
//
//		//#DEFINE CHECK_ALRDL
//

//  (8) Variable for dummy OD&PO rule checking:
//
//	By default, dummy OD&PO are not checked by rules in this deck. But some unnecessary rule 
//	checks may induce false alarm. If dummy OD&PO are required to check, please
//	remove // to this option:
//
//		#DEFINE CHECK_DUMMY_ODPO
//
//	Note: If this option is disabled, please make sure the LVS result is correct after 
//	      dummy insertion to prevent from dummy pattern induced layout circuit short.
//
//  (9) Variable for Mixed-Signal/RF circuit design:
//
//	By default, this DRC deck is used for Mixed-Signal/RF process. When this DRC deck is
//	used for general Logic process, please add // to this option:
//
//		//#DEFINE MIX_MODE
//

//  (10) FULL_CHIP :
//    By default, this option is for whole chip layout for the rules about sealring and dummy PAD.   
//    If the layout is a cell, please add // to this option.
//            
//              //#DEFINE FULL_CHIP
//
//  (11) Variable for Thick Top Metal check:
//
//	By default, the Top Metal is Normal Top Metal. If customer uses 20KA or 40KA Thick Top 
//	Metal, please remove // to the option 'THICK_40K' or 'THICK_20K',But only one should be turn on every time.
//
//	For 20k Top metal:
//		//#DEFINE THICK_40K
//		#DEFINE THICK_20K
//
//	For 40k Top metal:
//		#DEFINE THICK_40K
//		//#DEFINE THICK_20K

//  (12) Variable for recommended rule check:
//
//	By default, recommended rules are not checked, but it is suggested to remove // to 
//	enable this option from the point of view of noise isolation and SPICE model accuracy.

//	The recommended rule check includes NW.R.1, NWR.R.7, OD.C.7, VIAx.E.3, VIAn.E.3, CB.W.3, UTM20K/40K.I.3, 
//  UTM20K/40K.C.1, ESDIMP.EN.1, DNW.E.1, DNW.S.2, AN.R.41m, DPO.R.1, and RES rules.
//
//		#DEFINE Recommend
//

//  (13) Latch-up guideline check:
//
//	By default, This command file will check Latch-up guideline rules,
//	please add // if you don't want check these rules:
//
//		//#DEFINE GUIDELINE_LUP
//
//  (14) DISCONNECT_ALL_RESISTOR & CONNECT_ALL_RESISTOR:
//  By default, the connection is broken by resistors with dummy layer RES200 for Latch-Up rule checks. 
//  The switches of DISCONNECT_ALL_RESISTOR and CONNECT_ALL_RESISTOR can control the connectivity of resistor.
//  Turn on DISCONNECT_ALL_RESISTOR option will disconnect all resistors between pad and device for Latch-Up rule check.
//  Turn on CONNECT_ALL_RESISTOR option will connect all resistors between pad and device for Latch-Up rule check.
//	    //#DEFINE DISCONNECT_ALL_RESISTOR 
//		//#DEFINE CONNECT_ALL_RESISTOR
//
//  (15) ESD guideline check:
//
//	By default, This command file will check ESD guideline rules,
//	please add // if you don't want check these rules:
//
//      	//#DEFINE GUIDELINE_ESD
//
//  (16) Variable CHECK_LATCHUP_BY_TEXT:
//     DRC uses CB/CBD/CB2/UBM layer to recognize PAD, and uses the connection
//     of well strap to distinguish IO PAD and VDD/VSS PAD. So latch-up rules can not be
//     checked in cell level if no CB/CBD/CB2/UBM layer exists. Also,if VDD/VSS pad is not
//     connected to strap, it will be falsely recognized as IO pad. 
//     You can remove // this option to solve these inconveniences. Assign the PAD/VDD/VSS pin name in
//     Variables (PAD_TEXT/VDD_TEXT/VSS_TEXT). Notice that only text by metal pin layer in top cell
//     is used for latch-up check.
//
//     By default, the switch CHECK_LATCHUP_BY_TEXT is off. If you want to recognize VDD/VSS/PAD by pin name,
//     you could remove // this switch as follow:
//
//              #DEFINE CHECK_LATCHUP_BY_TEXT
//
//  (17) DENSITY_IN_BLOCKAGE :
//      By default, this option is for local density check. 
//      If customer want to check local density within blockage layers only, please remove // to this option.
//
//              #DEFINE DENSITY_IN_BLOCKAGE
//
//  (18) BigSealringCorner option:
//      If customer requests TSMC to add chip corner stress relief pattern, seal ring and CDU,
//	    empty areas in 4 chip corners must be reserved and no layout is allowed inside. 
//	    By default, this option is enabled and "big seal-ring corner" will be used as chip 
//      corner stress relief patterns.
//	            #DEFINE BigSealringCorner
//	            // #DEFINE SmallSealringCorner  
//
//  (19) SmallSealringCorner option:
//  	If customer requests TSMC to add chip corner stress relief pattern, seal ring and CDU,
//	    empty areas in 4 chip corners must be reserved and no layout is allowed inside. 
//      If "SmallSealringCorner" structure is used as chip corner stress relief patterns in 
//      your design, please remove // this option for proper checking as below :
//              // #DEFINE BigSealringCorner  
//              #DEFINE SmallSealringCorner  
//     
//  (20) AAIO :
//		Plese remove // to turn on for treat OD injector as same as AAIO .
//		#DEFINE ALL_AREA_IO
//      
//---------------------------------------------------------------------


//-------------------------------------------------------------------------------------------
// OPTION SETUP
//===============
#DEFINE CHECK_SRAM_EXCL // turn on only when you want check M2 and upward layers in SRAM region covered by EXCL. otherwise please turn off it

#DEFINE CHECK_ALRDL       // turn on only when you want check MD&VIAD rules. otherwise please turn off it

//#DEFINE CHECK_DUMMY_ODPO  // turn on only when you want check Dummy OD&PO. otherwise please turn off it

#DEFINE GUIDELINE_LUP     // turn on only when you want check latchup guideline rules. otherwise please turn off it
//#DEFINE DISCONNECT_ALL_RESISTOR    // turn on only when you want to disconnect all resistors to check latchup rules, otherwise please turn off it
//#DEFINE CONNECT_ALL_RESISTOR       // turn on only when you want to connect all resistors to check latchup rules, otherwise please turn off it
#DEFINE GUIDELINE_ESD     // turn on only when you want check ESD guideline rules. otherwise please turn off it
//#DEFINE Recommend       // turn on only when you want to check Recommended rules. otherwise please turn off it



//#DEFINE MIX_MODE          // turn on only when you use Mixed-Singal/RF process. otherwise please turn off it

//#DEFINE THICK_40K       // turn on only when 40KA Thick Top Metal is used. otherwise please turn off it
#DEFINE THICK_20K       // turn on only when 20KA Thick Top Metal is used. otherwise please turn off it


//#DEFINE LP          // turn on only when you use Low Power process. otherwise please turn off it 
//#DEFINE C016        // turn on only when you use 0.16um process. otherwise please turn off it
//#DEFINE C0152       // turn on only when you use 0.152um process. otherwise please turn off it

#DEFINE 3.3V 	// turn on only when HIGH_VOLTAGE is 3.3V. otherwise please turn off it
//#DEFINE 5V 	// turn on only when HIGH_VOLTAGE is 5V. otherwise please turn off it
//#DEFINE 2.5V 	// turn on only when HIGH_VOLTAGE is 2.5V. otherwise please turn off it

#DEFINE 1.8V 	// turn on only when CORE_VOLTAGE is 1.8V. otherwise please turn off it
//#DEFINE 1.5V 	// turn on only when CORE_VOLTAGE is 1.5V. otherwise please turn off it

//#DEFINE CHECK_LATCHUP_BY_TEXT       // Turn on to recognize IO PAD by following text  
VARIABLE PAD_TEXT  "?"       // pin name of PAD
VARIABLE VDD_TEXT  "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA"    // pin name of VDD
VARIABLE VSS_TEXT  "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG"    // pin name of VSS 
#DEFINE FULL_CHIP           // Turn on for chip level design of sealring and dummy PAD, otherwise please turn off it.

//#DEFINE DENSITY_IN_BLOCKAGE     // turn on only when to check density within blockage layers
#DEFINE BigSealringCorner         // Turn on to use big seal-ring corner for whole chip design
//#DEFINE SmallSealringCorner     // Turn on to use small seal-ring corner for whole chip design
//#DEFINE WITH_SEALRING			// Turn on to check sealring rules

//#DEFINE ALL_AREA_IO   // Turn on for treat OD injector as same as AAIO

//
// ENVIRONMENT SETUP
//------------------
PRECISION    1000
RESOLUTION     5   //Set layout grid  check to 0.005

LAYOUT SYSTEM GDSII
LAYOUT PATH "GDSFILENAME"
LAYOUT PRIMARY "TOPCELLNAME"

DRC RESULTS DATABASE "DRC_RES.db"
DRC SUMMARY REPORT "DRC.rep" 
DRC CHECK TEXT ALL
DRC MAXIMUM RESULTS ALL
//DRC INCREMENTAL CONNECT YES

FLAG OFFGRID YES     // For layout grid check. default grid value is resolution size
FLAG ACUTE YES
FLAG SKEW YES
FLAG NONSIMPLE YES
FLAG NONSIMPLE PATH YES

LAYOUT PROCESS BOX RECORD YES



VARIABLE  GRID      0.005
VARIABLE  G_1 		5

VARIABLE UTM40K_W_1 2.6
VARIABLE UTM40K_S_1 2.5 
VARIABLE UTM40K_A_1 6.76
VARIABLE UTM40K_C_1 50.0
VARIABLE UTM40K_R_1 30
VARIABLE UTM40K_R_2 80
VARIABLE UTM40K_R_3 5
VARIABLE UTM40K_A_2 75 
VARIABLE UTM40K_A_2_S 10

VARIABLE UTM40K_E_3 10.0



VARIABLE UTM20K_W_1 1.5
VARIABLE UTM20K_S_1 1.5
VARIABLE UTM20K_A_1 2.25
VARIABLE UTM20K_C_1 50.0

VARIABLE UTM20K_E_3 10.0
VARIABLE MHOLE 10.0





VARIABLE NT_N_S_1 0.86
VARIABLE NT_N_E_1 0.26
VARIABLE NT_N_C_1 0.52
VARIABLE NT_N_C_2 1.66
VARIABLE OD_W_3_J 0.42
VARIABLE OD_W_3_T 0.8


VARIABLE OD_C_7 0.36

VARIABLE OD_C_2_1 0.6
VARIABLE OD_C_4_1 0.8


VARIABLE OD2_W_1 0.6

VARIABLE PO_C_2   0.32
VARIABLE PP_W_1   0.44
VARIABLE PP_S_1   0.44
VARIABLE PP_C_1   0.26
VARIABLE PP_C_5   0.32
VARIABLE PP_E_1   0.18
VARIABLE PP_E_6   0.18
VARIABLE PP_E_6_2   0.18
VARIABLE NP_W_1   0.44
VARIABLE NP_S_1   0.44
VARIABLE NP_C_1   0.26
VARIABLE NP_C_5   0.32
VARIABLE NP_E_1   0.18
VARIABLE RPO_S_1  0.43
VARIABLE RPO_C_2  0.22
VARIABLE CO_E_3   0.12
VARIABLE CO_E_4   0.12
VARIABLE M1_S_2   0.6
VARIABLE M1_S_2_1 0.6
VARIABLE M1_S_2_2 0.6
VARIABLE M1_S_2_L 35.0 
VARIABLE M2_S_2_1 0.6
VARIABLE M2_S_2_2 0.6
VARIABLE M2_S_2_L 35.0 
VARIABLE M3_S_2_1 0.6
VARIABLE M3_S_2_2 0.6
VARIABLE M3_S_2_L 35.0 
VARIABLE M4_S_2_1 0.6
VARIABLE M4_S_2_2 0.6
VARIABLE M4_S_2_L 35.0 
VARIABLE M5_S_2_1 0.6
VARIABLE M5_S_2_2 0.6
VARIABLE M5_S_2_L 35.0 
VARIABLE M6_S_2_1 0.6
VARIABLE M6_S_2_2 0.6
VARIABLE M6_S_2_L 35.0 
VARIABLE MD_S_2_1 0.6
VARIABLE MD_S_2_2 0.6
VARIABLE MD_S_2_L 35.0 



VARIABLE M1_A_1   0.202
VARIABLE Mx_A_1   0.202
VARIABLE VIAn_W_1 0.36
VARIABLE VIAn_S_1 0.35
VARIABLE VIAD_W_1 0.36
VARIABLE VIAD_S_1 0.35
VARIABLE NT_N_S_2 1.66
VARIABLE DOD_DN_1_W 150
VARIABLE DOD_DN_1_S 75
VARIABLE DOD_DN_1 0.2
VARIABLE DOD_DN_2_W 150
VARIABLE DOD_DN_2_S 75
VARIABLE DOD_DN_2 0.8
#IFDEF C016
VARIABLE SR_S_1   5.5
#ELSE
#IFDEF C0152
VARIABLE SR_S_1   5.95
#ELSE
VARIABLE SR_S_1   5.0
#ENDIF
#ENDIF
VARIABLE SR_E_1   0.6
VARIABLE SR_E_2   4.1
VARIABLE CO_W_2   0.22
VARIABLE VIA1_W_2 0.26
VARIABLE VIA2_W_2 0.26
VARIABLE VIA3_W_2 0.26
VARIABLE VIA4_W_2 0.26
VARIABLE VIAn_W_2 0.36


VARIABLE NW_S_3 2.0
VARIABLE NW_S_4 2.0
VARIABLE NT_N_W_1 0.74
VARIABLE PO_C_3 0.15
VARIABLE PO_C_4 0.15
VARIABLE RES_2_W 1.0
VARIABLE RES_13 0.2
VARIABLE RES_14 0.6

VARIABLE RES_2_Nsq 5.0
VARIABLE RES_12_W 2.0
VARIABLE RES_12_Nsq 5.0
VARIABLE RES_HRI_9 0.6


VARIABLE RES_HRI_12 0.25
VARIABLE VIA2_E_3 0.06
VARIABLE VIA3_E_3 0.06
VARIABLE VIA4_E_3 0.06
VARIABLE VIA5_E_3 0.06
VARIABLE VIAD_E_3 0.06

VARIABLE ESD_3g 360.0

VARIABLE ESD_5g   2000.0
VARIABLE ESD_5_1g 1800.0


VARIABLE ESD_10g 2.4

VARIABLE ESDIMP_W_1 0.6
VARIABLE ESDIMP_S_1 0.6
VARIABLE ESDIMP_S_2 0.6
VARIABLE ESDIMP_EN_1 0.4
VARIABLE ESDIMP_A_1 1.0
VARIABLE ESDIMP_A_2 1.0
VARIABLE DNW_W_1_0152 3.570
VARIABLE DNW_S_1_0152 5.950

VARIABLE PO_R_2 50.0




VARIABLE MIM_M5_W_1 35.0
VARIABLE MIM_M5_S_1 0.80
VARIABLE MIM_M5_S_2 0.80
VARIABLE MIM_M5_E_3 0.40
VARIABLE CTM_W_1  4.0
VARIABLE CTM_W_2  0.4
VARIABLE CTM_S_1  1.2
VARIABLE CTM_S_2  0.8
VARIABLE CTM_W_4  30.0
VARIABLE CTM_A_1  0.202
VARIABLE MIMVIA_S_1 2.00
VARIABLE MIMVIA_S_2 4.00
VARIABLE MIMVIA_E_1 0.24
VARIABLE MIMVIA_E_2 0.12
VARIABLE MIMVIA_C_1 0.40



VARIABLE ANALOGDMY_A_1 1.71
VARIABLE ANALOGDMY_EX_1 0.32
VARIABLE ANALOGDMY_EX_2 0.4
VARIABLE ANALOGDMY_S_1 0.45
VARIABLE ANALOGDMY_S_2 0.32
VARIABLE ANALOGDMY_S_3 0.4
VARIABLE ANALOGDMY_S_4 0.26
VARIABLE ANALOGDMY_W_1 1.26
VARIABLE 3DMIM_A_1 0.202
VARIABLE 3DMIM_A_2 0.202
VARIABLE 3DMIM_EX_1 0.4
VARIABLE 3DMIM_EX_2 0.24
VARIABLE 3DMIM_EX_3 0.4
VARIABLE 3DMIM_EX_4 0.24
VARIABLE 3DMIM_EX_5 0.12
VARIABLE 3DMIM_S_1 0.4
VARIABLE 3DMIM_S_2 2
VARIABLE 3DMIM_S_3 2
VARIABLE 3DMIM_S_4 1.2
VARIABLE 3DMIM_S_5 0.8
VARIABLE 3DMIM_S_6 4
VARIABLE 3DMIM_S_7 0.4
VARIABLE 3DMIM_S_8 0.8
VARIABLE 3DMIM_S_9 0.8
VARIABLE 3DMIM_S_10 4
VARIABLE 3DMIM_W_1 4.0
VARIABLE 3DMIM_W_2 0.4
VARIABLE 3DMIM_W_3 0.6
VARIABLE 3DMIM_W_4 0.8
VARIABLE 3DMIM_W_5 30.0
VARIABLE 3DMIM_W_6 4.0
VARIABLE MOM_S_2 0.5
VARIABLE MOM_A_1 1.64E15
VARIABLE RPO_A_2 1.0
VARIABLE OD_EX_1 0.18
VARIABLE M1_W_1 0.23
VARIABLE M1_S_1 0.23
VARIABLE M2_W_1 0.28
VARIABLE M2_S_1 0.28
VARIABLE M3_W_1 0.28
VARIABLE M3_S_1 0.28
VARIABLE M4_W_1 0.28
VARIABLE M4_S_1 0.28
VARIABLE M5_W_1 0.28
VARIABLE M5_S_1 0.28
#IFDEF THICK_40K
VARIABLE M6_W_1 2.6
VARIABLE M6_S_1 2.5
#ELSE

#IFDEF THICK_20K
VARIABLE M6_W_1 1.5
VARIABLE M6_S_1 1.5
#ELSE
VARIABLE M6_W_1 0.44
VARIABLE M6_S_1 0.46
#ENDIF

#ENDIF
VARIABLE M1_THICKNESS 0.53      // The Thickness of Inter Metal is 4K A
VARIABLE M2_THICKNESS 0.53      // The Thickness of Inter Metal is 4K A
VARIABLE M3_THICKNESS 0.53      // The Thickness of Inter Metal is 4K A
VARIABLE M4_THICKNESS 0.53      // The Thickness of Inter Metal is 4K A
VARIABLE M5_THICKNESS 0.53      // The Thickness of Inter Metal is 4K A
#IFDEF THICK_40K
VARIABLE M6_THICKNESS 4.6       // The Thickness of Top Metal is 40K A
#ELSE

#IFDEF THICK_20K
VARIABLE M6_THICKNESS 2.34     // The Thickness of Top Metal is 20K A
#ELSE
VARIABLE M6_THICKNESS 0.99    // The Thickness of Top Metal is 8K A
#ENDIF

#ENDIF


// DRAWN LAYER DEFINITIONS
//------------------------
LAYER NWELii	2	// Nwell technology
LAYER ULLNWi  128      // Nwell for ULL devices
LAYER ODLLi	101	// Define LL device region
LAYER DIFFi	3	// Active areas

LAYER DOD	1340	// Dummy OD (DIFF)
LAYER MAP 3   DATATYPE 1 1340	// Mapping (3;1) to 1340 for dummy OD
LAYER ODBLK	1350	// DOD blocking for insertion
LAYER MAP 150 DATATYPE 20 1350
LAYER PDIFFi	11	// Active areas
LAYER NDIFFi	12	// Active areas
LAYER OD2i	4	// Define thick gate oxides
LAYER POLYi	13	// Polysilicon gates, interconnect
LAYER DPO	1342	// Dummy Poly
LAYER MAP 13  DATATYPE 1 1342	// Mapping (13;1) to 1342 for dummy PO
LAYER POBLK	1351	// DPO blocking for insertion
LAYER MAP 150 DATATYPE 21 1351
LAYER PPi	7	// P+ S/D imlant
LAYER NPi	8	// N+ S/D imlant

LAYER NLVTi	405
LAYER MAP 141 DATATYPE 63 405

LAYER DTi       171     // Deep trench 
LAYER DTBLK  2046  // Deep trench block
LAYER MAP 171 DATATYPE 2 2046
LAYER FLASH	94	// FLASH IP outline


LAYER BJTDUMMY	49	// BJT dummy LAYER
LAYER DIODUMMY	56	// Diode dummy layer
LAYER RPDUMMY   54
LAYER COi	15	// Define connection from M1 to S/D and Gate
LAYER M1i	16	// First Metal layer
LAYER VIA1i	17	// Define connection from M2 to M1
LAYER M2i	18	// Second Metal layer
LAYER VIA2i	27	// Define connection from M3 to M2
LAYER M3i	28	// Third Metal layer
LAYER VIA3i	29	// Define connection from M4 to M3
LAYER M4i	31	// Fourth Metal layer
LAYER VIA4i	32	// Define connection from M5 to M4
LAYER M5i	33	// Fifth Metal layer
LAYER VIA5i	39	// Define connection from M6 to M5
LAYER M6i	38	// Sixth Metal layer  
LAYER M1_PIN_TEXT	4000
LAYER MAP 40 TEXTTYPE 0	4000
LAYER M2_PIN_TEXT	4100
LAYER MAP 41 TEXTTYPE 0	4100
LAYER M3_PIN_TEXT	4200
LAYER MAP 42 TEXTTYPE 0	4200
LAYER M4_PIN_TEXT	4300
LAYER MAP 43 TEXTTYPE 0	4300
LAYER M5_PIN_TEXT	4400
LAYER MAP 44 TEXTTYPE 0	4400
LAYER M6_PIN_TEXT	4500
LAYER MAP 45 TEXTTYPE 0	4500


LAYER VIADi	167	// Define connect from MD to Top Metal
LAYER MDi	168	// RDL Metal layer above Top Metal
LAYER MD_PIN_TEXT	15900
LAYER MAP 159 TEXTTYPE 0	15900
LAYER CBi	19	// Passivation opening for Bond Pad
LAYER CBDi	169	// Definition of passivation window for bump
LAYER UBMi	170	// Bond Pad definition for RDL
LAYER PPIi	189	// Post Passivation RDL
LAYER RPOi	34	// Salicided Block Layer
LAYER NTNi	129	// Native NMOS blocked implantation
LAYER PLMIDEi	89	// Polymide (if drawn)
//LAYER  FUSEi	235	// Fuse window
LAYER DNWi	82	// Deep N-WELL
LAYER VTMPi	23	// Blocking region of PMOS VT implantation
LAYER VTMNi	24	// Blocking region of NMOS VT implantation
LAYER PV_P	71	// PV_P pmos varactor p+ implant layer
LAYER PV_N	72	// PV_N pmos varactor n+ blocking layer
LAYER HRIi	48	// High Resistor implant

// Dummy Metal layers
//-------------------
LAYER MAP 16  DATATYPE 1 316
LAYER M1DMY	316	// Metal1 dummy (if drawn)
LAYER MAP 18  DATATYPE 1 318
LAYER M2DMY	318	// Metal2 dummy (if drawn)
LAYER MAP 28  DATATYPE 1 329
LAYER M3DMY	329	// Metal3 dummy (if drawn)
LAYER MAP 31  DATATYPE 1 331
LAYER M4DMY	331	// Metal4 dummy (if drawn)
LAYER MAP 33  DATATYPE 1 333
LAYER M5DMY	333	// Metal5 dummy (if drawn)
LAYER MAP 38  DATATYPE 1 338
LAYER M6DMY	338	// Metal6 dummy (if drawn)
LAYER MAP 168 DATATYPE 1 340
LAYER MDDMY	340    	// MD dummy (if drawn)

// Metal Slot layers
//------------------
LAYER MAP 16  DATATYPE 2 321
LAYER M1SLOTi	321	// Metal1 slot (if drawn)
LAYER MAP 18  DATATYPE 2 322
LAYER M2SLOTi	322	// Metal2 slot (if drawn)
LAYER MAP 28  DATATYPE 2 323
LAYER M3SLOTi	323	// Metal3 slot (if drawn)
LAYER MAP 31  DATATYPE 2 324
LAYER M4SLOTi	324	// Metal4 slot (if drawn)
LAYER MAP 33  DATATYPE 2 325
LAYER M5SLOTi	325	// Metal5 slot (if drawn)
LAYER MAP 38  DATATYPE 2 326
LAYER M6SLOTi	326	// Metal6 slot (if drawn)
LAYER MAP 168 DATATYPE 2 328
LAYER MDSLOTi	328	// MD slot (if drawn)

// Capacitor Top Metal Layers
//---------------------------

LAYER MAP 67  DATATYPE 2 257
LAYER CTM2i	257	// Capacitor Top Metal-2
LAYER MAP 67  DATATYPE 3 258
LAYER CTM3i	258	// Capacitor Top Metal-3
LAYER MAP 67  DATATYPE 4 259
LAYER CTM4i	259	// Capacitor Top Metal-4
LAYER MAP 67  DATATYPE 5 260
LAYER CTM5i	260	// Capacitor Top Metal-5

// Dummy Layers
//-------------
LAYER HOTWL	51	// Hot N-Well (SEE README HOT_NWEL NOTES)
LAYER EXCLi	55	// Exclude layer
LAYER DRCDMY	60	// DRC I/O waiver
LAYER RWDMY	52	// NWEL Resistor dummy layer
LAYER DPDMY	65	// Dummy Pad area dummy layer
LAYER PLDMY	66	// Power Line area dummy layer
LAYER SDI	58	// IO ESD region dummy layer
LAYER MAP 58 DATATYPE 3 583
LAYER HIADMY	583
LAYER ESD1DMY	136	// IO ESD region dummy layer, RPO must enclose whole gate
LAYER ESD2DMY	137	// IO ESD region dummy layer, RPO enclose gate 0.05 for 3.3V
LAYER ESD3DMY	234
LAYER CTMDMY	131	// Cover metal as a capacitor bottom plate
LAYER RLPPDMY	134	// HRI high Poly resistor dummy layer
LAYER DMN2V	184	// Dummy layer to ensure N2V in N+ poly/OD resistor
LAYER DMP2V	149	// Dummy layer to ensure P2V in P+ poly/OD resistor
LAYER VARDMY	138	// Dummy layer to cover varactor device
LAYER PMDMY	236	// Dummy layer to cover fuse window and protection ring structur
LAYER FWi	235	// Fuse window when x, (x+1) = 3 
LAYER LMARK	263	// L target window for bump process
LAYER MAP 63  DATATYPE 1 263
LAYER LWI	363	// L target window for bump process
LAYER MAP 63  DATATYPE 2 363
LAYER WBDMY	183	// Dummy layer to cover the CUP pad
LAYER ESDi	30	// For 0.18um 1.8V/5V on i/o esd's implant only.
LAYER ESDIMPi 2504 // For 0.18um 3.3V esd NMOS only.
LAYER MAP 250 DATATYPE 4 2504
LAYER INDDMY	364	// Dummy layer to define inductor
LAYER MAP 139 DATATYPE 0 364
LAYER SEALRING	126	// SEAL-RING Layer used for SR.S.1 check
LAYER LOGO	178	// Dummy layer for product labels and LOGO
LAYER LUPWDMY     2551     // DRC dummy layer to waive Latch-Up rules for verified IP.
LAYER MAP 255 DATATYPE 1 2551
LAYER LUPWDMY_2	  25518   // Area Array IO LUP rules check
LAYER MAP 255 DATATYPE 18 25518

LAYER SBDDMY     1440 //A layer for DRC,LVS and creating mask logic operation Use "SBDDMY" to fully cover schottky barrier diode.
LAYER MAP 144 DATATYPE 0 1440
LAYER RFDUMMY     1601    // recognize RF dummy layer for LVS purpose.
LAYER MAP 160 DATATYPE 1 1601
LAYER RES200	  2559    // dummy layer to recognize 200 ohm or above resistor
LAYER MAP 255 DATATYPE 9 2559
LAYER MATCHING    1821    // dummy layer to enable pair check
LAYER MAP 182 DATATYPE 11 1821


LAYER MAP 255 DATATYPE 4   2554
LAYER	VDDDMY 2554
LAYER MAP 255 DATATYPE 5   2555
LAYER	VSSDMY 2555
LAYER TSVi    251      // TSV region define layer.



LAYER ANALOGDMY  2032
LAYER MAP  203 DATATYPE 2 2032
LAYER CMM 73
LAYER MAP 73  DATATYPE 2 267
LAYER CMM2i	267	// Capacitor Top Metal-2
LAYER MAP 73  DATATYPE 3 268
LAYER CMM3i	268	// Capacitor Top Metal-3
LAYER MAP 73  DATATYPE 4 269
LAYER CMM4i	269	// Capacitor Top Metal-4
LAYER MAP 73  DATATYPE 5 270
LAYER CMM5i	270	// Capacitor Top Metal-5
LAYER MOMDMY 145
LAYER MOMDMY_1 1451
LAYER MAP  145 DATATYPE 1 1451
LAYER MOMDMY_2 1452
LAYER MAP  145 DATATYPE 2 1452
LAYER MOMDMY_3 1453
LAYER MAP  145 DATATYPE 3 1453
LAYER MOMDMY_4 1454
LAYER MAP  145 DATATYPE 4 1454
LAYER MOMDMY_5 1455
LAYER MAP  145 DATATYPE 5 1455
LAYER MOMDMY_6 1456
LAYER MAP  145 DATATYPE 6 1456
LAYER MOMDMY_ALL 14510
LAYER MAP 145 DATATYPE 100 14510
LAYER MAP 145 DATATYPE >=1 <=6 14510 

LAYOUT TOP LAYER M1i VIA1i M1SLOTi M1DMY
LAYOUT TOP LAYER M2i VIA2i M2SLOTi M2DMY
LAYOUT TOP LAYER M3i VIA3i M3SLOTi M3DMY
LAYOUT TOP LAYER M4i VIA4i M4SLOTi M4DMY
LAYOUT TOP LAYER M5i VIA5i M5SLOTi M5DMY

LAYOUT TOP LAYER MDi VIADi MDSLOTi MDDMY M6i M6SLOTi M6DMY CBi 


M1xd = (M1i OR M1DMY) NOT M1SLOTi
M1x  = M1i NOT M1SLOTi

LAYER DM1EXCL	371
LAYER MAP 150 DATATYPE 1 371
M2xd = (M2i OR M2DMY) NOT M2SLOTi
M2x  = M2i NOT M2SLOTi

LAYER DM2EXCL	372
LAYER MAP 150 DATATYPE 2 372
M3xd = (M3i OR M3DMY) NOT M3SLOTi
M3x  = M3i NOT M3SLOTi

LAYER DM3EXCL	373
LAYER MAP 150 DATATYPE 3 373
M4xd = (M4i OR M4DMY) NOT M4SLOTi
M4x  = M4i NOT M4SLOTi

LAYER DM4EXCL	374
LAYER MAP 150 DATATYPE 4 374
M5xd = (M5i OR M5DMY) NOT M5SLOTi
M5x  = M5i NOT M5SLOTi

LAYER DM5EXCL	375
LAYER MAP 150 DATATYPE 5 375
M6xd = (M6i OR M6DMY) NOT M6SLOTi
M6x  = M6i NOT M6SLOTi

LAYER DM6EXCL	376
LAYER MAP 150 DATATYPE 6 376
MDxd = (MDi OR MDDMY) NOT MDSLOTi
MDx  = MDi NOT MDSLOTi
LAYER DMDEXCL	380
LAYER MAP 150 DATATYPE 15 380

/////////////////////////////////////////////////////////////////////////////////

// EXCLUDE UNCHECKED REGIONS
//--------------------------
CHIP         = EXTENT


BULK	= SIZE CHIP BY 1.0
EXCL = EXCLi NOT LOGO
#IFDEF CHECK_SRAM_EXCL
EXCL_S	= CHIP NOT BULK	// Use an empty layer to disable the usage of EXCL
#ELSE
EXCL_S	= COPY EXCL	// EXCL_S = EXCL
#ENDIF

// Front-End Layer
//----------------

#IFDEF C0152
NWELi = NWELii OR ULLNWi
#ELSE
NWELi = COPY NWELii
#ENDIF
PWELi = BULK NOT NWELi


ODi	= (DIFFi OR NDIFFi) OR PDIFFi

PWEL	= PWELi	NOT EXCL
NWEL	= NWELi	NOT INSIDE EXCL
DNW	= DNWi	NOT EXCL
ULLNW	= ULLNWi NOT INSIDE EXCL
LVNW = NWELii NOT INSIDE EXCL
ODLL = ODLLi NOT INSIDE EXCL
VTMP	= VTMPi	NOT EXCL
VTMN	= VTMNi	NOT EXCL
#IFDEF CHECK_DUMMY_ODPO
OD	= (ODi	OR  DOD) NOT EXCL
POLY	= (POLYi OR DPO) NOT EXCL
#ELSE
OD	= ODi	NOT EXCL
POLY	= POLYi	NOT EXCL
#ENDIF

OD2	= OD2i	NOT EXCL
PP	= PPi	NOT INSIDE EXCL
NP	= NPi	NOT INSIDE EXCL
CO	= COi	NOT EXCL






// Back-End Layer
//---------------


M1	= M1xd	NOT EXCL
M1_A	= M1xd  NOT INSIDE EXCL
VIA1	= VIA1i	NOT EXCL
M2	= M2xd	NOT INSIDE EXCL_S
VIA2	= VIA2i	NOT INSIDE EXCL_S
M3	= M3xd	NOT INSIDE EXCL_S
VIA3	= VIA3i	NOT INSIDE EXCL_S
M4	= M4xd	NOT INSIDE EXCL_S
VIA4	= VIA4i	NOT INSIDE EXCL_S
M5	= M5xd	NOT INSIDE EXCL_S
VIA5	= VIA5i	NOT INSIDE EXCL_S
M6	= M6xd	NOT INSIDE EXCL_S
VIAD	= VIADi	NOT INSIDE EXCL_S
MD	= MDxd	NOT INSIDE EXCL_S
CB	= CBi	NOT EXCL_S
CBD	= CBDi	NOT EXCL_S
RPO	= RPOi	NOT EXCL
NTN	= NTNi	NOT EXCL
PLMIDE	= PLMIDEi NOT EXCL_S
//FUSE	= FUSEi	NOT EXCL
FW	= FWi	NOT EXCL_S
LW	= LWI	NOT EXCL_S
HRI	= HRIi	NOT EXCL
ESD	= ESDi	NOT EXCL_S
ESDIMP = ESDIMPi NOT EXCL_S
CTM2	= CTM2i	NOT EXCL_S
CTM3	= CTM3i	NOT EXCL_S
CTM4	= CTM4i	NOT EXCL_S
CTM5	= CTM5i	NOT EXCL_S






// GLOBAL DERIVED LAYERS FOR RULE CHECKS 
//--------------------------------------

ALL_OD   = ODi     OR  DOD  		//For OD density check
ALL_PO   = POLYi  OR  DPO               //For POLY density check
NRODi	= ODi	NOT RPOi
NPODi	= NPi	AND NRODi
PPODi	= PPi	AND NRODi
NONWRi	= NWELi	NOT INTERACT RWDMY	// NWEL - NWR(OD) - NWR(STI)


NTAPi	= NPODi	AND NONWRi	// NWEL Pick-Up
NACTi	= NPODi	NOT NWELi	// NMOS Device
PTAPi	= PPODi	NOT NWELi	// Substrate(PWEL) Pick-Up
PACTi	= PPODi	AND NONWRi	// PMOS Device 
PSDi	= PACTi	NOT POLYi	// PMOS source/drain,separated
NSDi	= NACTi	NOT POLYi	// NMOS source/drain,separated  
ILP1i	= POLYi	NOT RPOi	// Interconnection poly

NPOD	= NP	AND OD		// N+ OD region
PPOD	= PP	AND OD		// P+ OD region



ALL_GATE = POLY AND OD          // Gate regions for NMOS and PMOS
POLY_ISO = POLY NOT OD          // Interconnect POLY
LVGT    = ALL_GATE NOT OD2      // 1.8V gate
HVGT    = ALL_GATE AND OD2      // 3.3V gate

RNWEL = NWEL  CUT RWDMY  // NWEL resistor (UNDER OD & STI)
NONWR	= NWEL	NOT RNWEL	// NWEL - NWR(OD) - NWR(STI)

NTAP	= NPOD	AND NONWR	// NWEL Pick-Up
NACT	= NPOD	NOT NWEL	// NMOS Device
PTAP	= PPOD	NOT NWEL	// Substrate(PWEL) Pick-Up
PACT	= PPOD	AND NWEL	// PMOS Device

GATE_W	= POLY INSIDE EDGE OD	// Gate width
GATE_L	= OD INSIDE EDGE POLY	// Channel length
GATE_NP	= ALL_GATE AND NP	// N+ Gate
GATE_PP	= ALL_GATE AND PP	// P+ Gate

FPO1	= COPY POLY_ISO		// Field poly
RPO_NOT_SDI = RPO NOT SDI
PORES	= FPO1 AND RPO_NOT_SDI	// POLY resistor region
ILP1	= POLY_ISO NOT RPO	// Interconnection poly
FFOD    = (OD OUTSIDE RWDMY) OUTSIDE ALL_GATE
ODRES	= FFOD AND RPO_NOT_SDI	// OD resistor region
ODRES_ALL = FFOD INTERACT RPDUMMY



DACT    = NACT OR PACT          // NMOS and PMOS Device
DSTP    = NTAP OR PTAP          // NWEL and PWEL Pick-Up
IMP     = PP OR NP              // N+ and P+ implant 
HRDMY	= (DMP2V OR DMN2V) OR RLPPDMY	// High resistance poly resistor dummy layer for DRC
HREP	= PORES AND HRDMY		// High precision and resistacne poly resistor

HVN_GOX    = NPOD AND OD2	// Device n-type diffusion for thick gate NMOS
HVP_GOX    = PPOD AND OD2	// Device p-type diffusion for thick gate PMOS
HV_NGATE_W = GATE_W INSIDE EDGE HVN_GOX	// 3.3V NMOS gate edges
HV_PGATE_W = GATE_W INSIDE EDGE HVP_GOX	// 3.3V PMOS gate edges


BUTT_NTAP  = NTAP TOUCH PACT		// NWEL Tap butting p-type active diffusion
NONB_NTAP  = NTAP NOT TOUCH PACT	// Non-butting ntap
BUTT_PTAP  = PTAP TOUCH NACT		// PWEL Tap butting n-type active diffusion
NONB_PTAP  = PTAP NOT TOUCH NACT	// Non-butting ptap 
PP_BEDGE   = BUTT_PTAP COIN EDGE NACT	// PP edge to form butted tap
NP_BEDGE   = BUTT_NTAP COIN EDGE PACT	// NP edge to form butted tap
OD2_BEDGE  = OD2 INSIDE EDGE OD

ACT_OD	= OD INTERACT POLY
PNSD	= ACT_OD NOT ALL_GATE
SDPO2	= PNSD INTERACT POLY == 2	// S/D between two Poly gate

CO_DIFF	= CO OUTSIDE POLY_ISO		// Diffusion contacts + floating contacts
CO_POLY	= CO NOT OUTSIDE POLY_ISO	// POLY contacts
ASD1	= PNSD ENCLOSE CO_DIFF
// For checks such as PP.C.4/C.5, NP.C.4/C.5.

EXGATE_NP  = SIZE ((SIZE GATE_NP BY 0.03) AND POLY) BY NP_C_5
EXGATE_PP  = SIZE ((SIZE GATE_PP BY 0.03) AND POLY) BY PP_C_5
FUSE_LMARK = (CB OR FW) OR LW
RNGX       = PMDMY NOT FUSE_LMARK







#IFDEF FULL_CHIP
CHIP_CORE	 = SIZE CHIPx BY -(10 + SR_S_1)		// sealring + assembly isolation
#ELSE
CHIP_CORE    = COPY CHIPx
#ENDIF

PADH      = HOLES (CB OR CBD)

SCORE     = CHIP_CORE INSIDE PADH
SR_CHIP   = CHIP INTERACT SCORE
SR = SR_CHIP NOT (SIZE SR_CHIP BY -10)
SEALRING_ALL = SR OR SEALRING
SR_CB = CB AND SR
SR_CO     = CO AND SR


SR_VIA1     = VIA1 AND SR
SR_VIA2     = VIA2 AND SR
SR_VIA3     = VIA3 AND SR
SR_VIA4     = VIA4 AND SR
SR_VIA5     = VIA5 AND SR
SR_M1 		= M1 AND SR
SR_M2 		= M2 AND SR
SR_M3 		= M3 AND SR
SR_M4 		= M4 AND SR
SR_M5 		= M5 AND SR
SR_M6 		= M6 AND SR

// For SEAL-RING and CHIP CORNER checks.
CHIP_WISR    = CHIPx INTERACT SCORE
SR_EDGE      = CHIP_WISR NOT SCORE 
CHIP_NOSR    = CHIPx NOT INTERACT SR_EDGE
CHIP_NOSR1   = COPY CHIP_NOSR
CHIP_NOSR2   = COPY CHIP_NOSR
CHIP_NOSR3   = COPY CHIP_NOSR
SR_EDGE1     = COPY SR_EDGE 
SR_EDGE2     = COPY SR_EDGE 
SR_EDGE3     = COPY SR_EDGE 
#IFDEF FULL_CHIP
#IFDEF BigSealringCorner
// without seal-ring
EMPTY_AREA     = INT CHIP_NOSR1 < 350 ABUT == 90 REGION INTERSECTING ONLY
// with seal-ring
SR_EXC  = EXT SR_EDGE1 < 350 ABUT == 90 REGION INTERSECTING ONLY
#ELSE
#IFDEF SmallSealringCorner
// without seal-ring
EMPTY_AREA     = INT CHIP_NOSR2 < 125 ABUT == 90 REGION INTERSECTING ONLY
// with seal-ring
SR_EXC  = EXT SR_EDGE2 < 125 ABUT == 90 REGION INTERSECTING ONLY 
#ELSE  // not specify seal-ring structure, use BigSealringCorner
// without seal-ring
EMPTY_AREA     = INT CHIP_NOSR3 < 350 ABUT == 90 REGION INTERSECTING ONLY
// with seal-ring
SR_EXC  = EXT SR_EDGE3 < 350 ABUT == 90 REGION INTERSECTING ONLY 
#ENDIF
#ENDIF
SRCSR   = SR_EDGE OR SR_EXC   // Sealring + Corner + Assembly isolation
CHIP_CHAMFERED = (CHIPx NOT EMPTY_AREA) NOT SRCSR
CHIP_EDGE = CHIPx NOT SR_EDGE
ASS_REGION = (SIZE CHIP_EDGE BY SR_S_1) NOT CHIP_EDGE
#ENDIF  //FULL_CHIP
SR_VIAD     = VIAD AND SR

SBDOD    = ( OD AND SBDDMY ) AND NWEL

NW_SBD   = NWEL INTERACT SBDOD
DNW_SBD   = DNW INTERACT SBDOD

PP_SBD   = PP INTERACT SBDOD 
PP_SBD_HOLE = HOLES PP_SBD INNER
PP_SBD_ALL = PP_SBD OR PP_SBD_HOLE

PP_NSBD = PP NOT PP_SBD

PPOD_SBD = SBDOD INTERACT PP
NPOD_SBD = SBDOD AND NP

PPOD_SBD_GAP = EXPAND EDGE PPOD_SBD OUTSIDE BY 0.48
PPOD_SBD_G   = PPOD_SBD_GAP TOUCH NPOD_SBD
NPOD_SBD_GAP = EXPAND EDGE NPOD_SBD OUTSIDE BY 0.48
NPOD_SBD_G   = NPOD_SBD_GAP TOUCH PPOD_SBD

SBDOD_ALL = ( PPOD_SBD OR NPOD_SBD ) OR PPOD_SBD_G 

PPOD_SBD_W = PPOD_SBD TOUCH OUTSIDE EDGE NPOD_SBD_G
PPOD_SBD_L = PPOD_SBD NOT TOUCH OUTSIDE EDGE NPOD_SBD_G
NPOD_SBD_W = NPOD_SBD TOUCH OUTSIDE EDGE PPOD_SBD_G



CHIPx        = MERGE CHIP


// BUILD CONNECTION FOR RULE CHECKS 
//---------------------------------
CONNECT	NTAPi NWELi
CONNECT PTAPi RWi	// For DNW connection
CONNECT PTAPi PWELi	// For DNW connection
CONNECT	NTAPi PSDi
CONNECT	PTAPi NSDi
CONNECT	M1xd ILP1i NTAPi PTAPi PSDi NSDi BY COi
CONNECT	M1xd M2xd BY VIA1i

CONNECT	M2xd M3xd BY VIA2i

CONNECT	M3xd M4xd BY VIA3i

CONNECT	M4xd M5xd BY VIA4i



CONNECT M6xd CTM5i CMM5i M5xd BY VIA5i
CONNECT	M6xd  MDxd BY VIADi







HRI.WARN { @ RLPPDMY overlap OD is not allowed
  RLPPDMY AND OD   
}



//************************************************************************************* 
//
//  warning messages to check whether some switchs are used corretly or not. 
//
//*************************************************************************************
//======================================================================================
// Process selection warning.
//======================================================================================
#IFNDEF MIX_MODE
WARN.PROCESS_1 { @ MIX_MODE switch should be turned on for Mixed Singal/RF process
	MM_LAYERS = (((( CTM5i OR INDDMY ) OR  HRIi ) OR DNWi ) OR VTMPi ) OR VTMNi

    CHIPx INTERACT MM_LAYERS 
}
#ENDIF

#IFDEF MIX_MODE
#IFNDEF 1.8V
WARN.PROCESS_2 { @ Pls turn on (#DEFINE 1.8V) switch if you use Mixed Singal/RF process
     COPY CHIPx 
}
#ENDIF
#IFNDEF 3.3V
WARN.PROCESS_3 { @ Pls turn on (#DEFINE 3.3V) switch if you use Mixed Singal/RF process
     COPY CHIPx 
}
#ENDIF
#IFDEF LP
WARN.PROCESS_4 { @ Pls turn off (#DEFINE LP) switch if you use Mixed Singal/RF process. 
                 @ Low power is not supported in Mixed Signal process 
     COPY CHIPx 
}
#ENDIF
#IFDEF 1.5V
WARN.PROCESS_5 { @ Pls turn off (#DEFINE 1.5V) switch if you use Mixed Singal/RF process
                 @ Low voltage is not supported in Mixed Signal process
     COPY CHIPx 
}
#ENDIF
#IFDEF 5V
WARN.PROCESS_6 { @ Pls turn off (#DEFINE 5V) switch if you use Mixed Singal/RF process
                 @ 1.8V/5V is not supported in Mixed Signal process
     COPY CHIPx 
}
#ENDIF

#ENDIF
#IFDEF C016
#IFDEF 5V
WARN.PROCESS_7 { @ Pls turn off (#DEFINE 5V) switch if you use 0.16um process
                 @ 1.8V/5V is not supported in 0.16um process
     COPY CHIPx 
}
#ENDIF
#IFDEF 1.5V
WARN.PROCESS_8 { @ Pls turn off (#DEFINE 1.5V) switch if you use 0.16um process
                 @  Low voltage is not supported in 0.16um process
     COPY CHIPx 
}
#ENDIF
#IFDEF LP
WARN.PROCESS_9 { @ Pls turn off (#DEFINE LP) switch if you use 0.16um process
                 @  Low power is not supported in 0.16um process
     COPY CHIPx 
}
#ENDIF
#ENDIF

#IFDEF C016
#IFDEF C0152
WARN.PROCESS_10 { @ (#DEFINE C016 & #DEFINE C0152) switch can't be turned on together
     COPY CHIPx 
}
#ENDIF
#ENDIF
#IFDEF C0152
#IFDEF 5V
WARN.PROCESS_11 { @ Pls turn off (#DEFINE 5V) switch if you use 0.152um process
                 @ 1.8V/5V is not supported in 0.152um process
     COPY CHIPx 
}
#ENDIF
#IFDEF 1.5V
WARN.PROCESS_12 { @ Pls turn off (#DEFINE 1.5V) switch if you use 0.152um process
                 @  Low voltage is not supported in 0.152um process
     COPY CHIPx 
}
#ENDIF
#IFDEF LP
WARN.PROCESS_13 { @ Pls turn off (#DEFINE LP) switch if you use 0.152um process
                 @  Low power is not supported in 0.152um process
     COPY CHIPx 
}
#ENDIF
#ENDIF

#IFDEF LP
#IFDEF 1.5V
WARN.PROCESS_14 { @ Pls turn off (#DEFINE 1.5V) switch if you use 0.18um Low power process
     COPY CHIPx 
}
#ENDIF
#ENDIF

//======================================================================================
// Voltage selection warning.
//======================================================================================

#IFNDEF 3.3V
#IFNDEF 2.5V
#IFNDEF 5V
WARN.VOLTAGE_1 { @ There must be specified an option of HIGH_VOLTAGE
  COPY CHIPx
}
#ENDIF
#ENDIF
#ENDIF

#IFNDEF 1.8V
#IFNDEF 1.5V
WARN.VOLTAGE_2 { @ There must be specified an option of CORE_VOLTAGE
  COPY CHIPx
}
#ENDIF
#ENDIF

#IFDEF 3.3V
#IFDEF 2.5V
WARN.VOLTAGE_3 { @ Only one HIGH_VOLTAGE can be specified every time. 
  COPY CHIPx
}
#ENDIF
#IFDEF 5V
WARN.VOLTAGE_4 { @ Only one HIGH_VOLTAGE can be specified every time.
  COPY CHIPx
}
#ENDIF
#ENDIF


#IFDEF 1.8V
#IFDEF 1.5V
WARN.VOLTAGE_5 { @ Only one CORE_VOLTAGE can be specified every time.
  COPY CHIPx
}
#ENDIF
#ENDIF

#IFDEF 1.8V
#IFDEF 2.5V
WARN.VOLTAGE_6 { @ 1.8V and 2.5V can not be specified at the same time.
  COPY CHIPx
}
#ENDIF
#ENDIF

#IFDEF 1.5V
#IFDEF 5V
WARN.VOLTAGE_7 { @ 1.5V and 5V can not be specified at the same time.
  COPY CHIPx
}
#ENDIF
#ENDIF

//======================================================================================
// Thick top metal selection warning
//======================================================================================
#IFNDEF MIX_MODE
#IFDEF THICK_40K
WARN.THICK_TOP_METAL_1 { @ 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, 
                         @ Other processes are not provided in this design rule.
  COPY CHIPx 
}
#ENDIF
#IFDEF THICK_20K
WARN.THICK_TOP_METAL_2 { @ 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, 
                         @ Other processes are not provided in this design rule.
  COPY CHIPx 
}
#ENDIF
#ENDIF

#IFDEF C016
#IFDEF THICK_40K
WARN.THICK_TOP_METAL_3 { @ 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, 
                         @ Other processes are not provided in this design rule.
  COPY CHIPx 
}
#ENDIF
#ENDIF

#IFDEF C0152
#IFDEF THICK_40K
WARN.THICK_TOP_METAL_4 { @ 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, 
                         @ Other processes are not provided in this design rule.
  COPY CHIPx 
}
#ENDIF
#IFDEF THICK_20K
WARN.THICK_TOP_METAL_5 { @ 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, 
                         @ Other processes are not provided in this design rule.
  COPY CHIPx 
}
#ENDIF
#ENDIF

#IFDEF THICK_40K
#IFDEF THICK_20K
WARN.THICK_TOP_METAL_6 { @ 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, 
                         @ and 20KA and 40KA should not be placed in the same chip.
  COPY CHIPx 
}
#ENDIF
#ENDIF
#IFDEF C016
#IFDEF CHECK_ALRDL
WARN.THICK_TOP_METAL_7 { @ AL RDL is not support in 0.16um process
  COPY CHIPx
}
#ENDIF
#ENDIF


//======================================================================================
// DNW warning
//======================================================================================
#IFNDEF MIX_MODE
WARN.DNW { @ DNW only provide for MM/RF process
  COPY DNWi 
}
#ENDIF
//======================================================================================
// NTN warning
//======================================================================================
#IFDEF 5V
WARN.NTN_1 { @ NTN devices don't provide for 0.18um 1.8V/5V General purpose,Low Power and 
             @ 1.8V/3.3V Low Power process 
  COPY NTNi 
}
#ENDIF

#IFDEF LP
#IFDEF 3.3V
WARN.NTN_2 { @ NTN devices don't provide for 0.18um 1.8V/5V General purpose,Low Power and 
               @ 1.8V/3.3V Low Power process 
  COPY NTNi 
}
#ENDIF
#ENDIF













// NWEL CHECKS
//=============
HOT_NWEL = (NWEL AND HOTWL) OR RNWEL
NW_5V = NWEL NOT OUTSIDE OD2
NW_1_8V = NWEL OUTSIDE OD2

NW.W.1 { @ Min. NWEL width < 0.86
  INT NWEL < 0.86 ABUT < 90 SINGULAR REGION
}
NW.W.2 { @ Min. HOT_NWEL width < 2.10
  INT HOT_NWEL < 2.10 ABUT < 90 SINGULAR REGION
}
NW.S.1 { @ Min. different potential NWEL space < 1.40
  NWEL_NODAL = STAMP NWEL BY NWELi
  EXT NWEL_NODAL < 1.40 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT RNWEL NWEL < 1.40 ABUT < 90 SINGULAR REGION
  EXT RNWEL < 1.40 ABUT < 90 SINGULAR REGION
}

NW.S.2 { @ Min. same potential NWEL space < 0.6
  EXT NWEL < 0.60 ABUT < 90 SINGULAR REGION
}

#IFDEF 5V
NW.S.3 { @ Min. space between 1.8V & 5V NW < ^NW_S_3
	NW_1_8V_NODAL = STAMP NW_1_8V BY NWELi
	NW_5V_NODAL = STAMP NW_5V BY NWELi
	EXT NW_5V_NODAL NW_1_8V_NODAL < NW_S_3 ABUT < 90 SINGULAR REGION NOT CONNECTED 
}
NW.S.4 { @ Min. space between 5V NW with different potential, except two NW region fully covered with OD2 < ^NW_S_4
	NW2V = NW_5V NOT OD2
	NW3V = NW_5V AND OD2
	NW2V_NODAL = STAMP NW2V BY NWELi
	NW3V_NODAL = STAMP NW3V BY NWELi
	EXT NW2V_NODAL < NW_S_4 ABUT < 90 SINGULAR REGION NOT CONNECTED
	EXT NW2V_NODAL NW3V_NODAL < NW_S_4 ABUT < 90 > 0 SINGULAR REGION NOT CONNECTED
}
#ENDIF
//NW.S.5 is checked by other rule.


#IFDEF Recommend
NW.R.1 { @ Recommended not to use floating well

  X1 = ((NWELi OUTSIDE (NPODi INTERACT COi)) NOT LOGO) NOT INSIDE EXCL
  X2 = (((ODi NOT RPOi) INTERACT NPODi) AND NWELi) INTERACT COi
  X1 OUTSIDE X2
  Y1 = (PWELi OUTSIDE (PPODi INTERACT COi)) NOT INSIDE EXCL
  Y2 = (((ODi NOT RPOi) INTERACT PPODi) NOT NWELi) INTERACT COi

  Y1 OUTSIDE Y2
}
#ENDIF



// NWEL (within OD) RESISTOR CHECKS
//====================================

NWRES = RNWEL INTERACT RPO      // NWEL resistor (UNDER OD)
ODWR  = OD INTERACT NWRES       // OD area of NW resistor
NPWR  = NP INTERACT NWRES       // N+ implant on NW resistor terminals
COWR  = CO_DIFF INTERACT NWRES  // Contact on NW resistor terminals
RHWR  = ODWR NOT RPO            // Non-Salicided area of NW resistor
RPONWR_H =  HOLES RPO INNER

NWR.E.1 {@ Min. OD enclose NWEL resistor < 1.0
  ENC NWRES ODWR < 1.0 ABUT < 90 SINGULAR REGION
  NWRES CUT ODWR    
}
NWR.E.2 {@ Min. NWEL resistor enclose CO < 0.3
  ENC COWR NWRES < 0.3 ABUT < 90 SINGULAR REGION
  COWR CUT NWRES    
}
NWR.C.1 {@ Min. RPO hole enclose NWEL < 0.3
  ENC NWRES RHWR < 0.3 ABUT < 90 SINGULAR REGION
}
NWR.C.2 {@ Min. RPO enclose OD (with NWEL resistor) < 0.22
  ENC ODWR RPO < 0.22 ABUT < 90 SINGULAR REGION
}
NWR.C.3 {@ Min. RPO hole enclose NWEL resistor CO < 0.3
  ENC COWR RHWR < 0.3 ABUT < 90 SINGULAR REGION
  COWR CUT RHWR    
}
NWR.O.1 {@ Min. RPO overlap NP < 0.4
  INT NPWR RPO < 0.4 ABUT < 90 SINGULAR REGION
  X = RPO INTERACT NWRES
  H = HOLES X INNER
  H NOT NPWR
}
NWR.R.1 {@ NW resistor doped by implants not allowed.
  RWDMY AND NPOD
  RWDMY AND PPOD
}



NWT = NTAPu INTERACT NWRES
NWT_CB_DUMMY = CBu INTERACT VDD_VSS_DUMMY
NWT_UBMn_DUMMY = UBMnu INTERACT VDD_VSS_DUMMY
NWT_UBMd_DUMMY = UBMdu INTERACT VDD_VSS_DUMMY
PWR_M1u_BY_TEXT = M1u WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1u_BY_TEXT = M1u WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1u_BY_TEXT = M1u WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY

PWR_M1k_BY_TEXT = M1k WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1k_BY_TEXT = M1k WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1k_BY_TEXT = M1k WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
IO_PAD_M1k_BY_TEXT = (PAD_M1k_BY_TEXT NOT PWR_M1k_BY_TEXT) NOT GND_M1k_BY_TEXT

PWR_M2u_BY_TEXT = M2u WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2u_BY_TEXT = M2u WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2u_BY_TEXT = M2u WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY

PWR_M2k_BY_TEXT = M2k WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2k_BY_TEXT = M2k WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2k_BY_TEXT = M2k WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
IO_PAD_M2k_BY_TEXT = (PAD_M2k_BY_TEXT NOT PWR_M2k_BY_TEXT) NOT GND_M2k_BY_TEXT

PWR_M3u_BY_TEXT = M3u WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3u_BY_TEXT = M3u WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3u_BY_TEXT = M3u WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY

PWR_M3k_BY_TEXT = M3k WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3k_BY_TEXT = M3k WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3k_BY_TEXT = M3k WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
IO_PAD_M3k_BY_TEXT = (PAD_M3k_BY_TEXT NOT PWR_M3k_BY_TEXT) NOT GND_M3k_BY_TEXT

PWR_M4u_BY_TEXT = M4u WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4u_BY_TEXT = M4u WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4u_BY_TEXT = M4u WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY

PWR_M4k_BY_TEXT = M4k WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4k_BY_TEXT = M4k WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4k_BY_TEXT = M4k WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
IO_PAD_M4k_BY_TEXT = (PAD_M4k_BY_TEXT NOT PWR_M4k_BY_TEXT) NOT GND_M4k_BY_TEXT

PWR_M5u_BY_TEXT = M5u WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5u_BY_TEXT = M5u WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5u_BY_TEXT = M5u WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY

PWR_M5k_BY_TEXT = M5k WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5k_BY_TEXT = M5k WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5k_BY_TEXT = M5k WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
IO_PAD_M5k_BY_TEXT = (PAD_M5k_BY_TEXT NOT PWR_M5k_BY_TEXT) NOT GND_M5k_BY_TEXT

PWR_M6u_BY_TEXT = M6u WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6u_BY_TEXT = M6u WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6u_BY_TEXT = M6u WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY

PWR_M6k_BY_TEXT = M6k WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6k_BY_TEXT = M6k WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6k_BY_TEXT = M6k WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
IO_PAD_M6k_BY_TEXT = (PAD_M6k_BY_TEXT NOT PWR_M6k_BY_TEXT) NOT GND_M6k_BY_TEXT

PWR_MDu_BY_TEXT = MDu WITH TEXT VDD_TEXT MD_PIN_TEXT PRIMARY ONLY
GND_MDu_BY_TEXT = MDu WITH TEXT VSS_TEXT MD_PIN_TEXT PRIMARY ONLY
PAD_MDu_BY_TEXT = MDu WITH TEXT PAD_TEXT MD_PIN_TEXT PRIMARY ONLY
PWR_MDk_BY_TEXT = MDk WITH TEXT VDD_TEXT MD_PIN_TEXT PRIMARY ONLY
GND_MDk_BY_TEXT = MDk WITH TEXT VSS_TEXT MD_PIN_TEXT PRIMARY ONLY
PAD_MDk_BY_TEXT = MDk WITH TEXT PAD_TEXT MD_PIN_TEXT PRIMARY ONLY


NWT_IOPAD = NET AREA RATIO NWT CBu UBMnu UBMdu > 0 [!!AREA(CBu) + !!AREA(UBMnu) + !!AREA(UBMdu)]
NWT_VDD_VSS_PAD_DUMMY = NET AREA RATIO NWT OVER NWT_CB_DUMMY NWT_UBMn_DUMMY NWT_UBMd_DUMMY > 0
 NWT_PAD_TEXT = NET AREA RATIO NWT OVER  PAD_M1u_BY_TEXT PAD_M2u_BY_TEXT PAD_M3u_BY_TEXT PAD_M4u_BY_TEXT PAD_M5u_BY_TEXT PAD_M6u_BY_TEXT > 0
 NWT_VDD_VSS_PAD_TEXT = NET AREA RATIO NWT OVER  PWR_M1u_BY_TEXT PWR_M2u_BY_TEXT PWR_M3u_BY_TEXT PWR_M4u_BY_TEXT PWR_M5u_BY_TEXT PWR_M6u_BY_TEXT GND_M1u_BY_TEXT  GND_M2u_BY_TEXT  GND_M3u_BY_TEXT  GND_M4u_BY_TEXT  GND_M5u_BY_TEXT  GND_M6u_BY_TEXT > 0

#IFDEF CHECK_LATCHUP_BY_TEXT

NWT_IO = NWT_IOPAD NOT ( NWT_VDD_VSS_PAD_TEXT OR NWT_VDD_VSS_PAD_DUMMY )
NWT_IO_TEXT = NWT_PAD_TEXT NOT ( NWT_VDD_VSS_PAD_TEXT OR NWT_VDD_VSS_PAD_DUMMY )
#ELSE
NWT_IO = NWT_IOPAD NOT NWT_VDD_VSS_PAD_DUMMY
#ENDIF

#IFDEF Recommend
NWR.R.7 { @ Its recommended not to connect any terminal of NWROD(N-well under OD resistor) to IO voltage for the leakage current concern.
	NTAP_OD2 = NTAPu AND OD2
	PTAP_OD2 = PTAPu AND OD2
	NSD_OD2 = NSDu AND OD2
	PSD_OD2 = PSDu AND OD2 
	ILP1_OD2 = ILP1u AND OD2
#IFDEF CHECK_LATCHUP_BY_TEXT
	NET AREA RATIO NWT NTAP_OD2 PTAP_OD2 NSD_OD2 PSD_OD2 ILP1_OD2 NWT_IO NWT_IO_TEXT > 0
		[!!AREA(NTAP_OD2) + !!AREA(PTAP_OD2) + !!AREA(NSD_OD2) + !!AREA(PSD_OD2) + !!AREA(ILP1_OD2) + !!AREA(NWT_IO) + !!AREA(NWT_IO_TEXT)]
#ELSE 
	NET AREA RATIO NWT NTAP_OD2 PTAP_OD2 NSD_OD2 PSD_OD2 ILP1_OD2 NWT_IO > 0
		[!!AREA(NTAP_OD2) + !!AREA(PTAP_OD2) + !!AREA(NSD_OD2) + !!AREA(PSD_OD2) + !!AREA(ILP1_OD2) + !!AREA(NWT_IO)]
#ENDIF
}
#ENDIF

NWR.R.3{@ Only one NW inside NWROD is allowed in one OD.
   A = ODWR INTERACT (NWRES AND ODWR)>1
   NWRES INTERACT A
}  

NWR.R.4{@ Only two NPS in NWROD is allowed in one od.
 C = ODWR INTERACT (NP INTERACT NWRES) != 2
 NP INTERACT C
 ODWR NOT INTERACT ( NP INTERACT NWRES)
}

NWR.R.5 { @ ONLY TWO RPO HOLES IN NWROD ARE ALLOWED.
   A = ODWR INTERACT RPONWR_H != 2
   D = ODWR NOT INTERACT RPONWR_H
   RPONWR_H INTERACT (A OR D)
}  

NWR.R.6 { @ For U-shape or S-shape NWROD, both OD and NW must be U-shape or S-shape and the OD edge must be 
    	  @ parallel to the NW edge. DRC can only flag the pattern without OD space while 2 edges of NW 
	  @ [NW space or notch <= 5 um] parallel length > 0 um
  A = (EXT NWRES < 5 OPPOSITE REGION NOTCH) NOT NWRES
  A INSIDE ODWR      
} 



//NWEL under STI
NWRES_STI = RNWEL NOT INTERACT RPO	// NWEL resistor (UNDER STI)
ODWR_STI  = OD INTERACT NWRES_STI
NPWR_STI  = NP INTERACT NWRES_STI
NWR.E.3 { @ Min. extension of NP to OD (NWEL resistor under STI) 0.18 um
  ENC ODWR_STI NPWR_STI < 0.18 ABUT < 90 SINGULAR REGION
  ODWR_STI NOT NPWR_STI
}



#IFDEF C0152
// ULLNW CHECKS
//============
// ULLNW.W.1 is checked by NW.W.1
// ULLNW.W.2 is checked by NW.W.2
// ULLNW.S.1 is checked by NW.S.1
// ULLNW.S.2 is checked by NW.S.2
// ULLNW.S.3 is checked by NW.S.1
// ULLNW.S.4 is checked by NW.S.2
#ENDIF


#IFNDEF 5V
// NT_N
//======

NTN_OD = OD NOT OUTSIDE NTN
NTN_PO = POLY AND NTN
NTN_GATE = NTN_PO AND NTN_OD
NTN_GATE_W = NTN_PO INSIDE EDGE NTN_OD
NTN_GATE_L = NTN_OD INSIDE EDGE NTN_PO
NTN_PO_W   = (NTN_PO INTERACT (CO OR OD)) COIN INSIDE EDGE POLY

NT_N.I.1 {@ NT_N interact DNW is not allowed. (Butted is allowed)
  NTN AND DNW
}

NT_N.I.2 {@ only one OD region allowed to be put in an NT_N region
  NTN ENCLOSE OD > 1
}
NT_N.I.3 {@ A P+GATE is not allowed to be put in an NT_N region
  NTN AND GATE_PP
}
NT_N.I.4 {@ A bent poly region is not allowed to put in an NT_N region
  EXT NTN_PO_W < 0.18 ABUT == 90 INTERSECTING ONLY
  INT NTN_PO_W < 0.18 ABUT == 90 INTERSECTING ONLY
  EXT NTN_PO_W < 0.18 ABUT == 135 INTERSECTING ONLY
  INT NTN_PO_W < 0.18 ABUT == 135 INTERSECTING ONLY
}
NT_N.W.1 {@ For CL018LV 1.5V/2.5V, CL018G 1.8V/3.3V minimum dimension of a NT_N region < ^NT_N_W_1
  INT NTN < NT_N_W_1 ABUT < 90 SINGULAR REGION
}

#IFDEF 1.5V
#IFDEF 3.3V
NT_N.W.1_1.5_3.3V {@ For CL018LV 1.5V/3.3V, minimum dimension of a NT_N region.<0.86
  INT NTN < 0.86 ABUT < 90 SINGULAR REGION
}
#ENDIF
#ENDIF

#IFDEF 1.8V
#IFDEF C016
NTN.W.2 {@ Minimum poly gate dimension(channel length) of a 1.8V blocked NT_N device < 0.55
  INT NTN_GATE_W < 0.55 ABUT < 90 REGION
}

#ENDIF
#IFNDEF C016
NT_N.W.2_LV {@ Minimum Poly gate dimension of a 1.8V blocked NT_N device < 0.5
  INT NTN_GATE_W < 0.5 ABUT < 90 REGION
}
#ENDIF
#ENDIF

#IFDEF 1.5V
NT_N.W.2.LV {@ For CL018LV 1.5/2.5V & 1.5/3.3V, minimum Poly gate dimension of a 1.5V blocked NT_N device < 0.37
  INT NTN_GATE_W < 0.37 ABUT < 90 REGION
}
NT_N.W.2_HV   {@ CL018LV 1.5V/3.3V, CL018LV 1.5V/2.5V, CL018G 1.8V/3.3, minimum Poly gate dimension of a {2.5V or 3.3V} blocked NT_N device < 1.2
  Z = NTN_GATE_W INSIDE EDGE OD2
  INT Z < 1.2 ABUT < 90 REGION
}
#ENDIF


#IFNDEF C016
#IFDEF 3.3V
NT_N.W.2_3.3V {@ For CL018LV 1.5V/3.3V, CL018LV 1.5V/2.5V, CL018G 1.8V/3.3V, minimum Poly gate dimension of a {2.5V or 3.3V} blocked NT_N device < 1.2
  Z = NTN_GATE_W INSIDE EDGE OD2
  INT Z < 1.2 ABUT < 90 REGION
}
#ENDIF
#ENDIF

#IFDEF C016
NTN.W.2B {@ Minimum poly gate dimension (channel length) of a 3.3V blocked NT_N device < 1.32
  Z = NTN_GATE_W INSIDE EDGE OD2
  INT Z < 1.32 ABUT < 90 REGION
}
NTN.W.3 {@ Minimum OD width of 1.8V/3.3V blocked NT_N device < 0.245
  A = NTN_OD INTERACT NTN_PO 
  INT A < 0.245 ABUT < 90 REGION
}
#ENDIF


NT_N.S.1 {@ Minimum space between two NT_N regions < ^NT_N_S_1
  EXT NTN < NT_N_S_1 ABUT < 90 SINGULAR REGION
}
#IFDEF C0152
NT_N.S.2 { @ Space of NT_N to ULLNW (Overlap is not allowed) >= ^NT_N_S_2
	EXT NTN ULLNW < NT_N_S_2 ABUT < 90 SINGULAR REGION
	NTN AND ULLNW
}
#ENDIF
NT_N.E.1 {@ Maximum and Minimum extension from NT_N region beyond an NP OD region ^NT_N_E_1
  A = NTN INTERACT NPOD
  B = NPOD INTERACT NTN
  C = SIZE B BY NT_N_E_1
  D = SIZE A BY -NT_N_E_1
  A XOR C
  B XOR D
}

#IFDEF 1.5V
NT_N.E.2.LV {@ For CL018LV 1.5V/2.5V & 1.5V/3.3V, minimum extension from OD2 edge to {2.5V or 3.3V} 
             @ NT_N region inside OD2 < 0.86um
  ENC NTN OD2 < 0.86 ABUT < 90 SINGULAR REGION
  NTN CUT OD2
}
#ENDIF
NT_N.C.1 {@ MInimum clearance from NT_N to OD < ^NT_N_C_1
  EXT OD NTN < NT_N_C_1 ABUT < 90 SINGULAR REGION
  OD CUT NTN    
}

NT_N.C.2 {@ Minimum clearance frome a NT_N region to NWEL edge < 1.66
  EXT NTN NWEL < 1.66 ABUT < 90 SINGULAR REGION
  NTN AND NWEL
}
#IFDEF 1.5V
NT_N.C.3.LV { @ For CL018LV 1.5/2.5V & 1.5/3.3V, minimum clearance from 1.5V
              @ NT_N region to OD2 edge < 0.86um
  EXT NTN OD2 < 0.86 ABUT < 90 SINGULAR REGION
}
#ENDIF
NT_N.PO.1 {@ Minimum overlap of a PO region extended into field oxide(endcap) < 0.35
  ENC NTN_OD POLY < 0.35 ABUT < 90 SINGULAR REGION
}
#ENDIF  //#IFNDEF or IFDEF 5V


// OD CHECKS
//==============
OD.W.1_OD.W.2 { @ Min. OD width for MOS and interconnect < 0.22
  INT OD < 0.22 ABUT < 90 SINGULAR REGION
}
OD.S.1 { @ Min. OD space < 0.28
  EXT OD < 0.28 ABUT < 90 SINGULAR REGION 
}

OD.C.1 { @ Min. NWEL olap NPOD tie down < 0.12
  ENC NPOD NONWR < 0.12 ABUT < 90 SINGULAR REGION

  NPOD CUT NONWR

}
OD.C.2_OD.C.3 { @ Min. NWEL to NPOD space < 0.43
  A = NPOD NOT INSIDE NWEL
  X = A NOT ODWR
  EXT X NWEL < 0.43 ABUT < 90 SINGULAR REGION
  X CUT NWEL
}
OD.C.4 { @ NWEL overlap PPOD < 0.43
  ENC PPOD NWEL < 0.43 ABUT < 90 SINGULAR REGION
  PPOD CUT NWEL    
}
OD.C.5 { @ NWEL space PPOD outside NW < 0.12
  EXT PTAP NWEL < 0.12 ABUT < 90 SINGULAR REGION
}
// OD.C.6 is checked by PP.C.5 and NP.C.5


#IFDEF Recommend
OD.C.7 { @ Min. clearance between parallel NW strap and PW strap < ^OD_C_7 um
	EXT NTAP PTAP < OD_C_7 PARALLEL ONLY OPPOSITE REGION
}
#ENDIF
// OD.S.2 is not necessary to check
OD.W.3 { @ Length of active with width < ^OD_W_3_J um, connected to butted strap > ^OD_W_3_T um
  SD = (DACT INTERACT ALL_GATE) NOT ALL_GATE
  NP_PP_BTE = NPOD COIN OUTSIDE EDGE PPOD  
  BUTTED_EDGE = LENGTH NP_PP_BTE < OD_W_3_J
  CHECK_SD = SD WITH EDGE BUTTED_EDGE
  NARROW_SD = INT (CHECK_SD COIN INSIDE EDGE OD) < OD_W_3_J ABUT < 90 OPPOSITE REGION 
  CHECK_OD = (NARROW_SD WITH EDGE BUTTED_EDGE) OR (NARROW_SD WITH EDGE GATE_W)
  PATH LENGTH (OD COIN INSIDE EDGE CHECK_OD) > OD_W_3_T
}
OD.A.1 { @ Min. area of stand-alone OD region < 0.202
  OD AREA < 0.202
}



#IFDEF C0152
OD.S.3 {@ Space of (NW INTERACT (P+OD AND ULLNW)) to (P-channel PO gate INSIDE ULLNW) >= ^OD_S_3
   A= LVNW INTERACT (PPOD AND ULLNW)
   B= GATE_PP INSIDE ULLNW
   EXT A B < OD_S_3 ABUT < 90 SINGULAR REGION
}
OD.S.4 {@ Space of (ULLNW INTERACT (P+OD AND NW)) to (P-channel PO gate INSIDE NW) >= ^OD_S_4
   A= ULLNW INTERACT (PPOD AND LVNW)
   B= GATE_PP INSIDE LVNW
   EXT A B < OD_S_4 ABUT < 90 SINGULAR REGION
}
OD2.R.1 { @ OD2 region overlap ULLNW is not allowed
  OD2 AND ULLNW    
}
#ENDIF
#IFDEF Recommend
OD.EX.1 { @ Min. extension of NW beyond NPOD which is parallel NW strap and PW strap >= ^OD_EX_1
   A = EXT NTAP PTAP < 0.72 OPPOSITE PARALLEL REGION
   B = NTAP COINCIDENT EDGE A
   ENC B NWEL < OD_EX_1	ABUT < 90 OPPOSITE REGION
}

#ENDIF
OD.R.5 { @ (NW OR ULLNW) cut {(OD INTERACT(OD NOT (NP OR PP))) NOT INTERACT CO} is not allowed (except NW fully inside OD or OD fully inside NW)
     PRE =(OD INTERACT(OD NOT (NP OR PP))) NOT INTERACT CO
	 A = NWEL INSIDE PRE 
	 B = PRE INSIDE NWEL
	 (NWEL NOT A ) CUT  (PRE NOT B) 	
}




#IFDEF C0152
// ODLL CHECKS
//===========
ODLL_GATE_NP = GATE_NP INTERACT ODLL
ODLL_GATE    = ALL_GATE INTERACT ODLL
LV_ALL_GATE = ALL_GATE NOT ODLL_GATE

ODLL_EXGATE_NP = SIZE ((SIZE ODLL_GATE_NP BY 0.03) AND POLY) BY 0.32
LV_ALL_EXGATE = SIZE ((SIZE LV_ALL_GATE BY 0.03) AND POLY) BY 0.32

ODLL.W.1 { @ Min. width of ODLL < 0.44um
    INT ODLL < 0.44 ABUT < 90 SINGULAR REGION 
}

ODLL.S.1 { @ Min. space two ODLL region < 0.44um
    EXT ODLL < 0.44 ABUT < 90 SINGULAR REGION 
}

ODLL.S.2 { @ Space of ODLL to an non-butted Pwell strap(P+ OD inside PW) < 0.1um, and butted is allowed
    EXT ODLL PTAP < 0.1 ABUT > 0 < 90 SINGULAR REGION 
    A = EXT ODLL [PTAP] < 0.001 ABUT == 0
    B = EXPAND EDGE A OUTSIDE BY 0.001
    B NOT INTERACT NACT	
}

ODLL.S.3 { @ Space of ODLL to butted diffusion P+OD region(inside PW) < 0
    ODLL AND PTAP
}

ODLL.S.4_ODLL.E.2 { @ Min. clearance from ODLL to N-channel PO gate inside ODLL < 0.32um
   ODLL_EXGATE_NP NOT ODLL	
}

ODLL.S.5_ODLL.S.7 { @ Space of ODLL to PO gate outside ODLL < 0.32um
    LV_ALL_EXGATE AND ODLL	
}

ODLL.O.1 { @ Min. overlap from ODLL to OD < 0.23um
    INT ODLL OD < 0.23 ABUT > 0 < 90 SINGULAR REGION 
}

ODLL.E.1 { @ Min. extension of ODLL beyond NPOD ( if the distance to the releated poly > 0.32um ) < 0.18um
    ENC NACT ODLL < 0.18 ABUT > 0 < 90 SINGULAR REGION 
    A = ENC [NACT] ODLL < 0.001 ABUT == 0
    B = EXPAND EDGE A OUTSIDE BY 0.001
    B NOT INTERACT PTAP	
}

// ODLL.E.2 is checked by ODLL.S.4_ODLL.E.2

ODLL.E.3 { @ Minimum extension of a ODLL region beyond a P+OD region inside ULLNW >= 0.00um
   A = PACT AND ULLNW
   B = A AND ODLL
   C = A INTERACT B
   C NOT ODLL
}

ODLL.S.6 { @ Space of ODLL to N+OD outside ODLL and in PW (if the distance to the releated poly > 0.32um ) < 0.21um
    A = NACT NOT ODLL
    EXT A ODLL < 0.21 ABUT < 90 SINGULAR REGION 
}
//ODLL.S.7 is checked by ODLL.S.5_ODLL.S.7

ODLL.A.1 { @ Min. area of ODLL region < 0.3844
    AREA ODLL < 0.3844
}

ODLL.R.1 { @ Overlap of ODLL to LVNW is forbidden unless ODLL inside ULLNW.
    ( ODLL AND NWELi ) NOT ULLNWi
}

#ENDIF
#IFDEF 5V

// 5V OD CHECKS
//==============
OD.C.2.1_OD.C.3.1 { @ Minimum clearance from NWEL edge to N+OD which interacts OD2 < ^OD_C_2_1
  X = (NPOD NOT INSIDE NWEL) NOT ODWR
  Y = X INTERACT OD2
  EXT Y NWEL < OD_C_2_1 ABUT < 90 SINGULAR REGION
}
OD.C.4.1 { @ Minimum clearance from NWEL edge to P+OD which interacts OD2 < ^OD_C_4_1
  X = PPOD INTERACT OD2
  ENC X NWEL < OD_C_4_1 ABUT < 90 SINGULAR REGION
}

#ENDIF



// OD2 CHECKS
//===============
DACTG = DACT OR ALL_GATE



OD2.W.1 { @ Minimum width of an OD2 region >= ^OD2_W_1 um
  INT OD2 < OD2_W_1 ABUT < 90 SINGULAR REGION
}

OD2.E.1 { @ Minimum extension of an OD2 region beyond an {active OD OR Gate} region>=0.32um
  CHECK_EDGE = ENC [DACTG] OD2 < 0.32 ABUT < 90 SINGULAR 
  CHECK_EDGE NOT COIN OUTSIDE EDGE DSTP 
  OD2 INSIDE DACTG		// OD2 totally inside OD
}
#IFNDEF 5V
#IFDEF 1.8V
OD2.S.1 { @ For two well process (1.8V/3.3V C018G), minimum space between two OD2
          @ regions. Merge if the space is less than 0.45um.>=0.45um
  EXT OD2 < 0.45 ABUT < 90 SINGULAR REGION
}
#ENDIF
#ENDIF
#IFDEF 1.5V
OD2.S.1.LV { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
        	@ C018LP, 1.8V/5.0V C018G/LP, minimum space between two OD2 regions.
                @ Merge if the space is less than 0.86um.
  EXT OD2 < 0.86 SINGULAR ABUT <90 REGION
}
#ENDIF
#IFDEF 5V
OD2.S.1.5V { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
        	@ C018LP, 1.8V/5.0V C018G/LP, minimum space between two OD2 regions.
                @ Merge if the space is less than 0.86um.
  EXT OD2 < 0.86 SINGULAR ABUT <90 REGION
}
#ENDIF
#IFDEF LP
OD2.S.1.LP { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
        	@ C018LP, 1.8V/5.0V C018G/LP, minimum space between two OD2 regions.
                @ Merge if the space is less than 0.86um.
  EXT OD2 < 0.86 SINGULAR ABUT <90 REGION
}
#ENDIF

OD2.C.1 { @ Minimum clearance between OD region and an OD2 region>=0.32um
  EXT OD2 NACT < 0.32 SINGULAR ABUT <90 REGION
  EXT OD2 PACT < 0.32 SINGULAR ABUT <90 REGION
}
OD2.C.2 { @ Minimum clearance between OD2 region and {1.5V or 1.8V} transistor gate
          @ poly>= 0.4um
  A = OD2 INSIDE EDGE DACT
  EXT A GATE_W < 0.40 ABUT <90 REGION
}
OD2.E.2 { @ Minimum extension of OD2 region beyond {2.5V or 3.3V or 5V} transistor
          @ gate poly in the source/drain OD direction OD2 cut poly GATE is not
          @ allowed. >=0.4um
  ENC GATE_W OD2_BEDGE < 0.40 ABUT < 90 REGION 
  ALL_GATE CUT OD2    
}
#IFDEF 1.5V
OD2.E.4.LV { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP, minimum extension of an OD2 region
             @ beyond an NW region>=0.86um. Align if space is less than 0.86um
  ENC NWEL OD2 < 0.86 ABUT>0<90 SINGULAR REGION
}
OD2.C.4.LV { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region
             @ and an NW region. Align if space is less than 0.86um
  EXT NWEL OD2 < 0.86 ABUT>0<90 SINGULAR REGION
  ENC OD2 NWEL < 0.86 ABUT>0<90 SINGULAR REGION
}
OD2.O.1.LV { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP>=0.86um minimum overlap between OD2 and NWEL >= 0.86um
  INT NWEL OD2 < 0.86 ABUT>0<90 SINGULAR MEASURE COINCIDENT REGION
}
#ENDIF
#IFDEF 5V
OD2.E.4.5V { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP, minimum extension of an OD2 region
             @ beyond an NW region>=0.86um. Align if space is less than 0.86um
  ENC NWEL OD2 < 0.86 ABUT>0<90 SINGULAR REGION
}
OD2.C.4.5V { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region
             @ and an NW region. Align if space is less than 0.86um
  EXT NWEL OD2 < 0.86 ABUT>0<90 SINGULAR REGION
  ENC OD2 NWEL < 0.86 ABUT>0<90 SINGULAR REGION
}
OD2.O.1.5V { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP>=0.86um minimum overlap between OD2 and NWEL >= 0.86um
  INT NWEL OD2 < 0.86 ABUT>0<90 SINGULAR MEASURE COINCIDENT REGION
}
#ENDIF
#IFDEF LP
OD2.E.4.LP { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP, minimum extension of an OD2 region
             @ beyond an NW region>=0.86um. Align if space is less than 0.86um
  ENC NWEL OD2 < 0.86 ABUT>0<90 SINGULAR REGION
}
OD2.C.4.LP { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region
             @ and an NW region. Align if space is less than 0.86um
  EXT NWEL OD2 < 0.86 ABUT>0<90 SINGULAR REGION
  ENC OD2 NWEL < 0.86 ABUT>0<90 SINGULAR REGION
}
OD2.O.1.LP { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP>=0.86um minimum overlap between OD2 and NWEL >= 0.86um
  INT NWEL OD2 < 0.86 ABUT>0<90 SINGULAR MEASURE COINCIDENT REGION
}
#ENDIF







// POLY checks
//=============
//PO.W.1A is checked by PO.W.3
//PO.W.2A is checked by PO.W.3
PO.W.3 { @ Min. POLY width for interconnect, 1.8V NMOS, 1.8V PMOS < 0.18
  INT POLY < 0.18 ABUT < 90 SINGULAR REGION
}

#IFDEF 3.3V
PO.W.1_3.3V { @ Min. POLY gate length 3.3V pmos < 0.30
  INT HV_PGATE_W < 0.30 ABUT < 90 REGION
}
PO.W.2_3.3V { @ Min. POLY gate length 3.3v nmos < 0.35
  INT HV_NGATE_W < 0.35 ABUT < 90 REGION
}
#ENDIF
#IFDEF 2.5V
PO.W.1_2.5V { @ Min. POLY gate length 2.5V pmos < 0.26
  INT HV_PGATE_W < 0.26 ABUT < 90 REGION
}
PO.W.2_2.5V { @ Min. POLY gate length 2.5v nmos < 0.26
  INT HV_NGATE_W < 0.26 ABUT < 90 REGION
}
#ENDIF
#IFDEF 5V
PO.W.1_5V { @ Min. POLY gate length 5.0V pmos < 0.5
  INT HV_PGATE_W < 0.5 ABUT < 90 REGION
}
PO.W.2_5V { @ Min. POLY gate length 5.0v nmos < 0.6
  INT HV_NGATE_W < 0.6 ABUT < 90 REGION
}
#ENDIF

PO.S.1 { @ Min. POLY space on OD with contact < 0.375
  Y = ALL_GATE COINCIDENT OUTSIDE EDGE ASD1
  EXT Y < 0.375 ABUT < 90 REGION
}
PO.S.2_PO.S.3 { @ Min. POLY space: on OD w/o contact and interconnect < 0.25
  EXT POLY < 0.25 ABUT < 90  SINGULAR REGION
}
PO.C.1 { @ Min. POLY on field space to active < 0.1
  EXT POLY OD < 0.1 ABUT < 89.5 SINGULAR REGION
}
PO.C.2 { @ Min. OD overhang gate < ^PO_C_2
  ENC POLY OD < PO_C_2 ABUT < 89.5 SINGULAR REGION
}

GATE_5V = ALL_GATE AND OD2
PO_5V = POLY INTERACT GATE_5V
OD_5V = (NW_5V AND OD) OR ((OD INTERACT GATE_5V) NOT NWEL)
#IFDEF 5V
PO.C.3 { @ Min. clearance for an (OD not OD2) region to an 5V PO on field oxide >= ^PO_C_3 
	A = OD NOT OD2
	B = PO_5V NOT OD
	EXT A B < PO_C_3 ABUT < 90 SINGULAR REGION 
}
PO.C.4 { @ Min. clearance from an (5V OD not OD2) region to an PO on field oxide >= ^PO_C_4
	A = OD_5V NOT OD2
	EXT A POLY_ISO < PO_C_4 ABUT > 0 < 90 SINGULAR REGION 
	B = EXT [A] POLY_ISO < 0.001 ABUT == 0
    C = EXPAND EDGE B INSIDE BY 0.001
    C NOT INTERACT ALL_GATE
}
#ENDIF

PO.O.1 { @ Min. POLY overhang active < 0.22
   ENC OD POLY < 0.22 ABUT < 89.5 SINGULAR REGION
}

#IFNDEF MIX_MODE
PO.R.1A { @ 90 degree gate not allowed/L and U shape gate are not allowed
      // 0.18 value is arbitrary, note the angle
  EXT GATE_W < 0.18 ABUT == 90 INTERSECTING ONLY
  INT GATE_W < 0.18 ABUT == 90 INTERSECTING ONLY
}
#ENDIF


PO.R.1B { @ 45 degree 1.8V gate min. length < 0.21
  INT LVGT < 0.21 ANGLED == 2 OPPOSITE REGION

}
PO.R.2 { @ Max. POLY length between contacts when PO width less than 0.24um > ^PO_R_2
  LONG_PO = AREA ILP1 > 0.18*PO_R_2
  CHECK_PO = LONG_PO INTERACT CO
  CHECK_CO = CO INTERACT CHECK_PO
  CO_A = SIZE CHECK_CO BY PO_R_2 / 2 INSIDE OF CHECK_PO STEP 0.25 
  PO_A = CHECK_PO INTERACT CO_A == 1
  PO_B = CHECK_PO INTERACT CO_A > 1
  CO_B = CO_A INTERACT PO_A
  CO_C = SIZE CO_B BY PO_R_2 / 2 INSIDE OF PO_A STEP 0.25 
  BAD = (PO_A NOT CO_C) OR (PO_B NOT CO_A)
  BAD_EDGE = BAD COIN INSIDE EDGE POLY
  ERROR = INT BAD_EDGE <= 0.24 ABUT < 90 REGION
  CHECK_PO INTERACT ERROR
}
GATEu = STAMP ALL_GATE BY ILP1u
PSDu_g = PSDu INTERACT POLYi
NSDu_g = NSDu INTERACT POLYi

//get all floating gates
Float_GATE = NET AREA RATIO GATEu PTAPu NTAPu PSDu_g NSDu_g CBu UBMnu UBMdu COu > 0 
	[!AREA(PTAPu)*!AREA(NTAPu)*!AREA(PSDu_g)*!AREA(NSDu_g)*!AREA(CBu)*!AREA(UBMnu)*!AREA(UBMdu)+!AREA(COu)]
//get all floating source/drain
Float_NSD = NET AREA RATIO NSDu_g PSDu_g GATEu PTAPu NTAPu CBu UBMnu UBMdu > 0
	[~(COUNT(NSDu_g)-1)*!AREA(PSDu_g)*!AREA(GATEu)*!AREA(PTAPu)*!AREA(NTAPu)*!AREA(CBu)*!AREA(UBMnu)*!AREA(UBMdu)]
Float_PSD = NET AREA RATIO PSDu_g NSDu_g GATEu PTAPu NTAPu CBu UBMnu UBMdu > 0
	[~(COUNT(PSDu_g)-1)*!AREA(NSDu_g)*!AREA(GATEu)*!AREA(PTAPu)*!AREA(NTAPu)*!AREA(CBu)*!AREA(UBMnu)*!AREA(UBMdu)]

//not floating source/drain
effective_NSD = NSDu_g NOT Float_NSD
effective_PSD = PSDu_g NOT Float_PSD

Float_NSD_a = Float_NSD NOT ((Float_NSD OR ALL_GATE) INTERACT effective_NSD >= 2 BY NET)
Float_PSD_a = Float_PSD NOT ((Float_PSD OR ALL_GATE) INTERACT effective_PSD >= 2 BY NET)

Float_GATE_check = Float_GATE NOT INTERACT (Float_NSD_a OR Float_PSD_a)

#IFDEF FULL_CHIP
PO.R.4 { @ It is prohibited for Floating Gate if the effective source/drain is not connected together 
  Float_GATE_check INTERACT NSDu > 1 BY NET
  Float_GATE_check INTERACT PSDu > 1 BY NET
}
#ENDIF






// Poly/OD Resistor CHECK
//==========
PORESC = (PORES NOT INTERACT RLPPDMY) NOT INTERACT SDI

#IFDEF Recommend
  PORESC_L = EXPAND EDGE (PORESC NOT INSIDE EDGE POLY) BY 0.001 CORNER FILL
  PORESC_W = EXPAND EDGE (PORESC INSIDE EDGE POLY) BY 0.001
  CONNECT PORESC_L PORESC_W
RES.2 {@ For poly resistor, it is strongly recommended that the poly resistor width >= ^RES_2_W um,
		@ length >= 5.0um, and the resistor square number Nsq >= ^RES_2_Nsq,
		@ DRC will check the width and Nsq 1um and 5 for poly resistor & 2um and 5 for OD resistor
  INT PORESC < RES_2_W ABUT < 90 SINGULAR REGION
  NET AREA RATIO PORESC_L PORESC_W < RES_2_Nsq 
}




DMPN2V = DMP2V OR DMN2V

RES.3_PO { @ The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is
        @ resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance,
	@ dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation, 
	@ please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V.
	@ Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.   
   (( PORES INTERACT PP ) NOT INTERACT HRIi) NOT DMP2V
   ( PORES INTERACT NP ) NOT DMN2V  
   ( DMP2V AND DMN2V ) AND PORES
   PORES_PO = POLY INTERACT PORES
   ENC PORES_PO DMP2V < 0.22 ABUT < 90 SINGULAR REGION
   ENC PORES_PO DMN2V < 0.22 ABUT < 90 SINGULAR REGION
   X = EXPAND EDGE ( DMPN2V INTERACT PORES) INSIDE BY 0.005 EXTEND BY - 0.005
   Y = EXPAND EDGE ( DMPN2V TOUCH EDGE ( X NOT INTERACT PORES_PO )) INSIDE BY 0.22
   Y NOT TOUCH PORES
}
RES.3_OD { @ The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is
        @ resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance,
        @ dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation,
        @ please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V.
        @ Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.
   (( ODRES INTERACT PP ) NOT DMP2V ) NOT SEALRING_ALL
   ( ODRES INTERACT NP ) NOT DMN2V
   ( DMP2V AND DMN2V ) AND ODRES

   ODRES_OD = OD INTERACT ODRES
   ENC ODRES_OD DMP2V < 0.22 ABUT < 90 SINGULAR REGION
   ENC ODRES_OD DMN2V < 0.22 ABUT < 90 SINGULAR REGION
   X = EXPAND EDGE ( DMPN2V INTERACT ODRES) INSIDE BY 0.005 EXTEND BY - 0.005
   Y = EXPAND EDGE ( DMPN2V TOUCH EDGE ( X NOT INTERACT ODRES_OD )) INSIDE BY 0.22
   Y NOT TOUCH ODRES
}
RES.4_PO { @ Min. and Max. clearance from RPO to a contact on the poly resistor and OD resistor = 0.22um
  PO_RES = POLY INTERACT PORES
  CO_RES = CO INTERACT PO_RES
  RPO_E  = RPO INSIDE EDGE PO_RES
  RPO_EX = EXPAND EDGE RPO_E OUTSIDE BY 0.22
  RPO_EX AND CO_RES
  RPO_EX NOT INTERACT CO_RES
  CO_RES NOT INTERACT RPO_EX
}
RES.4_OD { @ Min. and Max. clearance from RPO to a contact on the poly resistor and OD resistor ==0.22um
  OD_RES = OD INTERACT ODRES
  CO_RES = CO INTERACT OD_RES
  RPO_E  = RPO INSIDE EDGE OD_RES
  RPO_EX = EXPAND EDGE RPO_E OUTSIDE BY 0.22
  (RPO_EX AND CO_RES) NOT SEALRING_ALL
  (RPO_EX NOT INTERACT CO_RES) NOT SEALRING_ALL 
  (CO_RES NOT INTERACT RPO_EX) NOT SEALRING_ALL
}
RES.5_PO { @ Min. clearance from poly resistor and OD resistor to un-related NP, PP regions >= 0.26um
  EXT PORES IMP < 0.26 ABUT < 90 SINGULAR REGION MEASURE ALL
}
RES.5_OD { @ Min. clearance from poly resistor and OD resistor to un-related NP, PP regions >= 0.26um
  EXT ODRES IMP < 0.26 ABUT < 90 SINGULAR REGION MEASURE ALL
}
RES.6_PO { @ Minimum clearance from an un-related RPO to the POLY and OD  resistor>= 0.3um
  EXT PORES RPO < 0.3 ABUT < 90 SINGULAR REGION MEASURE ALL
}
RES.6_OD { @ Minimum clearance from an un-related RPO to the POLY and OD resistor>= 0.3um
  EXT ODRES RPO < 0.3 ABUT < 90 SINGULAR REGION MEASURE ALL
}

// RES.7 is checked by RES.4
RES.8 { @ To use rectangle shape resistor for SPICE simulation accuracy.
	NOT RECTANGLE PORESC
	(NOT RECTANGLE ODRES) NOT SEALRING
}

#ENDIF
RES.9 {@ DMN2V overlap DMP2V not allowed
  DMP2V AND DMN2V
}
RES.10 {@ Minimum clearence from DMN2V to GATE(overlap is not allowed) >=0.35um
    EXT DMN2V ALL_GATE <0.35 ABUT < 90 SINGULAR REGION 
    DMN2V AND ALL_GATE
}
RES.11 {@ Minimum clearence from DMP2V to GATE(overlap is not allowed) >=0.35um
    EXT DMP2V ALL_GATE <0.35 ABUT < 90 SINGULAR REGION 
    DMP2V AND ALL_GATE
}






#IFDEF Recommend
  ODRESC = (ODRES NOT INTERACT RLPPDMY) NOT SEALRING
  ODRESC_L = EXPAND EDGE (ODRESC NOT INSIDE EDGE OD) BY 0.001 CORNER FILL
  ODRESC_W = EXPAND EDGE (ODRESC INSIDE EDGE OD) BY 0.001
  CONNECT ODRESC_L ODRESC_W
RES.12 {@ For OD resistor, it is strongly recommended that the resistor width>= ^RES_12_W um and the resistor square number Nsq >= ^RES_12_Nsq.
        @ DRC will check the width and Nsq 1um and 5 for poly resistor & 2um and 5 for OD resistor
  INT ODRESC < RES_12_W ABUT < 90 SINGULAR REGION
  NET AREA RATIO ODRESC_L ODRESC_W < RES_12_Nsq
}
#IFDEF 5V 
RES.14 {@ Minimum clearance from poly resistor to od edge >= ^RES_14
	EXT PORESC OD < RES_14 ABUT < 90 SINGULAR REGION	
}
#ENDIF

#ENDIF

RES.13 {@ Minimum clearance from poly resistor to OD edge >= ^RES_13
	EXT PORESC OD < RES_13 ABUT < 90 SINGULAR REGION
}


RES.15 {@ Poly resistor cuts NW is not allowed.
	PORESC CUT NWEL
}
















#IFDEF MIX_MODE





  HREPC = HREP INTERACT RLPPDMY
#IFDEF Recommend
  HREP_L = EXPAND EDGE (HREPC NOT INSIDE EDGE POLY) BY 0.001 CORNER FILL
  HREP_W = EXPAND EDGE (HREPC INSIDE EDGE POLY) BY 0.001
  CONNECT HREP_L HREP_W
RES.HRI.1 { @ It is strongly recommended that the HRI poly resistor width e 1.0 um and resistor number of square Nsq e 2.
 INT HREPC < 1.0 ABUT < 90 SINGULAR REGION
 NET AREA RATIO HREP_L HREP_W < 2.0 
}

//RES.HRI.2 is checked by RES.4_PO
//RES.HRI.3 is checked by RES.5_PO
//RES.HRI.4 is checked by RES.6_PO 
//RES.HRI.5 is checked by RES.4_PO
//RES.HRI.6 un-checkable by DRC

RES.HRI.7 { @ Min. clearance from RLPPDMY to the HRI poly resistor >= 0.26um
  PO_HREP = POLY INTERACT HREP
  ENC PO_HREP RLPPDMY < 0.26 ABUT < 90 SINGULAR REGION
}
RES.HRI.8 { @ To use rectangle shape HRI resistor for the SPICE simulation accuracy.
	NOT RECTANGLE HREPC
}
RES.HRI.9 { @ Min. clearance from HRI resistor to OD edge >= ^RES_HRI_9
	EXT HREPC OD < RES_HRI_9 ABUT < 90 SINGULAR REGION 
}


#ENDIF
RES.HRI.10 { @ HRI resistor cuts NW is not allowed.
	HREPC CUT NWEL
}
RES.HRI.11 { @ RLPPDMY and PP must be butted (overlap is not allow)
	(RLPPDMY AND PP) AND POLY
	A = PP INSIDE EDGE (POLY INTERACT HREPC)
	B = PP AND (POLY INTERACT HREPC)
	HREPC NOT TOUCH B == 2
	A NOT COIN OUTSIDE EDGE RLPPDMY
}



#IFDEF Recommend
CO_HRI = CO INTERACT (POLY INTERACT HREPC)
RES.HRI.12 { @ Min and max space between two CO region on HRI poly res == ^RES_HRI_12
    EXT CO_HRI < RES_HRI_12 ABUT < 90  SINGULAR REGION
    A = (POLY INTERACT HREPC) NOT RPO
    B = SIZE CO_HRI BY RES_HRI_12/2 OVERUNDER
    A INTERACT B != 1
}
#ENDIF





#ENDIF


















// PP CHECKS
//============
PPE4_NWELC = SIZE NWELi BY 0.43
PPE4_NWELS = SIZE PPE4_NWELC BY 0.18
PPE4_OD = PTAP AND PPE4_NWELS
PPE4_C1 = ENC PPE4_OD PP < 0.18 ABUT > 0 < 90 OPPOSITE REGION
PPE4_C2 = ENC PPE4_OD PP < 0.18 ABUT > 0 < 90 CORNER REGION
PPE4_C3 = ENC PPE4_OD PP < 0.18 ABUT > 0 < 90 PROJ==0 REGION
PPE4_C4 = (SIZE PPE4_C2 BY 0.005) NOT PPE4_OD
PPE4_ALL = (PPE4_C1 OR PPE4_C3) OR PPE4_C4
PPE4_CHECKOD = PPE4_ALL COIN OUTSIDE EDGE PPE4_OD


NPC3_C1 = EXT PPE4_OD NP < 0.18 ABUT > 0 < 90 OPPOSITE REGION
NPC3_C2 = EXT PPE4_OD NP < 0.18 ABUT > 0 < 90 CORNER REGION
NPC3_C3 = EXT PPE4_OD NP < 0.18 ABUT > 0 < 90 PROJ==0 REGION
NPC3_C4 = (SIZE NPC3_C2 BY 0.005) NOT PPE4_OD
NPC3_ALL = (NPC3_C1 OR NPC3_C3) OR NPC3_C4
NPC3_CHECKOD = NPC3_ALL COIN OUTSIDE EDGE PPE4_OD


NPE4_NWELC = SIZE NWELi BY -0.43
NPE4_NWELS = SIZE NPE4_NWELC BY -0.18
NPE4_OD = NTAP NOT NPE4_NWELS
NPE4_C1 = ENC NPE4_OD NP < 0.18 ABUT > 0 < 90 OPPOSITE REGION
NPE4_C2 = ENC NPE4_OD NP < 0.18 ABUT > 0 < 90 CORNER REGION
NPE4_C3 = ENC NPE4_OD NP < 0.18 ABUT > 0 < 90 PROJ==0 REGION
NPE4_C4 = (SIZE NPE4_C2 BY 0.005) NOT NPE4_OD
NPE4_ALL = (NPE4_C1 OR NPE4_C3) OR NPE4_C4
NPE4_CHECKOD = NPE4_ALL COIN OUTSIDE EDGE NPE4_OD

PPC3_C1 = EXT NPE4_OD PP < 0.18 ABUT > 0 < 90 OPPOSITE REGION
PPC3_C2 = EXT NPE4_OD PP < 0.18 ABUT > 0 < 90 CORNER REGION
PPC3_C3 = EXT NPE4_OD PP < 0.18 ABUT > 0 < 90 PROJ==0 REGION
PPC3_C4 = (SIZE PPC3_C2 BY 0.005) NOT NPE4_OD
PPC3_ALL = (PPC3_C1 OR PPC3_C3) OR PPC3_C4
PPC3_CHECKOD = PPC3_ALL COIN OUTSIDE EDGE NPE4_OD

PP.W.1 { @ PP width < ^PP_W_1
INT PP < PP_W_1 ABUT < 90 SINGULAR REGION

}



PP.S.1 { @ PP space < ^PP_S_1
  EXT PP < PP_S_1 ABUT < 90 SINGULAR REGION
}

PP.C.1 { @ PP space to n active in pwell < ^PP_C_1
  // N active in pwell can be butting or non-butting. 
  // The non-butting N active is not allowed to touch PP.
  EXT PP NACT < PP_C_1 ABUT > 0 < 90 SINGULAR REGION
  X = EXT PP [NACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
}
PP.C.2 { @ PP space to non-butting NTAP < 0.1 with PWEL space >= 0.43
  EXT PP NTAP < 0.1 ABUT > 0 < 90 SINGULAR REGION
}
PP.C.3 { @ PP space to non-butting NTAP < 0.18 with PWEL space < 0.43
  PPC3_CHECKOD OUTSIDE EDGE NPE4_NWELC
}
// PP.C.4 is checked by NP.C.5 and PP.R.1_NP.R.1
PP.C.5 { @ PP extension over (P gate) + (field poly within 0.35um) < ^PP_C_5 um
  // This rule must extend out of gate in the direction of PO by 0.35um
  EXGATE_PP NOT PP
}

PP.O.1 { @ Minimum overlap from a PP edge to an OD region must >= 0.230um except SBD region 
    INT OD PP_NSBD < 0.230 ABUT > 0 < 90 SINGULAR REGION
}

PP.E.1 { @ Minimum extension of a PP region beyond a P+ active OD region must >= ^PP_E_1 um 
		 @ except SBD and SEALRING region
    (ENC PACT PP_NSBD < PP_E_1 ABUT > 0 < 90 SINGULAR REGION) NOT INTERACT SEALRING_ALL
    Y = ENC [PACT] PP_NSBD < 0.001 ABUT == 0
    Z = EXPAND EDGE Y OUTSIDE BY 0.001
	(Z NOT INTERACT NPOD) NOT INTERACT SEALRING_ALL
}

PP.E.1_NP.E.1 { @ Implant can not coincident OD edge except butted diffusion
	(IMP NOT INTERACT SEALRING_ALL) COIN INSIDE EDGE OD
}
PP.E.3 { @ Minimum enclosure of PTAP by PP < 0.02 with NWEL space >= 0.43 except SEALRING region
  (ENC PTAP PP < 0.02 ABUT > 0 < 90 SINGULAR REGION) NOT INTERACT SEALRING_ALL
  X = ENC [PTAP] PP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD ) NOT INTERACT SEALRING_ALL
}
PP.E.4 { @ Min. enc. of PTAP by PP < 0.18 with NWEL space < 0.43
  PPE4_CHECKOD INSIDE EDGE PPE4_NWELC
}
// PP.C.6 is not necessary to check
// PP.E.5 is not necessary to check
PP.A.1 { @ Minimum area of PP < 0.3844
  PP AREA < 0.3844
}
#IFNDEF MIX_MODE
PP.E.6 { @ Min enc of POLY resistor by PP < ^PP_E_6
  ENC PORES PP < PP_E_6 ABUT < 90 SINGULAR REGION
  ((RPO AND POLY) NOT IMP) NOT HRI
}
#ENDIF


PP.R.1_NP.R.1 { @ PP and NP not allowed to overlap
  PP AND NP
}
//PP.R.1 is checked by PP.R.1_NP.R.1
//NP.R.1 is checked by PP.R.1_NP.R.1

// PP.R.2 is not necessary to check
PP.R.3_NP.R.3 { @ OD must be fully covered by PP and NP, except OD without interacting CO OR PO
   (((OD INTERACT POLYi )NOT ODWR)NOT SBDDMY) NOT IMP
   (((OD INTERACT COi )NOT ODWR)NOT SBDDMY) NOT IMP
}




// NP CHECKS
//============
NP.W.1 { @ NP width < ^NP_W_1
  INT NP < NP_W_1 ABUT < 90 SINGULAR REGION
}


NP.S.1 { @ NP space < ^NP_S_1
  EXT NP < NP_S_1 ABUT < 90 SINGULAR REGION
}
NP.C.1 { @ NP space to p active in NWEL < ^NP_C_1
  // P active in NWEL can be butting or non-butting.
  // The non-butting P active is not allowed to touch NP.
  EXT NP PACT < NP_C_1 ABUT > 0 < 90 SINGULAR REGION
  X = EXT NP [PACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
}

NP.C.2 { @ NP space to non-butting ptap < 0.1 with NWEL space >= 0.43
  EXT NP PTAP < 0.1 ABUT > 0 < 90 SINGULAR REGION
}
NP.C.3 { @ NP space to non-butting ptap < 0.18 with NWEL space < 0.43
  NPC3_CHECKOD INSIDE EDGE PPE4_NWELC
}
// NP.C.4 is checked by PP.C.5 and PP.R.1_NP.R.1
NP.C.5 { @ NP extension over (N gate) + (field poly within 0.35um) < ^NP_C_5 um
  // This rule must extend out of gate in the direction of PO by 0.35um
	EXGATE_NP NOT NP
}

NP.O.1 { @ NP extends into n active < 0.230
  INT OD NP < 0.230 ABUT > 0 < 90 SINGULAR REGION 
}

NP.E.1 { @ NP olap OD < ^NP_E_1 except SEALRING region
  X = NACT NOT ODWR
  ( ENC X NP < NP_E_1 ABUT > 0 < 90 SINGULAR REGION ) NOT INTERACT SEALRING_ALL
  Y = ENC [X] NP < 0.001 ABUT == 0
  Z  = EXPAND EDGE Y OUTSIDE BY 0.001
  (Z NOT INTERACT PPOD) NOT INTERACT SEALRING_ALL
}
NP.E.3 { @ Minimum enclosure of NTAP by NP < 0.02 with PWEL space >= 0.43
  ENC NTAP NP < 0.02 ABUT > 0 < 90 SINGULAR REGION
  X = ENC [NTAP] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
}
NP.E.4 { @ Min. enc. of NTAP by NP < 0.18 with PWEL space < 0.43
  NPE4_CHECKOD OUTSIDE EDGE NPE4_NWELC
}
// NP.C.6 is not checked by drc
// NP.E.5 is not checked by drc

NP.A.1 { @ Minimum area of NP < 0.3844
  NP AREA < 0.3844
}

NP.E.6 { @ Min enc of POLY resistor by NP < 0.18
  ENC PORES NP < 0.18 ABUT < 90 SINGULAR REGION
}
// NP.R.2 is not necessary to check







// RPO checks
//===========

CB_HOLE = HOLES CB 
CB_SR = CB TOUCH CB_HOLE ==1
RPO_NOT_SR = RPO NOT INTERACT CB_SR

RPO.W.1 { @ Minimum RPO width < 0.43
  INT RPO < 0.43 ABUT < 90 SINGULAR REGION
}
RPO.S.1 { @ Minimum RPO space < ^RPO_S_1
  EXT RPO < RPO_S_1 ABUT < 90 SINGULAR REGION
}

RPO.C.1 { @ Minimum RPO space to OD < 0.22 except SEALRING region
  (EXT RPO OD < 0.22 ABUT < 90 SINGULAR REGION) NOT INTERACT SEALRING_ALL
}
RPO.C.2 { @ Minimum RPO space to CO < ^RPO_C_2
  EXT RPO CO < RPO_C_2 ABUT < 90 SINGULAR REGION
  CO AND RPO     
}
RPO.C.3 { @ Minimum RPO space to gate < 0.45 
    	  @exclude ESD part
  A = ((((ALL_GATE NOT DRCDMY) NOT ESD1DMY) NOT ESD2DMY) NOT ESD3DMY ) NOT SDI
  EXT RPO A < 0.45 ABUT < 90 SINGULAR REGION 
  RPO AND A
}
RPO.C.4 { @ Minimum RPO overhang OD < 0.22
  ( ENC OD RPO < 0.22 ABUT < 90 SINGULAR REGION ) NOT INTERACT SEALRING_ALL
  RPO_NOT_SR INSIDE OD   
}
RPO.E.1 { @ Minimum OD overhang RPO < 0.22
  ( ENC RPO OD < 0.22 ABUT < 90 SINGULAR REGION ) NOT INTERACT SEALRING_ALL
}
RPO.C.5 { @ Minimum RPO overhang POLY < 0.22
  ENC POLY RPO < 0.22 ABUT < 90 SINGULAR REGION
  RPO_NOT_SR INSIDE POLY
}
RPO.C.6 { @ Minimum clearance RPO to unrelated poly < 0.3um
  EXT RPO POLY_ISO < 0.30 ABUT < 90 SINGULAR REGION
}
RPO.A.1 { @ RPO min. area < 2 um*um
  AREA RPO < 2
}






VARIABLE RPO_A_2pre ((RPO_A_2 + (RPO_S_1 * RPO_S_1 * 3.142))/(2 * RPO_S_1))*((RPO_A_2 + (RPO_S_1 * RPO_S_1 * 3.142))/(2 * RPO_S_1))/3.141
RPO.A.2 { @ Enclosed Area >= ^RPO_A_2 um2
  A = HOLES RPO INNER < RPO_A_2pre 
  B = A NOT RPO
  AREA B < RPO_A_2
}  


// CO checks
//===============
CO.W.1 { @ contact width != 0.22
  X = CO NOT SR_CO
  NOT RECTANGLE X == 0.22 BY == 0.22 ORTHOGONAL ONLY
}
CO.S.1 { @ contact spacing < 0.25
  EXT CO < 0.25 ABUT < 90 SINGULAR REGION
}


CO.S.2  { @ Min space between two contacts in larger than 4x4 array.
  A = SIZE CO BY 0.30/2 OVERUNDER	// space < 0.3um treat as array
  B = SIZE A BY 0.7 UNDEROVER	// (0.22*3+0.3*2) = 1.26  (3 COs Mix.)
  C = B INTERACT CO >= 16	// 1.63-0.22 = 1.41       (Max. CO shift space) 
  D = CO INTERACT C		// so 1.26 < CONTY width < 1.41
  EXT D < 0.28			// & we use CONTY width = 1.4
}
CO.C.1_CO.R.1 { @ diff contact to gate space < 0.16, or contact on gate
  EXT CO_DIFF ALL_GATE < 0.16 ABUT < 90 SINGULAR REGION
  CO_DIFF AND ALL_GATE    
}
CO.C.2 { @ poly contact space to OD < 0.20
  EXT CO_POLY OD < 0.20 ABUT < 90 SINGULAR REGION
}
CO.E.1 { @ active olap contact < 0.10, also floating contacts
  ENC CO_DIFF OD < 0.10 ABUT < 90 SINGULAR REGION
  CO_DIFF OUTSIDE EDGE OD    
}
CO.E.2 { @ poly olap contact < 0.10
  ENC CO_POLY POLY_ISO < 0.10 ABUT < 90 SINGULAR REGION
  CO_POLY CUT POLY_ISO    
}

CO.E.3 { @ Minimum extension of a PP region beyond a OD CO region must >= ^CO_E_3 um except SBD region
    ENC CO_DIFF PP_NSBD < CO_E_3 ABUT < 90 SINGULAR REGION
    PP_NSBD INSIDE EDGE CO_DIFF 
}

CO.E.4 { @ implant olap contact < ^CO_E_4
  ENC CO_DIFF NP < CO_E_4 ABUT < 90 SINGULAR REGION
  NP INSIDE EDGE CO_DIFF    
}
// CO.R.2 is checked by CO.E.3/CO.E.4
// CO.R.3 is checked by RPO.C.2
CO.R.4 { @ CO and {PO INTERACT(RPDMY(54;0) OR RPDMY(drawing1)(54;1) OR RLPPDMY)} must be fully covered by {NP OR PP}
   A = CO AND (POLY INTERACT(RPDUMMY OR RLPPDMY))
   A NOT (NP OR PP)
}





// M1 checks
//=============
M1.W.1 { @ Min. M1 width < 0.23
  INT M1 < 0.23 ABUT < 90 SINGULAR REGION
}
M1.S.1 { @ Min. M1 space < 0.23
  EXT M1 < 0.23 ABUT < 90 SINGULAR REGION
}

M1.S.2 { @ Min. space to wide M1 (>10um) < ^M1_S_2
  M1_S5 = SHRINK (SHRINK (SHRINK (SHRINK M1 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M1_G5 = GROW (GROW (GROW (GROW M1_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M1_Wide = M1_G5 AND M1
  M1_Exp = SIZE M1_Wide BY 1 INSIDE OF M1 STEP 0.161
  M1_Branch = M1_Exp NOT M1_Wide
  M1_Branch_edge = M1_Branch COIN INSIDE EDGE M1
  M1_Check = M1 AND (SIZE M1_Exp BY M1_S_2)
  M1_Branch_Check = M1 AND (EXPAND EDGE M1_Branch_edge OUTSIDE BY M1_S_2 CORNER FILL)
  M1_WideC = STAMP M1_Wide BY M1xd
  M1_CheckC = STAMP M1_Check BY M1xd
  M1_BranchC = STAMP M1_Branch BY M1xd
  M1_Branch_CheckC = STAMP M1_Branch_Check BY M1xd
  EXT M1_WideC M1_CheckC < M1_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M1_BranchC M1_Branch_CheckC < M1_S_2 ABUT >0 <89.5 NOT CONNECTED REGION
}
M1.S.2.1.a { @ Min. space betweem wide metal and small piece of metal with parallel run length >= ^M1_S_2_L and same connection >=^M1_S_2_1 um
  M1_S5 = SHRINK (SHRINK (SHRINK (SHRINK M1 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M1_G5 = GROW (GROW (GROW (GROW M1_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M1_Wide = M1_G5 AND M1
  M1_Small = M1 NOT M1_Wide
  M1_WideC = STAMP M1_Wide BY M1xd
  M1_SmallC = STAMP M1_Small BY M1xd
  M1_S_REG = EXT M1_WideC M1_SmallC < M1_S_2_1 CONNECTED OPPOSITE REGION MEASURE ALL
  M1_S_REG_CHECK = ENCLOSE RECTANGLE M1_S_REG GRID M1_S_2_L 
  WideEdge1 = M1_S_REG_CHECK COIN OUTSIDE EDGE M1_Wide
  M1_Small_Edge = M1_Small COIN INSIDE EDGE M1
  WideEdge2 = M1_S_REG_CHECK COIN OUTSIDE EDGE M1_Small_Edge
  PATH LENGTH WideEdge1 >= M1_S_2_L
  PATH LENGTH WideEdge2 >= M1_S_2_L
}
M1.S.2.1.b { @ Min. space between two wide metals with parallel run length >= ^M1_S_2_L and same connection >=^M1_S_2_2 um
  M1_S5 = SHRINK (SHRINK (SHRINK (SHRINK M1 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M1_G5 = GROW (GROW (GROW (GROW M1_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M1_Wide = M1_G5 AND M1
  M1_WideC = STAMP M1_Wide BY M1xd
  M1_S_REG = EXT M1_WideC < M1_S_2_2 CONNECTED OPPOSITE REGION
  M1_S_REG_CHECK = ENCLOSE RECTANGLE M1_S_REG GRID M1_S_2_L
  WideEdge = M1_S_REG_CHECK COIN OUTSIDE EDGE M1_Wide
  PATH LENGTH WideEdge >= M1_S_2_L
}


M1.E.1 { @ Min. extension of a M1 region beyond a CO region < 0.005
  ENC CO M1 < 0.005 ABUT < 90 SINGULAR REGION
  CO NOT M1    
}
M1.E.2 { @ Min. extension of M1 end-of-line region beyond CO region < 0.06
  X = ENC [CO] M1 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.22 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}
M1.A.1{ @ Min. M1 area < ^M1_A_1
  AREA M1_A < M1_A_1
}

// Density check M1.R.1 included at the end of this file




// VIA1 checks
//=============
VIA1_CORE = VIA1 NOT SR_VIA1
VIA1.W.1 { @ VIA1 must be 0.26 x 0.26
  A = NOT RECTANGLE VIA1_CORE == 0.26 BY == 0.26 ORTHOGONAL ONLY
  A OUTSIDE RNGX   // exclude from metal fuse protection ring area
}

VIA1.S.1 { @ Min. VIA1 space < 0.26
  EXT VIA1 < 0.26 ABUT < 90 SINGULAR REGION 
}
VIA1.E.1 { @ Min. extension of a M1 region beyond a VIA1 region < 0.01
  ENC VIA1 M1 < 0.01 ABUT < 90 SINGULAR REGION
  VIA1 NOT M1    
}
VIA1.E.2 { @ Min. extension of M1 end-of-line region beyond VIA1 region < 0.06
  X = ENC [VIA1] M1 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26  ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}




// M2 checks
//=============
M2.W.1 { @ Min. M2 width < 0.28
  INT M2 < 0.28 ABUT < 90 SINGULAR REGION
}

M2.S.1 { @ Min. M2 space < 0.28
  EXT M2 < 0.28 ABUT < 90 SINGULAR REGION
}

M2.S.2 { @ Min. space to wide M2 (>10um) < 0.6
  M2_S5 = SHRINK (SHRINK (SHRINK (SHRINK M2 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M2_G5 = GROW (GROW (GROW (GROW M2_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M2_Wide = M2_G5 AND M2
  M2_Exp = SIZE M2_Wide BY 1 INSIDE OF M2 STEP 0.196
  M2_Branch = M2_Exp NOT M2_Wide
  M2_Branch_edge = M2_Branch COIN INSIDE EDGE M2
  M2_Check = M2 AND (SIZE M2_Exp BY 0.6)
  M2_Branch_Check = M2 AND (EXPAND EDGE M2_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
  M2_WideC = STAMP M2_Wide BY M2xd
  M2_CheckC = STAMP M2_Check BY M2xd
  M2_BranchC = STAMP M2_Branch BY M2xd
  M2_Branch_CheckC = STAMP M2_Branch_Check BY M2xd
  EXT M2_WideC M2_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M2_BranchC M2_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
M2.S.2.1.a { @ Min. space betweem wide metal and small piece of metal with parallel run length >= ^M2_S_2_L and same connection >=^M2_S_2_1 um
  M2_S5 = SHRINK (SHRINK (SHRINK (SHRINK M2 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M2_G5 = GROW (GROW (GROW (GROW M2_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M2_Wide = M2_G5 AND M2
  M2_Small = M2 NOT M2_Wide
  M2_WideC = STAMP M2_Wide BY M2xd
  M2_SmallC = STAMP M2_Small BY M2xd
  M2_S_REG = EXT M2_WideC M2_SmallC < M2_S_2_1 CONNECTED OPPOSITE REGION MEASURE ALL
  M2_S_REG_CHECK = ENCLOSE RECTANGLE M2_S_REG GRID M2_S_2_L 
  WideEdge1 = M2_S_REG_CHECK COIN OUTSIDE EDGE M2_Wide
  M2_Small_Edge = M2_Small COIN INSIDE EDGE M2
  WideEdge2 = M2_S_REG_CHECK COIN OUTSIDE EDGE M2_Small_Edge
  PATH LENGTH WideEdge1 >= M2_S_2_L
  PATH LENGTH WideEdge2 >= M2_S_2_L
}
M2.S.2.1.b { @ Min. space between two wide metals with parallel run length >= ^M2_S_2_L and same connection >=^M2_S_2_2 um
  M2_S5 = SHRINK (SHRINK (SHRINK (SHRINK M2 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M2_G5 = GROW (GROW (GROW (GROW M2_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M2_Wide = M2_G5 AND M2
  M2_WideC = STAMP M2_Wide BY M2xd
  M2_S_REG = EXT M2_WideC < M2_S_2_2 CONNECTED OPPOSITE REGION
  M2_S_REG_CHECK = ENCLOSE RECTANGLE M2_S_REG GRID M2_S_2_L
  WideEdge = M2_S_REG_CHECK COIN OUTSIDE EDGE M2_Wide
  PATH LENGTH WideEdge >= M2_S_2_L
}

M2.E.1 { @ Min. extension of a M2 region beyond a VIA1 region < 0.01
  ENC VIA1 M2 < 0.01 ABUT < 90 SINGULAR REGION
  VIA1 NOT M2
}

M2.E.2 { @ Min. extension of M2 end-of-line region beyond VIA1 region < 0.06
  X = ENC [VIA1] M2 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}


M2.A.1{ @ Min M2 area region < ^Mx_A_1
  AREA M2 < Mx_A_1
}


// Density check M2.R.1 included at the end of this file

// VIA2 checks
//=============
VIA2_CORE = VIA2 NOT SR_VIA2
VIA2.W.1 { @ VIA2 must be 0.26 x 0.26
  A = NOT RECTANGLE VIA2_CORE == 0.26 BY == 0.26 ORTHOGONAL ONLY
  A OUTSIDE RNGX   // exclude from metal fuse protection ring area
}

VIA2.S.1 { @ Min. VIA2 space < 0.26
  EXT VIA2 < 0.26 ABUT < 90 SINGULAR REGION 
}
VIA2.E.1 { @ Min. extension of a M2 region beyond a VIA2 region < 0.01
  ENC VIA2 M2 < 0.01 ABUT < 90 SINGULAR REGION
  VIA2 NOT M2    
}
VIA2.E.2 { @ Min. extension of M2 end-of-line region beyond VIA2 region < 0.06
  X = ENC [VIA2] M2 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26  ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}

#IFDEF Recommend
VIA2.E.3 {@ Minimum extension of M2 beyond the overlap area that VIA2 and VIA1 are fully or partially touching < ^VIA2_E_3
	X = VIA2 AND VIA1
	ENC X M2 < VIA2_E_3 ABUT < 90 SINGULAR REGION 
}
#ENDIF



// M3 checks
//=============
M3.W.1 { @ Min. M3 width < 0.28
  INT M3 < 0.28 ABUT < 90 SINGULAR REGION
}

M3.S.1 { @ Min. M3 space < 0.28
  EXT M3 < 0.28 ABUT < 90 SINGULAR REGION
}

M3.S.2 { @ Min. space to wide M3 (>10um) < 0.6
  M3_S5 = SHRINK (SHRINK (SHRINK (SHRINK M3 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M3_G5 = GROW (GROW (GROW (GROW M3_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M3_Wide = M3_G5 AND M3
  M3_Exp = SIZE M3_Wide BY 1 INSIDE OF M3 STEP 0.196
  M3_Branch = M3_Exp NOT M3_Wide
  M3_Branch_edge = M3_Branch COIN INSIDE EDGE M3
  M3_Check = M3 AND (SIZE M3_Exp BY 0.6)
  M3_Branch_Check = M3 AND (EXPAND EDGE M3_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
  M3_WideC = STAMP M3_Wide BY M3xd
  M3_CheckC = STAMP M3_Check BY M3xd
  M3_BranchC = STAMP M3_Branch BY M3xd
  M3_Branch_CheckC = STAMP M3_Branch_Check BY M3xd
  EXT M3_WideC M3_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M3_BranchC M3_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
M3.S.2.1.a { @ Min. space betweem wide metal and small piece of metal with parallel run length >= ^M3_S_2_L and same connection >=^M3_S_2_1 um
  M3_S5 = SHRINK (SHRINK (SHRINK (SHRINK M3 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M3_G5 = GROW (GROW (GROW (GROW M3_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M3_Wide = M3_G5 AND M3
  M3_Small = M3 NOT M3_Wide
  M3_WideC = STAMP M3_Wide BY M3xd
  M3_SmallC = STAMP M3_Small BY M3xd
  M3_S_REG = EXT M3_WideC M3_SmallC < M3_S_2_1 CONNECTED OPPOSITE REGION MEASURE ALL
  M3_S_REG_CHECK = ENCLOSE RECTANGLE M3_S_REG GRID M3_S_2_L 
  WideEdge1 = M3_S_REG_CHECK COIN OUTSIDE EDGE M3_Wide
  M3_Small_Edge = M3_Small COIN INSIDE EDGE M3
  WideEdge2 = M3_S_REG_CHECK COIN OUTSIDE EDGE M3_Small_Edge
  PATH LENGTH WideEdge1 >= M3_S_2_L
  PATH LENGTH WideEdge2 >= M3_S_2_L
}
M3.S.2.1.b { @ Min. space between two wide metals with parallel run length >= ^M3_S_2_L and same connection >=^M3_S_2_2 um
  M3_S5 = SHRINK (SHRINK (SHRINK (SHRINK M3 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M3_G5 = GROW (GROW (GROW (GROW M3_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M3_Wide = M3_G5 AND M3
  M3_WideC = STAMP M3_Wide BY M3xd
  M3_S_REG = EXT M3_WideC < M3_S_2_2 CONNECTED OPPOSITE REGION
  M3_S_REG_CHECK = ENCLOSE RECTANGLE M3_S_REG GRID M3_S_2_L
  WideEdge = M3_S_REG_CHECK COIN OUTSIDE EDGE M3_Wide
  PATH LENGTH WideEdge >= M3_S_2_L
}

M3.E.1 { @ Min. extension of a M3 region beyond a VIA2 region < 0.01
  ENC VIA2 M3 < 0.01 ABUT < 90 SINGULAR REGION
  VIA2 NOT M3
}

M3.E.2 { @ Min. extension of M3 end-of-line region beyond VIA2 region < 0.06
  X = ENC [VIA2] M3 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}


M3.A.1{ @ Min M3 area region < ^Mx_A_1
  AREA M3 < Mx_A_1
}


// Density check M3.R.1 included at the end of this file

// VIA3 checks
//=============
VIA3_CORE = VIA3 NOT SR_VIA3
VIA3.W.1 { @ VIA3 must be 0.26 x 0.26
  A = NOT RECTANGLE VIA3_CORE == 0.26 BY == 0.26 ORTHOGONAL ONLY
  A OUTSIDE RNGX   // exclude from metal fuse protection ring area
}

VIA3.S.1 { @ Min. VIA3 space < 0.26
  EXT VIA3 < 0.26 ABUT < 90 SINGULAR REGION 
}
VIA3.E.1 { @ Min. extension of a M3 region beyond a VIA3 region < 0.01
  ENC VIA3 M3 < 0.01 ABUT < 90 SINGULAR REGION
  VIA3 NOT M3    
}
VIA3.E.2 { @ Min. extension of M3 end-of-line region beyond VIA3 region < 0.06
  X = ENC [VIA3] M3 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26  ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}

#IFDEF Recommend
VIA3.E.3 {@ Minimum extension of M3 beyond the overlap area that VIA3 and VIA2 are fully or partially touching < ^VIA3_E_3
	X = VIA3 AND VIA2
	ENC X M3 < VIA3_E_3 ABUT < 90 SINGULAR REGION 
}
#ENDIF



// M4 checks
//=============
M4.W.1 { @ Min. M4 width < 0.28
  INT M4 < 0.28 ABUT < 90 SINGULAR REGION
}

M4.S.1 { @ Min. M4 space < 0.28
  EXT M4 < 0.28 ABUT < 90 SINGULAR REGION
}

M4.S.2 { @ Min. space to wide M4 (>10um) < 0.6
  M4_S5 = SHRINK (SHRINK (SHRINK (SHRINK M4 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M4_G5 = GROW (GROW (GROW (GROW M4_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M4_Wide = M4_G5 AND M4
  M4_Exp = SIZE M4_Wide BY 1 INSIDE OF M4 STEP 0.196
  M4_Branch = M4_Exp NOT M4_Wide
  M4_Branch_edge = M4_Branch COIN INSIDE EDGE M4
  M4_Check = M4 AND (SIZE M4_Exp BY 0.6)
  M4_Branch_Check = M4 AND (EXPAND EDGE M4_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
  M4_WideC = STAMP M4_Wide BY M4xd
  M4_CheckC = STAMP M4_Check BY M4xd
  M4_BranchC = STAMP M4_Branch BY M4xd
  M4_Branch_CheckC = STAMP M4_Branch_Check BY M4xd
  EXT M4_WideC M4_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M4_BranchC M4_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
M4.S.2.1.a { @ Min. space betweem wide metal and small piece of metal with parallel run length >= ^M4_S_2_L and same connection >=^M4_S_2_1 um
  M4_S5 = SHRINK (SHRINK (SHRINK (SHRINK M4 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M4_G5 = GROW (GROW (GROW (GROW M4_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M4_Wide = M4_G5 AND M4
  M4_Small = M4 NOT M4_Wide
  M4_WideC = STAMP M4_Wide BY M4xd
  M4_SmallC = STAMP M4_Small BY M4xd
  M4_S_REG = EXT M4_WideC M4_SmallC < M4_S_2_1 CONNECTED OPPOSITE REGION MEASURE ALL
  M4_S_REG_CHECK = ENCLOSE RECTANGLE M4_S_REG GRID M4_S_2_L 
  WideEdge1 = M4_S_REG_CHECK COIN OUTSIDE EDGE M4_Wide
  M4_Small_Edge = M4_Small COIN INSIDE EDGE M4
  WideEdge2 = M4_S_REG_CHECK COIN OUTSIDE EDGE M4_Small_Edge
  PATH LENGTH WideEdge1 >= M4_S_2_L
  PATH LENGTH WideEdge2 >= M4_S_2_L
}
M4.S.2.1.b { @ Min. space between two wide metals with parallel run length >= ^M4_S_2_L and same connection >=^M4_S_2_2 um
  M4_S5 = SHRINK (SHRINK (SHRINK (SHRINK M4 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M4_G5 = GROW (GROW (GROW (GROW M4_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M4_Wide = M4_G5 AND M4
  M4_WideC = STAMP M4_Wide BY M4xd
  M4_S_REG = EXT M4_WideC < M4_S_2_2 CONNECTED OPPOSITE REGION
  M4_S_REG_CHECK = ENCLOSE RECTANGLE M4_S_REG GRID M4_S_2_L
  WideEdge = M4_S_REG_CHECK COIN OUTSIDE EDGE M4_Wide
  PATH LENGTH WideEdge >= M4_S_2_L
}

M4.E.1 { @ Min. extension of a M4 region beyond a VIA3 region < 0.01
  ENC VIA3 M4 < 0.01 ABUT < 90 SINGULAR REGION
  VIA3 NOT M4
}

M4.E.2 { @ Min. extension of M4 end-of-line region beyond VIA3 region < 0.06
  X = ENC [VIA3] M4 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}


M4.A.1{ @ Min M4 area region < ^Mx_A_1
  AREA M4 < Mx_A_1
}


// Density check M4.R.1 included at the end of this file

// VIA4 checks
//=============
VIA4_CORE = VIA4 NOT SR_VIA4
VIA4.W.1 { @ VIA4 must be 0.26 x 0.26
  A = NOT RECTANGLE VIA4_CORE == 0.26 BY == 0.26 ORTHOGONAL ONLY
  A OUTSIDE RNGX   // exclude from metal fuse protection ring area
}

VIA4.S.1 { @ Min. VIA4 space < 0.26
  EXT VIA4 < 0.26 ABUT < 90 SINGULAR REGION 
}
VIA4.E.1 { @ Min. extension of a M4 region beyond a VIA4 region < 0.01
  ENC VIA4 M4 < 0.01 ABUT < 90 SINGULAR REGION
  VIA4 NOT M4    
}
VIA4.E.2 { @ Min. extension of M4 end-of-line region beyond VIA4 region < 0.06
  X = ENC [VIA4] M4 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26  ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}

#IFDEF Recommend
VIA4.E.3 {@ Minimum extension of M4 beyond the overlap area that VIA4 and VIA3 are fully or partially touching < ^VIA4_E_3
	X = VIA4 AND VIA3
	ENC X M4 < VIA4_E_3 ABUT < 90 SINGULAR REGION 
}
#ENDIF



// M5 checks
//=============
M5.W.1 { @ Min. M5 width < 0.28
  INT M5 < 0.28 ABUT < 90 SINGULAR REGION
}

M5.S.1 { @ Min. M5 space < 0.28
  EXT M5 < 0.28 ABUT < 90 SINGULAR REGION
}

M5.S.2 { @ Min. space to wide M5 (>10um) < 0.6
  M5_S5 = SHRINK (SHRINK (SHRINK (SHRINK M5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M5_G5 = GROW (GROW (GROW (GROW M5_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M5_Wide = M5_G5 AND M5
  M5_Exp = SIZE M5_Wide BY 1 INSIDE OF M5 STEP 0.196
  M5_Branch = M5_Exp NOT M5_Wide
  M5_Branch_edge = M5_Branch COIN INSIDE EDGE M5
  M5_Check = M5 AND (SIZE M5_Exp BY 0.6)
  M5_Branch_Check = M5 AND (EXPAND EDGE M5_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
  M5_WideC = STAMP M5_Wide BY M5xd
  M5_CheckC = STAMP M5_Check BY M5xd
  M5_BranchC = STAMP M5_Branch BY M5xd
  M5_Branch_CheckC = STAMP M5_Branch_Check BY M5xd
  EXT M5_WideC M5_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M5_BranchC M5_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
M5.S.2.1.a { @ Min. space betweem wide metal and small piece of metal with parallel run length >= ^M5_S_2_L and same connection >=^M5_S_2_1 um
  M5_S5 = SHRINK (SHRINK (SHRINK (SHRINK M5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M5_G5 = GROW (GROW (GROW (GROW M5_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M5_Wide = M5_G5 AND M5
  M5_Small = M5 NOT M5_Wide
  M5_WideC = STAMP M5_Wide BY M5xd
  M5_SmallC = STAMP M5_Small BY M5xd
  M5_S_REG = EXT M5_WideC M5_SmallC < M5_S_2_1 CONNECTED OPPOSITE REGION MEASURE ALL
  M5_S_REG_CHECK = ENCLOSE RECTANGLE M5_S_REG GRID M5_S_2_L 
  WideEdge1 = M5_S_REG_CHECK COIN OUTSIDE EDGE M5_Wide
  M5_Small_Edge = M5_Small COIN INSIDE EDGE M5
  WideEdge2 = M5_S_REG_CHECK COIN OUTSIDE EDGE M5_Small_Edge
  PATH LENGTH WideEdge1 >= M5_S_2_L
  PATH LENGTH WideEdge2 >= M5_S_2_L
}
M5.S.2.1.b { @ Min. space between two wide metals with parallel run length >= ^M5_S_2_L and same connection >=^M5_S_2_2 um
  M5_S5 = SHRINK (SHRINK (SHRINK (SHRINK M5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M5_G5 = GROW (GROW (GROW (GROW M5_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M5_Wide = M5_G5 AND M5
  M5_WideC = STAMP M5_Wide BY M5xd
  M5_S_REG = EXT M5_WideC < M5_S_2_2 CONNECTED OPPOSITE REGION
  M5_S_REG_CHECK = ENCLOSE RECTANGLE M5_S_REG GRID M5_S_2_L
  WideEdge = M5_S_REG_CHECK COIN OUTSIDE EDGE M5_Wide
  PATH LENGTH WideEdge >= M5_S_2_L
}

M5.E.1 { @ Min. extension of a M5 region beyond a VIA4 region < 0.01
  ENC VIA4 M5 < 0.01 ABUT < 90 SINGULAR REGION
  VIA4 NOT M5
}

M5.E.2 { @ Min. extension of M5 end-of-line region beyond VIA4 region < 0.06
  X = ENC [VIA4] M5 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}


M5.A.1{ @ Min M5 area region < ^Mx_A_1
  AREA M5 < Mx_A_1
}


// Density check M5.R.1 included at the end of this file





/*****  Variables for IMD crack check *****/
VARIABLE  VIA_W_1      5.0   //The width of ViaArray
VARIABLE  VIA_S_1      5.0 //VIA ARAAY interal space. 
VARIABLE  VIA_S_2      2.7 //Space of metal between via array

VARIABLE  Mx_S_3_7      1.2 //Space of both metal with larger via array area

VARIABLE  VIA_S_2L     15.0  //via array parrallel run length
VARIABLE  VIA_S_4      5.0 //Metal extension space 
VARIABLE  VIA_S_5      12.7 //Space of VIA array (5.0+2.7+5.0)

VARIABLE  VIA_A_5      300.0 //The overlap area of 5 level continuous stack via array.

VARIABLE  VIA_A_5_B      500.0 //The overlap area of 5 level continuous stack via array for viax.s.6.

VARIABLE  VIA_A_4      725.0 //The overlap area of 4 level continuous stack via array.

VARIABLE  VIA_A_4_B      1000.0 //The overlap area of 4 level continuous stack via array for viax.s.7.

VARIABLE  VIA_A_3      960.0 //The overlap area of 3 level continuous stack via array.

VARIABLE  VIA_A_3_B      2000.0 //The overlap area of 3 level continuous stack via array for viax.s.8.

VARIABLE  VIA_A_2     3000.0 //The overlap area of 2 level continuous stack via array.
VARIABLE  VIA_A_2_B     4000.0 //The overlap area of 2 level continuous stack via array for viax.s.9.
VARIABLE  VIA_A_1     4900.0 //The region area of single layer via array for viax.s.10.

VARIABLE  VIA_Merge   2.505  //The Merge error VIAs and highlight error vias region

VARIABLE  VIA_D_1     0.10 //The highlight array minimum density
VARIABLE  VIA_S_3     0.49 //Space of via in via array.
VARIABLE  VIA_Filter   3.0 // Shrink via arrary For broken small metal connection.
//********************************************
//***** Pre-processing for IMD crack check **** 
//********************************************
//
// Processing for SAME Array Merged 
//*********************************
  VIA1_M = VIA1 INTERACT M1 
  VIA1Merge1 = SIZE VIA1_M BY VIA_S_1/2 INSIDE OF M1 STEP 0.46
  VIA1Merge2 = SIZE VIA1_M BY VIA_S_1/2 OVERUNDER                 // Any space <= VIA1_S_1 um treated as "array"
  VIA1Merge.pre1 = VIA1Merge1 AND VIA1Merge2                      // Find merged via array(s)
  VIA1Merge.pre11 = ENCLOSE RECTANGLE VIA1Merge.pre1 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  VIA1Merge.pre12 = VIA1_M INTERACT VIA1Merge.pre11                    // find VIA1 in the effective via arrary
  VIA1Merge.pre13 = SIZE VIA1Merge.pre12 BY VIA_S_1/2 OVERUNDER        // Any space <= VIA1_S_1 um treated as "array"
  VIA1Merge.pre2  = VIA1Merge1 AND VIA1Merge.pre13                     // Find merged via array(s)
  VIA1_same_array = SIZE VIA1Merge.pre2 BY VIA_Filter/2 UNDEROVER // For broken small metal connection

  VIA1_same_array_B = SIZE VIA1Merge.pre1 BY VIA_Filter/2 UNDEROVER // For broken small metal connection

  VIA2_M = VIA2 INTERACT M2 
  VIA2Merge1 = SIZE VIA2_M BY VIA_S_1/2 INSIDE OF M2 STEP 0.46
  VIA2Merge2 = SIZE VIA2_M BY VIA_S_1/2 OVERUNDER                 // Any space <= VIA1_S_1 um treated as "array"
  VIA2Merge.pre1 = VIA2Merge1 AND VIA2Merge2                      // Find merged via array(s)
  VIA2Merge.pre11 = ENCLOSE RECTANGLE VIA2Merge.pre1 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  VIA2Merge.pre12 = VIA2_M INTERACT VIA2Merge.pre11                    // find VIA2 in the effective via arrary
  VIA2Merge.pre13 = SIZE VIA2Merge.pre12 BY VIA_S_1/2 OVERUNDER        // Any space <= VIA1_S_1 um treated as "array"
  VIA2Merge.pre2  = VIA2Merge1 AND VIA2Merge.pre13                     // Find merged via array(s)
  VIA2_same_array = SIZE VIA2Merge.pre2 BY VIA_Filter/2 UNDEROVER // For broken small metal connection

  VIA2_same_array_B = SIZE VIA2Merge.pre1 BY VIA_Filter/2 UNDEROVER // For broken small metal connection

  VIA3_M = VIA3 INTERACT M3 
  VIA3Merge1 = SIZE VIA3_M BY VIA_S_1/2 INSIDE OF M3 STEP 0.46
  VIA3Merge2 = SIZE VIA3_M BY VIA_S_1/2 OVERUNDER                 // Any space <= VIA1_S_1 um treated as "array"
  VIA3Merge.pre1 = VIA3Merge1 AND VIA3Merge2                      // Find merged via array(s)
  VIA3Merge.pre11 = ENCLOSE RECTANGLE VIA3Merge.pre1 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  VIA3Merge.pre12 = VIA3_M INTERACT VIA3Merge.pre11                    // find VIA3 in the effective via arrary
  VIA3Merge.pre13 = SIZE VIA3Merge.pre12 BY VIA_S_1/2 OVERUNDER        // Any space <= VIA1_S_1 um treated as "array"
  VIA3Merge.pre2  = VIA3Merge1 AND VIA3Merge.pre13                     // Find merged via array(s)
  VIA3_same_array = SIZE VIA3Merge.pre2 BY VIA_Filter/2 UNDEROVER // For broken small metal connection

  VIA3_same_array_B = SIZE VIA3Merge.pre1 BY VIA_Filter/2 UNDEROVER // For broken small metal connection

  VIA4_M = VIA4 INTERACT M4 
  VIA4Merge1 = SIZE VIA4_M BY VIA_S_1/2 INSIDE OF M4 STEP 0.46
  VIA4Merge2 = SIZE VIA4_M BY VIA_S_1/2 OVERUNDER                 // Any space <= VIA1_S_1 um treated as "array"
  VIA4Merge.pre1 = VIA4Merge1 AND VIA4Merge2                      // Find merged via array(s)
  VIA4Merge.pre11 = ENCLOSE RECTANGLE VIA4Merge.pre1 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  VIA4Merge.pre12 = VIA4_M INTERACT VIA4Merge.pre11                    // find VIA4 in the effective via arrary
  VIA4Merge.pre13 = SIZE VIA4Merge.pre12 BY VIA_S_1/2 OVERUNDER        // Any space <= VIA1_S_1 um treated as "array"
  VIA4Merge.pre2  = VIA4Merge1 AND VIA4Merge.pre13                     // Find merged via array(s)
  VIA4_same_array = SIZE VIA4Merge.pre2 BY VIA_Filter/2 UNDEROVER // For broken small metal connection

  VIA4_same_array_B = SIZE VIA4Merge.pre1 BY VIA_Filter/2 UNDEROVER // For broken small metal connection

  VIA5_M = VIA5 INTERACT M5 
  VIA5Merge1 = SIZE VIA5_M BY VIA_S_1/2 INSIDE OF M5 STEP 0.46
  VIA5Merge2 = SIZE VIA5_M BY VIA_S_1/2 OVERUNDER                 // Any space <= VIA1_S_1 um treated as "array"
  VIA5Merge.pre1 = VIA5Merge1 AND VIA5Merge2                      // Find merged via array(s)
  VIA5Merge.pre11 = ENCLOSE RECTANGLE VIA5Merge.pre1 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  VIA5Merge.pre12 = VIA5_M INTERACT VIA5Merge.pre11                    // find VIA5 in the effective via arrary
  VIA5Merge.pre13 = SIZE VIA5Merge.pre12 BY VIA_S_1/2 OVERUNDER        // Any space <= VIA1_S_1 um treated as "array"
  VIA5Merge.pre2  = VIA5Merge1 AND VIA5Merge.pre13                     // Find merged via array(s)
  VIA5_same_array = SIZE VIA5Merge.pre2 BY VIA_Filter/2 UNDEROVER // For broken small metal connection

  VIA5_same_array_B = SIZE VIA5Merge.pre1 BY VIA_Filter/2 UNDEROVER // For broken small metal connection


// Processing for 5 ~ 1 Stack Array  
//**********************************

  VIA1_same_array_5stack.pre1 = ((((AREA VIA1_same_array >= VIA_A_5) AND (AREA VIA2_same_array>= VIA_A_5 )) AND ( AREA VIA3_same_array>= VIA_A_5)) AND (AREA VIA4_same_array >= VIA_A_5)) AND ( AREA VIA5_same_array >= VIA_A_5 ) 
  VIA1_same_array_5stack.pre2 = AREA VIA1_same_array_5stack.pre1 >= VIA_A_5


  VIA1_same_array_5stack_S_6.pre1 = ((((AREA VIA1_same_array_B >= VIA_A_5_B) AND (AREA VIA2_same_array_B >= VIA_A_5_B )) AND ( AREA VIA3_same_array_B >= VIA_A_5_B)) AND (AREA VIA4_same_array_B >= VIA_A_5_B)) AND ( AREA VIA5_same_array_B >= VIA_A_5_B ) 
  VIA1_same_array_5stack_S_6.pre2 = AREA VIA1_same_array_5stack_S_6.pre1 >= VIA_A_5_B
  VIA1_same_array_5stack_Mx_S3.pre1 = ((((AREA VIA1_same_array >= VIA_A_5_B) AND (AREA VIA2_same_array >= VIA_A_5_B )) AND ( AREA VIA3_same_array >= VIA_A_5_B)) AND (AREA VIA4_same_array >= VIA_A_5_B)) AND ( AREA VIA5_same_array >= VIA_A_5_B ) 
  VIA1_same_array_5stack_Mx_S3.pre2 = AREA VIA1_same_array_5stack_Mx_S3.pre1 >= VIA_A_5_B



  VIA1_same_array_4stack.pre1 = ((( AREA VIA1_same_array >= VIA_A_4)  AND (AREA VIA2_same_array >= VIA_A_4)) AND ( AREA VIA3_same_array>= VIA_A_4 )) AND ( AREA VIA4_same_array >= VIA_A_4 )
  VIA1_same_array_4stack.pre2 = AREA VIA1_same_array_4stack.pre1 >= VIA_A_4


  VIA1_same_array_4stack_S_7.pre1 = ((( AREA VIA1_same_array_B >= VIA_A_4_B) AND (AREA VIA2_same_array_B >= VIA_A_4_B)) AND ( AREA VIA3_same_array_B >= VIA_A_4_B )) AND ( AREA VIA4_same_array_B >= VIA_A_4_B )
  VIA1_same_array_4stack_S_7.pre2 = AREA VIA1_same_array_4stack_S_7.pre1 >= VIA_A_4_B
  VIA1_same_array_4stack_Mx_S4.pre1 = ((( AREA VIA1_same_array >= VIA_A_4_B) AND (AREA VIA2_same_array >= VIA_A_4_B)) AND ( AREA VIA3_same_array >= VIA_A_4_B )) AND ( AREA VIA4_same_array >= VIA_A_4_B )
  VIA1_same_array_4stack_Mx_S4.pre2 = AREA VIA1_same_array_4stack_Mx_S4.pre1 >= VIA_A_4_B

  VIA2_same_array_4stack.pre1 = ((( AREA VIA2_same_array >= VIA_A_4)  AND (AREA VIA3_same_array >= VIA_A_4)) AND ( AREA VIA4_same_array>= VIA_A_4 )) AND ( AREA VIA5_same_array >= VIA_A_4 )
  VIA2_same_array_4stack.pre2 = AREA VIA2_same_array_4stack.pre1 >= VIA_A_4


  VIA2_same_array_4stack_S_7.pre1 = ((( AREA VIA2_same_array_B >= VIA_A_4_B) AND (AREA VIA3_same_array_B >= VIA_A_4_B)) AND ( AREA VIA4_same_array_B >= VIA_A_4_B )) AND ( AREA VIA5_same_array_B >= VIA_A_4_B )
  VIA2_same_array_4stack_S_7.pre2 = AREA VIA2_same_array_4stack_S_7.pre1 >= VIA_A_4_B
  VIA2_same_array_4stack_Mx_S4.pre1 = ((( AREA VIA2_same_array >= VIA_A_4_B) AND (AREA VIA3_same_array >= VIA_A_4_B)) AND ( AREA VIA4_same_array >= VIA_A_4_B )) AND ( AREA VIA5_same_array >= VIA_A_4_B )
  VIA2_same_array_4stack_Mx_S4.pre2 = AREA VIA2_same_array_4stack_Mx_S4.pre1 >= VIA_A_4_B


  VIA1_same_array_3stack.pre1 = ((AREA VIA1_same_array >= VIA_A_3 ) AND (AREA VIA2_same_array >= VIA_A_3)) AND ( AREA VIA3_same_array >= VIA_A_3 )
  VIA1_same_array_3stack.pre2 = AREA VIA1_same_array_3stack.pre1 >= VIA_A_3


  VIA1_same_array_3stack_S_8.pre1 = ((AREA VIA1_same_array_B >= VIA_A_3_B ) AND (AREA VIA2_same_array_B >= VIA_A_3_B)) AND ( AREA VIA3_same_array_B >= VIA_A_3_B )
  VIA1_same_array_3stack_S_8.pre2 = AREA VIA1_same_array_3stack_S_8.pre1 >= VIA_A_3_B
  VIA1_same_array_3stack_Mx_S5.pre1 = ((AREA VIA1_same_array >= VIA_A_3_B ) AND (AREA VIA2_same_array >= VIA_A_3_B)) AND ( AREA VIA3_same_array >= VIA_A_3_B )
  VIA1_same_array_3stack_Mx_S5.pre2 = AREA VIA1_same_array_3stack_Mx_S5.pre1 >= VIA_A_3_B

  VIA2_same_array_3stack.pre1 = ((AREA VIA2_same_array >= VIA_A_3 ) AND (AREA VIA3_same_array >= VIA_A_3)) AND ( AREA VIA4_same_array >= VIA_A_3 )
  VIA2_same_array_3stack.pre2 = AREA VIA2_same_array_3stack.pre1 >= VIA_A_3


  VIA2_same_array_3stack_S_8.pre1 = ((AREA VIA2_same_array_B >= VIA_A_3_B ) AND (AREA VIA3_same_array_B >= VIA_A_3_B)) AND ( AREA VIA4_same_array_B >= VIA_A_3_B )
  VIA2_same_array_3stack_S_8.pre2 = AREA VIA2_same_array_3stack_S_8.pre1 >= VIA_A_3_B
  VIA2_same_array_3stack_Mx_S5.pre1 = ((AREA VIA2_same_array >= VIA_A_3_B ) AND (AREA VIA3_same_array >= VIA_A_3_B)) AND ( AREA VIA4_same_array >= VIA_A_3_B )
  VIA2_same_array_3stack_Mx_S5.pre2 = AREA VIA2_same_array_3stack_Mx_S5.pre1 >= VIA_A_3_B

  VIA3_same_array_3stack.pre1 = ((AREA VIA3_same_array >= VIA_A_3 ) AND (AREA VIA4_same_array >= VIA_A_3)) AND ( AREA VIA5_same_array >= VIA_A_3 )
  VIA3_same_array_3stack.pre2 = AREA VIA3_same_array_3stack.pre1 >= VIA_A_3


  VIA3_same_array_3stack_S_8.pre1 = ((AREA VIA3_same_array_B >= VIA_A_3_B ) AND (AREA VIA4_same_array_B >= VIA_A_3_B)) AND ( AREA VIA5_same_array_B >= VIA_A_3_B )
  VIA3_same_array_3stack_S_8.pre2 = AREA VIA3_same_array_3stack_S_8.pre1 >= VIA_A_3_B
  VIA3_same_array_3stack_Mx_S5.pre1 = ((AREA VIA3_same_array >= VIA_A_3_B ) AND (AREA VIA4_same_array >= VIA_A_3_B)) AND ( AREA VIA5_same_array >= VIA_A_3_B )
  VIA3_same_array_3stack_Mx_S5.pre2 = AREA VIA3_same_array_3stack_Mx_S5.pre1 >= VIA_A_3_B

  
  VIA1_same_array_2stack.pre1 = ( AREA VIA1_same_array >= VIA_A_2 ) AND (AREA VIA2_same_array >= VIA_A_2 )
  VIA1_same_array_2stack.pre2 = AREA VIA1_same_array_2stack.pre1 >= VIA_A_2


  VIA1_same_array_2stack_S_9.pre1 = ( AREA VIA1_same_array_B >= VIA_A_2_B ) AND (AREA VIA2_same_array_B >= VIA_A_2_B )
  VIA1_same_array_2stack_S_9.pre2 = AREA VIA1_same_array_2stack_S_9.pre1 >= VIA_A_2_B
  VIA1_same_array_2stack_Mx_S6.pre1 = ( AREA VIA1_same_array >= VIA_A_2_B ) AND (AREA VIA2_same_array >= VIA_A_2_B )
  VIA1_same_array_2stack_Mx_S6.pre2 = AREA VIA1_same_array_2stack_Mx_S6.pre1 >= VIA_A_2_B

  VIA2_same_array_2stack.pre1 = ( AREA VIA2_same_array >= VIA_A_2 ) AND (AREA VIA3_same_array >= VIA_A_2 )
  VIA2_same_array_2stack.pre2 = AREA VIA2_same_array_2stack.pre1 >= VIA_A_2


  VIA2_same_array_2stack_S_9.pre1 = ( AREA VIA2_same_array_B >= VIA_A_2_B ) AND (AREA VIA3_same_array_B >= VIA_A_2_B )
  VIA2_same_array_2stack_S_9.pre2 = AREA VIA2_same_array_2stack_S_9.pre1 >= VIA_A_2_B
  VIA2_same_array_2stack_Mx_S6.pre1 = ( AREA VIA2_same_array >= VIA_A_2_B ) AND (AREA VIA3_same_array >= VIA_A_2_B )
  VIA2_same_array_2stack_Mx_S6.pre2 = AREA VIA2_same_array_2stack_Mx_S6.pre1 >= VIA_A_2_B

  VIA3_same_array_2stack.pre1 = ( AREA VIA3_same_array >= VIA_A_2 ) AND (AREA VIA4_same_array >= VIA_A_2 )
  VIA3_same_array_2stack.pre2 = AREA VIA3_same_array_2stack.pre1 >= VIA_A_2


  VIA3_same_array_2stack_S_9.pre1 = ( AREA VIA3_same_array_B >= VIA_A_2_B ) AND (AREA VIA4_same_array_B >= VIA_A_2_B )
  VIA3_same_array_2stack_S_9.pre2 = AREA VIA3_same_array_2stack_S_9.pre1 >= VIA_A_2_B
  VIA3_same_array_2stack_Mx_S6.pre1 = ( AREA VIA3_same_array >= VIA_A_2_B ) AND (AREA VIA4_same_array >= VIA_A_2_B )
  VIA3_same_array_2stack_Mx_S6.pre2 = AREA VIA3_same_array_2stack_Mx_S6.pre1 >= VIA_A_2_B

  VIA4_same_array_2stack.pre1 = ( AREA VIA4_same_array >= VIA_A_2 ) AND (AREA VIA5_same_array >= VIA_A_2 )
  VIA4_same_array_2stack.pre2 = AREA VIA4_same_array_2stack.pre1 >= VIA_A_2


  VIA4_same_array_2stack_S_9.pre1 = ( AREA VIA4_same_array_B >= VIA_A_2_B ) AND (AREA VIA5_same_array_B >= VIA_A_2_B )
  VIA4_same_array_2stack_S_9.pre2 = AREA VIA4_same_array_2stack_S_9.pre1 >= VIA_A_2_B
  VIA4_same_array_2stack_Mx_S6.pre1 = ( AREA VIA4_same_array >= VIA_A_2_B ) AND (AREA VIA5_same_array >= VIA_A_2_B )
  VIA4_same_array_2stack_Mx_S6.pre2 = AREA VIA4_same_array_2stack_Mx_S6.pre1 >= VIA_A_2_B




  VIA1_same_array_1stack_S_10.pre1 = AREA VIA1_same_array_B >= VIA_A_1
  VIA1_same_array_1stack_Mx_S7.pre1 = AREA VIA1_same_array >= VIA_A_1
  VIA2_same_array_1stack_S_10.pre1 = AREA VIA2_same_array_B >= VIA_A_1
  VIA2_same_array_1stack_Mx_S7.pre1 = AREA VIA2_same_array >= VIA_A_1
  VIA3_same_array_1stack_S_10.pre1 = AREA VIA3_same_array_B >= VIA_A_1
  VIA3_same_array_1stack_Mx_S7.pre1 = AREA VIA3_same_array >= VIA_A_1
  VIA4_same_array_1stack_S_10.pre1 = AREA VIA4_same_array_B >= VIA_A_1
  VIA4_same_array_1stack_Mx_S7.pre1 = AREA VIA4_same_array >= VIA_A_1
  VIA5_same_array_1stack_S_10.pre1 = AREA VIA5_same_array_B >= VIA_A_1
  VIA5_same_array_1stack_Mx_S7.pre1 = AREA VIA5_same_array >= VIA_A_1


//**********************  
// Small 5 stack array
//**********************
// Processing for SAME Array Size Check    
//**************************************
  VIA1_5stack.pre3 = ENCLOSE RECTANGLE VIA1_same_array_5stack.pre2 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  M1_5stack.pre3 = (((((M1 INTERACT VIA1_5stack.pre3) OR (M2 INTERACT VIA1_5stack.pre3)) OR (M3 INTERACT VIA1_5stack.pre3)) OR (M4 INTERACT VIA1_5stack.pre3)) OR (M5 INTERACT VIA1_5stack.pre3)) OR (M6 INTERACT VIA1_5stack.pre3)

  VIA1_Reg_3_S_5 = EXT VIA1_5stack.pre3 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90
  VIA1_Reg_3_S_5_pre = VIA1_Reg_3_S_5 NOT M1_5stack.pre3
  VIA1_Reg_3_S_5_1 = ENCLOSE RECTANGLE VIA1_Reg_3_S_5_pre 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L
  VIA1_5stack.pre4 = VIA1_5stack.pre3 INTERACT (VIA1_Reg_3_S_5 INTERACT VIA1_Reg_3_S_5_1)
  VIA1ArrayS1_S_5 = EXT VIA1_5stack.pre4 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90
  VIA1ArrayS2_S_5 = (((((VIA1ArrayS1_S_5 NOT INSIDE M1) NOT INSIDE M2) NOT INSIDE M3) NOT INSIDE M4) NOT INSIDE M5 ) NOT INSIDE M6 
  VIA1_5stack.pre5 = VIA1_5stack.pre4 INTERACT VIA1ArrayS2_S_5

  M1_5stack.pre4 = EXT M1_5stack.pre3 <= VIA_S_2 ABUT < 90 OPPOSITE SINGULAR REGION
  M1_5stack.pre4_edge = M1_5stack.pre3 COIN OUTSIDE EDGE M1_5stack.pre4
  M1_5stack.pre5 = EXPAND EDGE M1_5stack.pre4_edge INSIDE BY VIA_S_4
  M1_5stack.pre5_region_1 = M1_5stack.pre5 INTERACT VIA1_5stack.pre5
  M1_5stack.pre5_region = M1_5stack.pre4 INTERACT M1_5stack.pre5_region_1 >= 2
  M1_5stack.pre6 = M1_5stack.pre5_region OR M1_5stack.pre5_region_1
  M1_5stack.pre7 = M1_5stack.pre6 INTERACT VIA1_5stack.pre5 >= 2
  VIA1_5stack.Final = VIA1_5stack.pre5 INTERACT M1_5stack.pre7  
  VIA1_S_5_A1 = VIA1 INTERACT VIA1_5stack.Final 
  VIA1_Reg_4_S_5_A1 = EXT VIA1_S_5_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA1s space smaller than 0.49 (inside small array)  
  VIA1_Violate_S_5_A1= VIA1_S_5_A1 INTERACT VIA1_Reg_4_S_5_A1                 
  VIA2_S_5_A1 = VIA2 INTERACT VIA1_5stack.Final 
  VIA2_Reg_4_S_5_A1 = EXT VIA2_S_5_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_5_A1 = VIA2_S_5_A1 INTERACT VIA2_Reg_4_S_5_A1  
  VIA3_S_5_A1 = VIA3 INTERACT VIA1_5stack.Final 
  VIA3_Reg_4_S_5_A1 = EXT VIA3_S_5_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_5_A1 = VIA3_S_5_A1 INTERACT VIA3_Reg_4_S_5_A1  
  VIA4_S_5_A1 = VIA4 INTERACT VIA1_5stack.Final 
  VIA4_Reg_4_S_5_A1 = EXT VIA4_S_5_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_5_A1 = VIA4_S_5_A1 INTERACT VIA4_Reg_4_S_5_A1  
  VIA5_S_5_A1 = VIA5 INTERACT VIA1_5stack.Final 
  VIA5_Reg_4_S_5_A1 = EXT VIA5_S_5_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA5s space smaller than 0.49 (inside small array)  
  VIA5_Violate_S_5_A1 = VIA5_S_5_A1 INTERACT VIA5_Reg_4_S_5_A1  






// Processing for VIAx.S.6 Check    
//**************************************
  M1_5stack_S_6.pre3 = (((((M1 INTERACT VIA1_same_array_5stack_S_6.pre2) OR (M2 INTERACT VIA1_same_array_5stack_S_6.pre2)) OR (M3 INTERACT VIA1_same_array_5stack_S_6.pre2)) OR (M4 INTERACT VIA1_same_array_5stack_S_6.pre2)) OR (M5 INTERACT VIA1_same_array_5stack_S_6.pre2)) OR (M6 INTERACT VIA1_same_array_5stack_S_6.pre2)
  VIA1_5stack_S_6.pre3 = SIZE VIA1_same_array_5stack_S_6.pre2 BY VIA_S_4 INSIDE OF M1_5stack_S_6.pre3 STEP 0.28
  VIA1_5stack_S_6.pre4 = VIA1_5stack_S_6.pre3 TOUCH EDGE M1_5stack_S_6.pre3
  VIA1_5stack_S_6.pre5 = VIA1_5stack_S_6.pre3 WITH EDGE VIA1_5stack_S_6.pre4 >= 1
  VIA1_5stack_S_6.Final = VIA1_same_array_5stack_S_6.pre2 INTERACT VIA1_5stack_S_6.pre5

  VIA1_S_5_B1 = VIA1 INTERACT VIA1_5stack_S_6.Final 
  VIA1_Reg_4_S_5_B1 = EXT VIA1_S_5_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA1s space smaller than 0.49 (inside small array)  
  VIA1_Violate_S_5_B1= VIA1_S_5_B1 INTERACT VIA1_Reg_4_S_5_B1                 
  VIA2_S_5_B1 = VIA2 INTERACT VIA1_5stack_S_6.Final 
  VIA2_Reg_4_S_5_B1 = EXT VIA2_S_5_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_5_B1 = VIA2_S_5_B1 INTERACT VIA2_Reg_4_S_5_B1  
  VIA3_S_5_B1 = VIA3 INTERACT VIA1_5stack_S_6.Final 
  VIA3_Reg_4_S_5_B1 = EXT VIA3_S_5_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_5_B1 = VIA3_S_5_B1 INTERACT VIA3_Reg_4_S_5_B1  
  VIA4_S_5_B1 = VIA4 INTERACT VIA1_5stack_S_6.Final 
  VIA4_Reg_4_S_5_B1 = EXT VIA4_S_5_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_5_B1 = VIA4_S_5_B1 INTERACT VIA4_Reg_4_S_5_B1  
  VIA5_S_5_B1 = VIA5 INTERACT VIA1_5stack_S_6.Final 
  VIA5_Reg_4_S_5_B1 = EXT VIA5_S_5_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA5s space smaller than 0.49 (inside small array)  
  VIA5_Violate_S_5_B1 = VIA5_S_5_B1 INTERACT VIA5_Reg_4_S_5_B1  



// Processing for Mx.S.3 Check    
//**************************************
  VIA1_5stack_Mx_S3.pre3 = ENCLOSE RECTANGLE VIA1_same_array_5stack_Mx_S3.pre2 VIA_W_1 VIA_W_1  // Find at least one width >= VIA_W_1

  M1_S_5_C1 = ENC VIA1_5stack_Mx_S3.pre3 [M1] <= VIA_S_4 ABUT < 90 SINGULAR 
  M1_Reg_4_S_5_C1 = EXT M1_S_5_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M1s space smaller than 1.2   
  M2_S_5_C1 = ENC VIA1_5stack_Mx_S3.pre3 [M2] <= VIA_S_4 ABUT < 90 SINGULAR 
  M2_Reg_4_S_5_C1 = EXT M2_S_5_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M2s space smaller than 1.2   
  M3_S_5_C1 = ENC VIA1_5stack_Mx_S3.pre3 [M3] <= VIA_S_4 ABUT < 90 SINGULAR 
  M3_Reg_4_S_5_C1 = EXT M3_S_5_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M3s space smaller than 1.2   
  M4_S_5_C1 = ENC VIA1_5stack_Mx_S3.pre3 [M4] <= VIA_S_4 ABUT < 90 SINGULAR 
  M4_Reg_4_S_5_C1 = EXT M4_S_5_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M4s space smaller than 1.2   
  M5_S_5_C1 = ENC VIA1_5stack_Mx_S3.pre3 [M5] <= VIA_S_4 ABUT < 90 SINGULAR 
  M5_Reg_4_S_5_C1 = EXT M5_S_5_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M5s space smaller than 1.2   



  
// Rule Check    
//**************************************
  CONNECT VIA1_5stack.Final VIA1_Violate_S_5_A1
  CONNECT VIA1_5stack.Final VIA2_Violate_S_5_A1
  CONNECT VIA1_5stack.Final VIA3_Violate_S_5_A1
  CONNECT VIA1_5stack.Final VIA4_Violate_S_5_A1
  CONNECT VIA1_5stack.Final VIA5_Violate_S_5_A1


VIA1.S.2_Array1_2_3_4_5_M {@Minimum space between two VIAs in 5-level continuous stacking VIA arrays with below condition. >=0.49um
    @ Via1 violate ^VIA_S_3 spacing in Via1/Via2/Via3/Via4/Via5 array & density large or equal ^VIA_D_1 
  A1 = NET AREA RATIO VIA1_Violate_S_5_A1 VIA1_5stack.Final >= VIA_D_1
  A2 = NET AREA RATIO VIA2_Violate_S_5_A1 VIA1_5stack.Final >= VIA_D_1
  A3 = NET AREA RATIO VIA3_Violate_S_5_A1 VIA1_5stack.Final >= VIA_D_1
  A4 = NET AREA RATIO VIA4_Violate_S_5_A1 VIA1_5stack.Final >= VIA_D_1
  A5 = NET AREA RATIO VIA5_Violate_S_5_A1 VIA1_5stack.Final >= VIA_D_1
  B1 = (((A1 OR A2) OR A3) OR A4) OR A5
  SIZE B1 BY VIA_Merge OVERUNDER 
}


VIA1.S.6_Array1_2_3_4_5_M { @ Minimum space between two VIA1 region >= ^VIA_S_3 um if the overlap area of 5-level 
                            	   @ continuous stacking VIA arrays >= ^VIA_A_5_B um2 (except sealring region)
   (VIA1_5stack_S_6.Final INTERACT VIA1_Violate_S_5_B1) NOT INTERACT SEALRING_ALL
}

VIA2.S.6_Array1_2_3_4_5_M { @ Minimum space between two VIA2 region >= ^VIA_S_3 um if the overlap area of 5-level 
									@ continuous stacking VIA arrays >= ^VIA_A_5_B um2 (except sealring region)
   (VIA1_5stack_S_6.Final INTERACT VIA2_Violate_S_5_B1) NOT INTERACT SEALRING_ALL
}

VIA3.S.6_Array1_2_3_4_5_M { @ Minimum space between two VIA3 region >= ^VIA_S_3 um if the overlap area of 5-level 
									 @ continuous stacking VIA arrays >= ^VIA_A_5_B um2 (except sealring region)
   (VIA1_5stack_S_6.Final INTERACT VIA3_Violate_S_5_B1) NOT INTERACT SEALRING_ALL
}

VIA4.S.6_Array1_2_3_4_5_M { @ Minimum space between two VIA4 region >= ^VIA_S_3 um if the overlap area of 5-level
									 @ continuous stacking VIA arrays >= ^VIA_A_5_B um2 (except sealring region)
   (VIA1_5stack_S_6.Final INTERACT VIA4_Violate_S_5_B1) NOT INTERACT SEALRING_ALL
}

VIA5.S.6_Array1_2_3_4_5_M { @ Minimum space between two VIA5 region >= ^VIA_S_3 um if the overlap area of 5-level 
									 @ continuous stacking VIA arrays >= ^VIA_A_5_B um2 (except sealring region)
   (VIA1_5stack_S_6.Final INTERACT VIA5_Violate_S_5_B1) NOT INTERACT SEALRING_ALL
}

M1_2_3_4_5.S.3 { @ Minimum space between two Mx region with below conditions >= ^Mx_S_3_7 um 
				  @ (a1) both of the Mx with the overlap area of 5-level continuous VIA array area >= ^VIA_A_5_B um2
				  @ (a2) Width of 5-level continuous stacking VIA arrays >= ^VIA_W_1 um
  (((M1_Reg_4_S_5_C1 OR M2_Reg_4_S_5_C1) OR M3_Reg_4_S_5_C1) OR M4_Reg_4_S_5_C1) OR M5_Reg_4_S_5_C1 
}




//**********************  
// Small 4 stack array
//**********************
// Processing for SAME Array Size Check    
//**************************************
  VIA1_4stack.pre3 = ENCLOSE RECTANGLE VIA1_same_array_4stack.pre2 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  M1_4stack.pre3 = ((((M1 INTERACT VIA1_4stack.pre3) OR (M2 INTERACT VIA1_4stack.pre3)) OR (M3 INTERACT VIA1_4stack.pre3)) OR (M4 INTERACT VIA1_4stack.pre3)) OR (M5 INTERACT VIA1_4stack.pre3)
  VIA1_Reg_3_S_4 = EXT VIA1_4stack.pre3 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90
  VIA1_Reg_3_S_4_pre = VIA1_Reg_3_S_4 NOT M1_4stack.pre3
  VIA1_Reg_3_S_4_1 = ENCLOSE RECTANGLE VIA1_Reg_3_S_4_pre 0.005 VIA_S_2L  
  VIA1_4stack.pre4 = VIA1_4stack.pre3 INTERACT (VIA1_Reg_3_S_4 INTERACT VIA1_Reg_3_S_4_1)
  VIA1ArrayS1_S_4 = EXT VIA1_4stack.pre4 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90    // Space of different "smae array" smaller than VIA_S_2
  VIA1ArrayS2_S_4 = ((((VIA1ArrayS1_S_4 NOT INSIDE M1) NOT INSIDE M2) NOT INSIDE M3) NOT INSIDE M4) NOT INSIDE M5
  VIA1_4stack.pre5 = VIA1_4stack.pre4 INTERACT VIA1ArrayS2_S_4

  M1_4stack.pre4 = EXT M1_4stack.pre3 <= VIA_S_2 ABUT < 90 OPPOSITE SINGULAR REGION
  M1_4stack.pre4_edge = M1_4stack.pre3 COIN OUTSIDE EDGE M1_4stack.pre4
  M1_4stack.pre5 = EXPAND EDGE M1_4stack.pre4_edge INSIDE BY VIA_S_4
  M1_4stack.pre5_region_1 = M1_4stack.pre5 INTERACT VIA1_4stack.pre5
  M1_4stack.pre5_region = M1_4stack.pre4 INTERACT M1_4stack.pre5_region_1 >= 2
  M1_4stack.pre6 = M1_4stack.pre5_region OR M1_4stack.pre5_region_1
  M1_4stack.pre7 = M1_4stack.pre6 INTERACT VIA1_4stack.pre5 >= 2
  VIA1_4stack.Final = VIA1_4stack.pre5 INTERACT M1_4stack.pre7

  VIA1_S_4_A1 = VIA1 INTERACT VIA1_4stack.Final 
  VIA1_Reg_4_S_4_A1 = EXT VIA1_S_4_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA1s space smaller than 0.49 (inside small array)  
  VIA1_Violate_S_4_A1= VIA1_S_4_A1 INTERACT VIA1_Reg_4_S_4_A1                 
  VIA2_S_4_A1 = VIA2 INTERACT VIA1_4stack.Final 
  VIA2_Reg_4_S_4_A1 = EXT VIA2_S_4_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_4_A1 = VIA2_S_4_A1 INTERACT VIA2_Reg_4_S_4_A1  
  VIA3_S_4_A1 = VIA3 INTERACT VIA1_4stack.Final 
  VIA3_Reg_4_S_4_A1 = EXT VIA3_S_4_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_4_A1 = VIA3_S_4_A1 INTERACT VIA3_Reg_4_S_4_A1  
  VIA4_S_4_A1 = VIA4 INTERACT VIA1_4stack.Final 
  VIA4_Reg_4_S_4_A1 = EXT VIA4_S_4_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_4_A1 = VIA4_S_4_A1 INTERACT VIA4_Reg_4_S_4_A1  


  VIA2_4stack.pre3 = ENCLOSE RECTANGLE VIA2_same_array_4stack.pre2 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  M2_4stack.pre3 = ((((M2 INTERACT VIA2_4stack.pre3) OR (M3 INTERACT VIA2_4stack.pre3)) OR (M4 INTERACT VIA2_4stack.pre3)) OR (M5 INTERACT VIA2_4stack.pre3)) OR (M6 INTERACT VIA2_4stack.pre3)
  VIA2_Reg_3_S_4 = EXT VIA2_4stack.pre3 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90
  VIA2_Reg_3_S_4_pre = VIA2_Reg_3_S_4 NOT M2_4stack.pre3
  VIA2_Reg_3_S_4_1 = ENCLOSE RECTANGLE VIA2_Reg_3_S_4_pre 0.005 VIA_S_2L  
  VIA2_4stack.pre4 = VIA2_4stack.pre3 INTERACT (VIA2_Reg_3_S_4 INTERACT VIA2_Reg_3_S_4_1)
  VIA2ArrayS1_S_4 = EXT VIA2_4stack.pre4 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90    // Space of different "smae array" smaller than VIA_S_2
  VIA2ArrayS2_S_4 = ((((VIA2ArrayS1_S_4 NOT INSIDE M2) NOT INSIDE M3) NOT INSIDE M4) NOT INSIDE M5) NOT INSIDE M6
  VIA2_4stack.pre5 = VIA2_4stack.pre4 INTERACT VIA2ArrayS2_S_4

  M2_4stack.pre4 = EXT M2_4stack.pre3 <= VIA_S_2 ABUT < 90 OPPOSITE SINGULAR REGION
  M2_4stack.pre4_edge = M2_4stack.pre3 COIN OUTSIDE EDGE M2_4stack.pre4
  M2_4stack.pre5 = EXPAND EDGE M2_4stack.pre4_edge INSIDE BY VIA_S_4
  M2_4stack.pre5_region_1 = M2_4stack.pre5 INTERACT VIA2_4stack.pre5
  M2_4stack.pre5_region = M2_4stack.pre4 INTERACT M2_4stack.pre5_region_1 >= 2
  M2_4stack.pre6 = M2_4stack.pre5_region OR M2_4stack.pre5_region_1
  M2_4stack.pre7 = M2_4stack.pre6 INTERACT VIA2_4stack.pre5 >= 2
  VIA2_4stack.Final = VIA2_4stack.pre5 INTERACT M2_4stack.pre7

  VIA2_S_4_A2 = VIA2 INTERACT VIA2_4stack.Final 
  VIA2_Reg_4_S_4_A2 = EXT VIA2_S_4_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_4_A2= VIA2_S_4_A2 INTERACT VIA2_Reg_4_S_4_A2                 
  VIA3_S_4_A2 = VIA3 INTERACT VIA2_4stack.Final 
  VIA3_Reg_4_S_4_A2 = EXT VIA3_S_4_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_4_A2 = VIA3_S_4_A2 INTERACT VIA3_Reg_4_S_4_A2  
  VIA4_S_4_A2 = VIA4 INTERACT VIA2_4stack.Final 
  VIA4_Reg_4_S_4_A2 = EXT VIA4_S_4_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_4_A2 = VIA4_S_4_A2 INTERACT VIA4_Reg_4_S_4_A2  
  VIA5_S_4_A2 = VIA5 INTERACT VIA2_4stack.Final 
  VIA5_Reg_4_S_4_A2 = EXT VIA5_S_4_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA5s space smaller than 0.49 (inside small array)  
  VIA5_Violate_S_4_A2 = VIA5_S_4_A2 INTERACT VIA5_Reg_4_S_4_A2  






// Processing for VIAx.S.7 Check    
//**************************************
  M1_4stack_S_7.pre3 = ((((M1 INTERACT VIA1_same_array_4stack_S_7.pre2) OR (M2 INTERACT VIA1_same_array_4stack_S_7.pre2)) OR (M3 INTERACT VIA1_same_array_4stack_S_7.pre2)) OR (M4 INTERACT VIA1_same_array_4stack_S_7.pre2)) OR (M5 INTERACT VIA1_same_array_4stack_S_7.pre2) 
  VIA1_4stack_S_7.pre3 = SIZE VIA1_same_array_4stack_S_7.pre2 BY VIA_S_4 INSIDE OF M1_4stack_S_7.pre3 STEP 0.28
  VIA1_4stack_S_7.pre4 = VIA1_4stack_S_7.pre3 TOUCH EDGE M1_4stack_S_7.pre3
  VIA1_4stack_S_7.pre5 = VIA1_4stack_S_7.pre3 WITH EDGE VIA1_4stack_S_7.pre4 >= 1
  VIA1_4stack_S_7.Final = VIA1_same_array_4stack_S_7.pre2 INTERACT VIA1_4stack_S_7.pre5
  
  VIA1_S_4_B1 = VIA1 INTERACT VIA1_4stack_S_7.Final 
  VIA1_Reg_4_S_4_B1 = EXT VIA1_S_4_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA1s space smaller than 0.49 (inside small array)  
  VIA1_Violate_S_4_B1= VIA1_S_4_B1 INTERACT VIA1_Reg_4_S_4_B1                 
  VIA2_S_4_B1 = VIA2 INTERACT VIA1_4stack_S_7.Final 
  VIA2_Reg_4_S_4_B1 = EXT VIA2_S_4_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_4_B1 = VIA2_S_4_B1 INTERACT VIA2_Reg_4_S_4_B1  
  VIA3_S_4_B1 = VIA3 INTERACT VIA1_4stack_S_7.Final 
  VIA3_Reg_4_S_4_B1 = EXT VIA3_S_4_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_4_B1 = VIA3_S_4_B1 INTERACT VIA3_Reg_4_S_4_B1  
  VIA4_S_4_B1 = VIA4 INTERACT VIA1_4stack_S_7.Final 
  VIA4_Reg_4_S_4_B1 = EXT VIA4_S_4_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_4_B1 = VIA4_S_4_B1 INTERACT VIA4_Reg_4_S_4_B1  


  M2_4stack_S_7.pre3 = ((((M2 INTERACT VIA2_same_array_4stack_S_7.pre2) OR (M3 INTERACT VIA2_same_array_4stack_S_7.pre2)) OR (M4 INTERACT VIA2_same_array_4stack_S_7.pre2)) OR (M5 INTERACT VIA2_same_array_4stack_S_7.pre2)) OR (M6 INTERACT VIA2_same_array_4stack_S_7.pre2) 
  VIA2_4stack_S_7.pre3 = SIZE VIA2_same_array_4stack_S_7.pre2 BY VIA_S_4 INSIDE OF M2_4stack_S_7.pre3 STEP 0.28
  VIA2_4stack_S_7.pre4 = VIA2_4stack_S_7.pre3 TOUCH EDGE M2_4stack_S_7.pre3
  VIA2_4stack_S_7.pre5 = VIA2_4stack_S_7.pre3 WITH EDGE VIA2_4stack_S_7.pre4 >= 1
  VIA2_4stack_S_7.Final = VIA2_same_array_4stack_S_7.pre2 INTERACT VIA2_4stack_S_7.pre5
  
  VIA2_S_4_B2 = VIA2 INTERACT VIA2_4stack_S_7.Final 
  VIA2_Reg_4_S_4_B2 = EXT VIA2_S_4_B2 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_4_B2= VIA2_S_4_B2 INTERACT VIA2_Reg_4_S_4_B2                 
  VIA3_S_4_B2 = VIA3 INTERACT VIA2_4stack_S_7.Final 
  VIA3_Reg_4_S_4_B2 = EXT VIA3_S_4_B2 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_4_B2 = VIA3_S_4_B2 INTERACT VIA3_Reg_4_S_4_B2  
  VIA4_S_4_B2 = VIA4 INTERACT VIA2_4stack_S_7.Final 
  VIA4_Reg_4_S_4_B2 = EXT VIA4_S_4_B2 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_4_B2 = VIA4_S_4_B2 INTERACT VIA4_Reg_4_S_4_B2  
  VIA5_S_4_B2 = VIA5 INTERACT VIA2_4stack_S_7.Final 
  VIA5_Reg_4_S_4_B2 = EXT VIA5_S_4_B2 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA5s space smaller than 0.49 (inside small array)  
  VIA5_Violate_S_4_B2 = VIA5_S_4_B2 INTERACT VIA5_Reg_4_S_4_B2  



// Processing for Mx.S.4 Check    
//**************************************
  VIA1_4stack_Mx_S4.pre3 = ENCLOSE RECTANGLE VIA1_same_array_4stack_Mx_S4.pre2 VIA_W_1 VIA_W_1  // Find at least one width >= VIA_W_1

  M1_S_4_C1 = ENC VIA1_4stack_Mx_S4.pre3 [M1] <= VIA_S_4 ABUT < 90 SINGULAR 
  M1_Reg_4_S_4_C1 = EXT M1_S_4_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M1s space smaller than 1.2   
  M2_S_4_C1 = ENC VIA1_4stack_Mx_S4.pre3 [M2] <= VIA_S_4 ABUT < 90 SINGULAR 
  M2_Reg_4_S_4_C1 = EXT M2_S_4_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M2s space smaller than 1.2   
  M3_S_4_C1 = ENC VIA1_4stack_Mx_S4.pre3 [M3] <= VIA_S_4 ABUT < 90 SINGULAR 
  M3_Reg_4_S_4_C1 = EXT M3_S_4_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M3s space smaller than 1.2   
  M4_S_4_C1 = ENC VIA1_4stack_Mx_S4.pre3 [M4] <= VIA_S_4 ABUT < 90 SINGULAR 
  M4_Reg_4_S_4_C1 = EXT M4_S_4_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M4s space smaller than 1.2   


  VIA2_4stack_Mx_S4.pre3 = ENCLOSE RECTANGLE VIA2_same_array_4stack_Mx_S4.pre2 VIA_W_1 VIA_W_1  // Find at least one width >= VIA_W_1

  M2_S_4_C2 = ENC VIA2_4stack_Mx_S4.pre3 [M2] <= VIA_S_4 ABUT < 90 SINGULAR 
  M2_Reg_4_S_4_C2 = EXT M2_S_4_C2 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M2s space smaller than 1.2   
  M3_S_4_C2 = ENC VIA2_4stack_Mx_S4.pre3 [M3] <= VIA_S_4 ABUT < 90 SINGULAR 
  M3_Reg_4_S_4_C2 = EXT M3_S_4_C2 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M3s space smaller than 1.2   
  M4_S_4_C2 = ENC VIA2_4stack_Mx_S4.pre3 [M4] <= VIA_S_4 ABUT < 90 SINGULAR 
  M4_Reg_4_S_4_C2 = EXT M4_S_4_C2 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M4s space smaller than 1.2   
  M5_S_4_C2 = ENC VIA2_4stack_Mx_S4.pre3 [M5] <= VIA_S_4 ABUT < 90 SINGULAR 
  M5_Reg_4_S_4_C2 = EXT M5_S_4_C2 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M5s space smaller than 1.2   




// Rule Check    
//**************************************
  CONNECT VIA1_4stack.Final VIA1_Violate_S_4_A1
  CONNECT VIA1_4stack.Final VIA2_Violate_S_4_A1
  CONNECT VIA1_4stack.Final VIA3_Violate_S_4_A1
  CONNECT VIA1_4stack.Final VIA4_Violate_S_4_A1
  CONNECT VIA2_4stack.Final VIA2_Violate_S_4_A2
  CONNECT VIA2_4stack.Final VIA3_Violate_S_4_A2
  CONNECT VIA2_4stack.Final VIA4_Violate_S_4_A2
  CONNECT VIA2_4stack.Final VIA5_Violate_S_4_A2

VIA1.S.3_Array1_2_3_4_M { @ Minimum space between two VIAs in 4-level continuous stacking VIA arrays with below condition >=0.49um
                               @ Via1 violate ^VIA_S_3 spacing in Via1/Via2/Via3/Via4 array & density large or equal ^VIA_D_1 
  A1 = NET AREA RATIO VIA1_Violate_S_4_A1 VIA1_4stack.Final >= VIA_D_1
  A2 = NET AREA RATIO VIA2_Violate_S_4_A1 VIA1_4stack.Final >= VIA_D_1
  A3 = NET AREA RATIO VIA3_Violate_S_4_A1 VIA1_4stack.Final >= VIA_D_1
  A4 = NET AREA RATIO VIA4_Violate_S_4_A1 VIA1_4stack.Final >= VIA_D_1
  B1 = ((A1 OR A2) OR A3) OR A4
  SIZE B1 BY VIA_Merge OVERUNDER 
}




VIA1.S.7_Array1_2_3_4_M { @ Minimum space between two VIA1 region >= ^VIA_S_3 um if the overlap area of 4-level 
						  	   @ continuous stacking VIA arrays >= ^VIA_A_4_B um2 (except sealring region)
  (VIA1_4stack_S_7.Final INTERACT VIA1_Violate_S_4_B1) NOT INTERACT SEALRING_ALL
}

VIA2.S.7_Array1_2_3_4_M { @ Minimum space between two VIA2 region >= ^VIA_S_3 um if the overlap area of 4-level
						  		@ continuous stacking VIA arrays >= ^VIA_A_4_B um2 (except sealring region)
  (VIA1_4stack_S_7.Final INTERACT VIA2_Violate_S_4_B1) NOT INTERACT SEALRING_ALL
}

VIA3.S.7_Array1_2_3_4_M { @ Minimum space between two VIA3 region >= ^VIA_S_3 um if the overlap area of 4-level
						  		 @ continuous stacking VIA arrays >= ^VIA_A_4_B um2 (except sealring region)
  (VIA1_4stack_S_7.Final INTERACT VIA3_Violate_S_4_B1) NOT INTERACT SEALRING_ALL
}

VIA4.S.7_Array1_2_3_4_M { @ Minimum space between two VIA4 region >= ^VIA_S_3 um if the overlap area of 4-level
						  		 @ continuous stacking VIA arrays >= ^VIA_A_4_B um2 (except sealring region)
  (VIA1_4stack_S_7.Final INTERACT VIA4_Violate_S_4_B1) NOT INTERACT SEALRING_ALL
}

M1_2_3_4.S.4 { @ Minimum space between two Mx region with below conditions >= ^Mx_S_3_7 um 
			  @ (a1) both of the Mx with the overlap area of 4-level continuous VIA array area >= ^VIA_A_4_B um2
			  @ (a2) Width of 4-level continuous stacking VIA arrays >= ^VIA_W_1 um
  ((M1_Reg_4_S_4_C1 OR M2_Reg_4_S_4_C1) OR M3_Reg_4_S_4_C1) OR M4_Reg_4_S_4_C1
}


VIA2.S.3_Array2_3_4_5_M { @ Minimum space between two VIAs in 4-level continuous stacking VIA arrays with below condition >=0.49um
                               @ Via2 violate ^VIA_S_3 spacing in Via2/Via3/Via4/Via5 array & density large or equal ^VIA_D_1 
  A2 = NET AREA RATIO VIA2_Violate_S_4_A2 VIA2_4stack.Final >= VIA_D_1
  A3 = NET AREA RATIO VIA3_Violate_S_4_A2 VIA2_4stack.Final >= VIA_D_1
  A4 = NET AREA RATIO VIA4_Violate_S_4_A2 VIA2_4stack.Final >= VIA_D_1
  A5 = NET AREA RATIO VIA5_Violate_S_4_A2 VIA2_4stack.Final >= VIA_D_1
  B2 = ((A2 OR A3) OR A4) OR A5
  SIZE B2 BY VIA_Merge OVERUNDER 
}




VIA2.S.7_Array2_3_4_5_M { @ Minimum space between two VIA2 region >= ^VIA_S_3 um if the overlap area of 4-level
						       @ continuous stacking VIA arrays >= ^VIA_A_4_B um2 (except sealring region)
  (VIA2_4stack_S_7.Final INTERACT VIA2_Violate_S_4_B2) NOT INTERACT SEALRING_ALL
}

VIA3.S.7_Array2_3_4_5_M { @ Minimum space between two VIA3 region >= ^VIA_S_3 um if the overlap area of 4-level
						  		@ continuous stacking VIA arrays >= ^VIA_A_4_B um2 (except sealring region)
  (VIA2_4stack_S_7.Final INTERACT VIA3_Violate_S_4_B2) NOT INTERACT SEALRING_ALL
}

VIA4.S.7_Array2_3_4_5_M { @ Minimum space between two VIA4 region >= ^VIA_S_3 um if the overlap area of 4-level
						  		 @ continuous stacking VIA arrays >= ^VIA_A_4_B um2 (except sealring region)
  (VIA2_4stack_S_7.Final INTERACT VIA4_Violate_S_4_B2) NOT INTERACT SEALRING_ALL
}

VIA5.S.7_Array2_3_4_5_M { @ Minimum space between two VIA5 region >= ^VIA_S_3 um if the overlap area of 4-level
						  		 @ continuous stacking VIA arrays >= ^VIA_A_4_B um2 (except sealring region)
  (VIA2_4stack_S_7.Final INTERACT VIA5_Violate_S_4_B2) NOT INTERACT SEALRING_ALL
}

M2_3_4_5.S.4 { @ Minimum space between two Mx region with below conditions >= ^Mx_S_3_7 um 
			  @ (a1) both of the Mx with the overlap area of 4-level continuous VIA array area >= ^VIA_A_4_B um2
			  @ (a2) Width of 4-level continuous stacking VIA arrays >= ^VIA_W_1 um
  ((M2_Reg_4_S_4_C2 OR M3_Reg_4_S_4_C2) OR M4_Reg_4_S_4_C2) OR M5_Reg_4_S_4_C2
}




//**********************  
// Small 3 stack array
//**********************
// Processing for SAME Array Size Check    
//**************************************
  VIA1_3stack.pre3 = ENCLOSE RECTANGLE VIA1_same_array_3stack.pre2 VIA_S_2L VIA_W_1    // Find at least one width >=VIA_W_1
  M1_3stack.pre3 = (((M1 INTERACT VIA1_3stack.pre3) OR (M2 INTERACT VIA1_3stack.pre3)) OR (M3 INTERACT VIA1_3stack.pre3)) OR (M4 INTERACT VIA1_3stack.pre3)
  VIA1_Reg_3_S_3 = EXT VIA1_3stack.pre3 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90
  VIA1_Reg_3_S_3_pre = VIA1_Reg_3_S_3 NOT M1_3stack.pre3
  VIA1_Reg_3_S_3_1 = ENCLOSE RECTANGLE VIA1_Reg_3_S_3_pre 0.005 VIA_S_2L  // Find parallel run length >= VIA_S_2L
  VIA1_3stack.pre4 = VIA1_3stack.pre3 INTERACT (VIA1_Reg_3_S_3 INTERACT VIA1_Reg_3_S_3_1) // Find parallel run length >= VIA_S_2L
  VIA1ArrayS1_S_3 = EXT VIA1_3stack.pre4 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than VIA_S_2
  VIA1ArrayS2_S_3 = (((VIA1ArrayS1_S_3 NOT INSIDE M1) NOT INSIDE M2) NOT INSIDE M3 ) NOT INSIDE M4
  VIA1_3stack.pre5 = VIA1_3stack.pre4 INTERACT VIA1ArrayS2_S_3

  M1_3stack.pre4 = EXT M1_3stack.pre3 <= VIA_S_2 ABUT < 90 OPPOSITE SINGULAR REGION
  M1_3stack.pre4_edge = M1_3stack.pre3 COIN OUTSIDE EDGE M1_3stack.pre4
  M1_3stack.pre5 = EXPAND EDGE M1_3stack.pre4_edge INSIDE BY VIA_S_4
  M1_3stack.pre5_region_1 = M1_3stack.pre5 INTERACT VIA1_3stack.pre5
  M1_3stack.pre5_region = M1_3stack.pre4 INTERACT M1_3stack.pre5_region_1 >= 2
  M1_3stack.pre6 = M1_3stack.pre5_region OR M1_3stack.pre5_region_1
  M1_3stack.pre7 = M1_3stack.pre6 INTERACT VIA1_3stack.pre5 >= 2
  VIA1_3stack.Final = VIA1_3stack.pre5 INTERACT M1_3stack.pre7

  VIA1_S_3_A1 = VIA1 INTERACT VIA1_3stack.Final 
  VIA1_Reg_4_S_3_A1 = EXT VIA1_S_3_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA1s space smaller than 0.49 (inside small array)  
  VIA1_Violate_S_3_A1= VIA1_S_3_A1 INTERACT VIA1_Reg_4_S_3_A1                 
  VIA2_S_3_A1 = VIA2 INTERACT VIA1_3stack.Final 
  VIA2_Reg_4_S_3_A1 = EXT VIA2_S_3_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_3_A1 = VIA2_S_3_A1 INTERACT VIA2_Reg_4_S_3_A1  
  VIA3_S_3_A1 = VIA3 INTERACT VIA1_3stack.Final 
  VIA3_Reg_4_S_3_A1 = EXT VIA3_S_3_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_3_A1 = VIA3_S_3_A1 INTERACT VIA3_Reg_4_S_3_A1  

  
  VIA2_3stack.pre3 = ENCLOSE RECTANGLE VIA2_same_array_3stack.pre2 VIA_S_2L VIA_W_1    // Find at least one width >=VIA_W_1
  M2_3stack.pre3 = (((M2 INTERACT VIA2_3stack.pre3) OR (M3 INTERACT VIA2_3stack.pre3)) OR (M4 INTERACT VIA2_3stack.pre3)) OR (M5 INTERACT VIA2_3stack.pre3)
  VIA2_Reg_3_S_3 = EXT VIA2_3stack.pre3 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90
  VIA2_Reg_3_S_3_pre = VIA2_Reg_3_S_3 NOT M2_3stack.pre3
  VIA2_Reg_3_S_3_1 = ENCLOSE RECTANGLE VIA2_Reg_3_S_3_pre 0.005 VIA_S_2L  // Find parallel run length >= VIA_S_2L
  VIA2_3stack.pre4 = VIA2_3stack.pre3 INTERACT (VIA2_Reg_3_S_3 INTERACT VIA2_Reg_3_S_3_1) // Find parallel run length >= VIA_S_2L
  VIA2ArrayS1_S_3 = EXT VIA2_3stack.pre4 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than VIA_S_2
  VIA2ArrayS2_S_3 = (((VIA2ArrayS1_S_3 NOT INSIDE M2) NOT INSIDE M3) NOT INSIDE M4 ) NOT INSIDE M5
  VIA2_3stack.pre5 = VIA2_3stack.pre4 INTERACT VIA2ArrayS2_S_3

  M2_3stack.pre4 = EXT M2_3stack.pre3 <= VIA_S_2 ABUT < 90 OPPOSITE SINGULAR REGION
  M2_3stack.pre4_edge = M2_3stack.pre3 COIN OUTSIDE EDGE M2_3stack.pre4
  M2_3stack.pre5 = EXPAND EDGE M2_3stack.pre4_edge INSIDE BY VIA_S_4
  M2_3stack.pre5_region_1 = M2_3stack.pre5 INTERACT VIA2_3stack.pre5
  M2_3stack.pre5_region = M2_3stack.pre4 INTERACT M2_3stack.pre5_region_1 >= 2
  M2_3stack.pre6 = M2_3stack.pre5_region OR M2_3stack.pre5_region_1
  M2_3stack.pre7 = M2_3stack.pre6 INTERACT VIA2_3stack.pre5 >= 2
  VIA2_3stack.Final = VIA2_3stack.pre5 INTERACT M2_3stack.pre7

  VIA2_S_3_A2 = VIA2 INTERACT VIA2_3stack.Final 
  VIA2_Reg_4_S_3_A2 = EXT VIA2_S_3_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_3_A2= VIA2_S_3_A2 INTERACT VIA2_Reg_4_S_3_A2                 
  VIA3_S_3_A2 = VIA3 INTERACT VIA2_3stack.Final 
  VIA3_Reg_4_S_3_A2 = EXT VIA3_S_3_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_3_A2 = VIA3_S_3_A2 INTERACT VIA3_Reg_4_S_3_A2  
  VIA4_S_3_A2 = VIA4 INTERACT VIA2_3stack.Final 
  VIA4_Reg_4_S_3_A2 = EXT VIA4_S_3_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_3_A2 = VIA4_S_3_A2 INTERACT VIA4_Reg_4_S_3_A2  

  
  VIA3_3stack.pre3 = ENCLOSE RECTANGLE VIA3_same_array_3stack.pre2 VIA_S_2L VIA_W_1    // Find at least one width >=VIA_W_1
  M3_3stack.pre3 = (((M3 INTERACT VIA3_3stack.pre3) OR (M4 INTERACT VIA3_3stack.pre3)) OR (M5 INTERACT VIA3_3stack.pre3)) OR (M6 INTERACT VIA3_3stack.pre3)
  VIA3_Reg_3_S_3 = EXT VIA3_3stack.pre3 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90
  VIA3_Reg_3_S_3_pre = VIA3_Reg_3_S_3 NOT M3_3stack.pre3
  VIA3_Reg_3_S_3_1 = ENCLOSE RECTANGLE VIA3_Reg_3_S_3_pre 0.005 VIA_S_2L  // Find parallel run length >= VIA_S_2L
  VIA3_3stack.pre4 = VIA3_3stack.pre3 INTERACT (VIA3_Reg_3_S_3 INTERACT VIA3_Reg_3_S_3_1) // Find parallel run length >= VIA_S_2L
  VIA3ArrayS1_S_3 = EXT VIA3_3stack.pre4 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than VIA_S_2
  VIA3ArrayS2_S_3 = (((VIA3ArrayS1_S_3 NOT INSIDE M3) NOT INSIDE M4) NOT INSIDE M5 ) NOT INSIDE M6
  VIA3_3stack.pre5 = VIA3_3stack.pre4 INTERACT VIA3ArrayS2_S_3

  M3_3stack.pre4 = EXT M3_3stack.pre3 <= VIA_S_2 ABUT < 90 OPPOSITE SINGULAR REGION
  M3_3stack.pre4_edge = M3_3stack.pre3 COIN OUTSIDE EDGE M3_3stack.pre4
  M3_3stack.pre5 = EXPAND EDGE M3_3stack.pre4_edge INSIDE BY VIA_S_4
  M3_3stack.pre5_region_1 = M3_3stack.pre5 INTERACT VIA3_3stack.pre5
  M3_3stack.pre5_region = M3_3stack.pre4 INTERACT M3_3stack.pre5_region_1 >= 2
  M3_3stack.pre6 = M3_3stack.pre5_region OR M3_3stack.pre5_region_1
  M3_3stack.pre7 = M3_3stack.pre6 INTERACT VIA3_3stack.pre5 >= 2
  VIA3_3stack.Final = VIA3_3stack.pre5 INTERACT M3_3stack.pre7

  VIA3_S_3_A3 = VIA3 INTERACT VIA3_3stack.Final 
  VIA3_Reg_4_S_3_A3 = EXT VIA3_S_3_A3 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_3_A3= VIA3_S_3_A3 INTERACT VIA3_Reg_4_S_3_A3                 
  VIA4_S_3_A3 = VIA4 INTERACT VIA3_3stack.Final 
  VIA4_Reg_4_S_3_A3 = EXT VIA4_S_3_A3 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_3_A3 = VIA4_S_3_A3 INTERACT VIA4_Reg_4_S_3_A3  
  VIA5_S_3_A3 = VIA5 INTERACT VIA3_3stack.Final 
  VIA5_Reg_4_S_3_A3 = EXT VIA5_S_3_A3 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA5s space smaller than 0.49 (inside small array)  
  VIA5_Violate_S_3_A3 = VIA5_S_3_A3 INTERACT VIA5_Reg_4_S_3_A3  

  




// Processing for VIAx.S.8 Check    
//**************************************
  M1_3stack_S_8.pre3 = (((M1 INTERACT VIA1_same_array_3stack_S_8.pre2) OR (M2 INTERACT VIA1_same_array_3stack_S_8.pre2)) OR (M3 INTERACT VIA1_same_array_3stack_S_8.pre2)) OR (M4 INTERACT VIA1_same_array_3stack_S_8.pre2) 
  VIA1_3stack_S_8.pre3 = SIZE VIA1_same_array_3stack_S_8.pre2 BY VIA_S_4 INSIDE OF M1_3stack_S_8.pre3 STEP 0.28
  VIA1_3stack_S_8.pre4 = VIA1_3stack_S_8.pre3 TOUCH EDGE M1_3stack_S_8.pre3
  VIA1_3stack_S_8.pre5 = VIA1_3stack_S_8.pre3 WITH EDGE VIA1_3stack_S_8.pre4 >= 1
  VIA1_3stack_S_8.Final = VIA1_same_array_3stack_S_8.pre2 INTERACT VIA1_3stack_S_8.pre5


  VIA1_S_3_B1 = VIA1 INTERACT VIA1_3stack_S_8.Final 
  VIA1_Reg_4_S_3_B1 = EXT VIA1_S_3_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA1s space smaller than 0.49 (inside small array)  
  VIA1_Violate_S_3_B1= VIA1_S_3_B1 INTERACT VIA1_Reg_4_S_3_B1                 
  VIA2_S_3_B1 = VIA2 INTERACT VIA1_3stack_S_8.Final 
  VIA2_Reg_4_S_3_B1 = EXT VIA2_S_3_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_3_B1 = VIA2_S_3_B1 INTERACT VIA2_Reg_4_S_3_B1  
  VIA3_S_3_B1 = VIA3 INTERACT VIA1_3stack_S_8.Final 
  VIA3_Reg_4_S_3_B1 = EXT VIA3_S_3_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_3_B1 = VIA3_S_3_B1 INTERACT VIA3_Reg_4_S_3_B1  


  M2_3stack_S_8.pre3 = (((M2 INTERACT VIA2_same_array_3stack_S_8.pre2) OR (M3 INTERACT VIA2_same_array_3stack_S_8.pre2)) OR (M4 INTERACT VIA2_same_array_3stack_S_8.pre2)) OR (M5 INTERACT VIA2_same_array_3stack_S_8.pre2) 
  VIA2_3stack_S_8.pre3 = SIZE VIA2_same_array_3stack_S_8.pre2 BY VIA_S_4 INSIDE OF M2_3stack_S_8.pre3 STEP 0.28
  VIA2_3stack_S_8.pre4 = VIA2_3stack_S_8.pre3 TOUCH EDGE M2_3stack_S_8.pre3
  VIA2_3stack_S_8.pre5 = VIA2_3stack_S_8.pre3 WITH EDGE VIA2_3stack_S_8.pre4 >= 1
  VIA2_3stack_S_8.Final = VIA2_same_array_3stack_S_8.pre2 INTERACT VIA2_3stack_S_8.pre5


  VIA2_S_3_B2 = VIA2 INTERACT VIA2_3stack_S_8.Final 
  VIA2_Reg_4_S_3_B2 = EXT VIA2_S_3_B2 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_3_B2= VIA2_S_3_B2 INTERACT VIA2_Reg_4_S_3_B2                 
  VIA3_S_3_B2 = VIA3 INTERACT VIA2_3stack_S_8.Final 
  VIA3_Reg_4_S_3_B2 = EXT VIA3_S_3_B2 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_3_B2 = VIA3_S_3_B2 INTERACT VIA3_Reg_4_S_3_B2  
  VIA4_S_3_B2 = VIA4 INTERACT VIA2_3stack_S_8.Final 
  VIA4_Reg_4_S_3_B2 = EXT VIA4_S_3_B2 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_3_B2 = VIA4_S_3_B2 INTERACT VIA4_Reg_4_S_3_B2  


  M3_3stack_S_8.pre3 = (((M3 INTERACT VIA3_same_array_3stack_S_8.pre2) OR (M4 INTERACT VIA3_same_array_3stack_S_8.pre2)) OR (M5 INTERACT VIA3_same_array_3stack_S_8.pre2)) OR (M6 INTERACT VIA3_same_array_3stack_S_8.pre2) 
  VIA3_3stack_S_8.pre3 = SIZE VIA3_same_array_3stack_S_8.pre2 BY VIA_S_4 INSIDE OF M3_3stack_S_8.pre3 STEP 0.28
  VIA3_3stack_S_8.pre4 = VIA3_3stack_S_8.pre3 TOUCH EDGE M3_3stack_S_8.pre3
  VIA3_3stack_S_8.pre5 = VIA3_3stack_S_8.pre3 WITH EDGE VIA3_3stack_S_8.pre4 >= 1
  VIA3_3stack_S_8.Final = VIA3_same_array_3stack_S_8.pre2 INTERACT VIA3_3stack_S_8.pre5


  VIA3_S_3_B3 = VIA3 INTERACT VIA3_3stack_S_8.Final 
  VIA3_Reg_4_S_3_B3 = EXT VIA3_S_3_B3 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_3_B3= VIA3_S_3_B3 INTERACT VIA3_Reg_4_S_3_B3                 
  VIA4_S_3_B3 = VIA4 INTERACT VIA3_3stack_S_8.Final 
  VIA4_Reg_4_S_3_B3 = EXT VIA4_S_3_B3 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_3_B3 = VIA4_S_3_B3 INTERACT VIA4_Reg_4_S_3_B3  
  VIA5_S_3_B3 = VIA5 INTERACT VIA3_3stack_S_8.Final 
  VIA5_Reg_4_S_3_B3 = EXT VIA5_S_3_B3 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA5s space smaller than 0.49 (inside small array)  
  VIA5_Violate_S_3_B3 = VIA5_S_3_B3 INTERACT VIA5_Reg_4_S_3_B3  



// Processing for Mx.S.5 Check    
//**************************************
  VIA1_3stack_Mx_S5.pre3 = ENCLOSE RECTANGLE VIA1_same_array_3stack_Mx_S5.pre2 VIA_W_1 VIA_W_1  // Find at least one width >= VIA_W_1

  M1_S_3_C1 = ENC VIA1_3stack_Mx_S5.pre3 [M1] <= VIA_S_4 ABUT < 90 SINGULAR 
  M1_Reg_4_S_3_C1 = EXT M1_S_3_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M1s space smaller than 1.2   
  M2_S_3_C1 = ENC VIA1_3stack_Mx_S5.pre3 [M2] <= VIA_S_4 ABUT < 90 SINGULAR 
  M2_Reg_4_S_3_C1 = EXT M2_S_3_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M2s space smaller than 1.2   
  M3_S_3_C1 = ENC VIA1_3stack_Mx_S5.pre3 [M3] <= VIA_S_4 ABUT < 90 SINGULAR 
  M3_Reg_4_S_3_C1 = EXT M3_S_3_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M3s space smaller than 1.2   


  VIA2_3stack_Mx_S5.pre3 = ENCLOSE RECTANGLE VIA2_same_array_3stack_Mx_S5.pre2 VIA_W_1 VIA_W_1  // Find at least one width >= VIA_W_1

  M2_S_3_C2 = ENC VIA2_3stack_Mx_S5.pre3 [M2] <= VIA_S_4 ABUT < 90 SINGULAR 
  M2_Reg_4_S_3_C2 = EXT M2_S_3_C2 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M2s space smaller than 1.2   
  M3_S_3_C2 = ENC VIA2_3stack_Mx_S5.pre3 [M3] <= VIA_S_4 ABUT < 90 SINGULAR 
  M3_Reg_4_S_3_C2 = EXT M3_S_3_C2 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M3s space smaller than 1.2   
  M4_S_3_C2 = ENC VIA2_3stack_Mx_S5.pre3 [M4] <= VIA_S_4 ABUT < 90 SINGULAR 
  M4_Reg_4_S_3_C2 = EXT M4_S_3_C2 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M4s space smaller than 1.2   


  VIA3_3stack_Mx_S5.pre3 = ENCLOSE RECTANGLE VIA3_same_array_3stack_Mx_S5.pre2 VIA_W_1 VIA_W_1  // Find at least one width >= VIA_W_1

  M3_S_3_C3 = ENC VIA3_3stack_Mx_S5.pre3 [M3] <= VIA_S_4 ABUT < 90 SINGULAR 
  M3_Reg_4_S_3_C3 = EXT M3_S_3_C3 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M3s space smaller than 1.2   
  M4_S_3_C3 = ENC VIA3_3stack_Mx_S5.pre3 [M4] <= VIA_S_4 ABUT < 90 SINGULAR 
  M4_Reg_4_S_3_C3 = EXT M4_S_3_C3 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M4s space smaller than 1.2   
  M5_S_3_C3 = ENC VIA3_3stack_Mx_S5.pre3 [M5] <= VIA_S_4 ABUT < 90 SINGULAR 
  M5_Reg_4_S_3_C3 = EXT M5_S_3_C3 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M5s space smaller than 1.2   




// Rule Check    
//**************************************
  CONNECT VIA1_3stack.Final VIA1_Violate_S_3_A1
  CONNECT VIA1_3stack.Final VIA2_Violate_S_3_A1
  CONNECT VIA1_3stack.Final VIA3_Violate_S_3_A1
  CONNECT VIA2_3stack.Final VIA2_Violate_S_3_A2
  CONNECT VIA2_3stack.Final VIA3_Violate_S_3_A2
  CONNECT VIA2_3stack.Final VIA4_Violate_S_3_A2
  CONNECT VIA3_3stack.Final VIA3_Violate_S_3_A3
  CONNECT VIA3_3stack.Final VIA4_Violate_S_3_A3
  CONNECT VIA3_3stack.Final VIA5_Violate_S_3_A3

VIA1.S.4_Array1_2_3_M { @ Minimum space between two VIAs in 3-level continuous stacking VIA arrays with below condition >=0.49um
                           @ Via1 violate ^VIA_S_3 spacing in Via1/Via2/Via3 array & density large or equal ^VIA_D_1 
  A1 = NET AREA RATIO VIA1_Violate_S_3_A1 VIA1_3stack.Final >= VIA_D_1
  A2 = NET AREA RATIO VIA2_Violate_S_3_A1 VIA1_3stack.Final >= VIA_D_1
  A3 = NET AREA RATIO VIA3_Violate_S_3_A1 VIA1_3stack.Final >= VIA_D_1
  B1 = (A1 OR A2) OR A3
  SIZE B1 BY VIA_Merge OVERUNDER 
}




M1_2_3.S.5 { @ Minimum space between two Mx region with below conditions >= ^Mx_S_3_7 um 
			  @ (a1) both of the Mx with the overlap area of 3-level continuous VIA array area >= ^VIA_A_3_B um2
			  @ (a2) Width of 3-level continuous stacking VIA arrays >= ^VIA_W_1 um
  (M1_Reg_4_S_3_C1 OR M2_Reg_4_S_3_C1) OR M3_Reg_4_S_3_C1 
}

VIA2.S.4_Array2_3_4_M { @ Minimum space between two VIAs in 3-level continuous stacking VIA arrays with below condition >=0.49um
                           @ Via2 violate ^VIA_S_3 spacing in Via2/Via3/Via4 array & density large or equal ^VIA_D_1 
  A2 = NET AREA RATIO VIA2_Violate_S_3_A2 VIA2_3stack.Final >= VIA_D_1
  A3 = NET AREA RATIO VIA3_Violate_S_3_A2 VIA2_3stack.Final >= VIA_D_1
  A4 = NET AREA RATIO VIA4_Violate_S_3_A2 VIA2_3stack.Final >= VIA_D_1
  B2 = (A2 OR A3) OR A4
  SIZE B2 BY VIA_Merge OVERUNDER 
}




M2_3_4.S.5 { @ Minimum space between two Mx region with below conditions >= ^Mx_S_3_7 um 
			  @ (a1) both of the Mx with the overlap area of 3-level continuous VIA array area >= ^VIA_A_3_B um2
			  @ (a2) Width of 3-level continuous stacking VIA arrays >= ^VIA_W_1 um
  (M2_Reg_4_S_3_C2 OR M3_Reg_4_S_3_C2) OR M4_Reg_4_S_3_C2 
}




VIA2.S.8_Array2_3_4_M { @ Minimum space between two VIA2 region >= ^VIA_S_3 um if the overlap area of 3-level
						   @ continuous stacking VIA arrays >= ^VIA_A_3_B um2 (except sealring region)
  (VIA2_3stack_S_8.Final INTERACT VIA2_Violate_S_3_B2) NOT INTERACT SEALRING_ALL
}

VIA3.S.8_Array2_3_4_M { @ Minimum space between two VIA3 region >= ^VIA_S_3 um if the overlap area of 3-level
							@ continuous stacking VIA arrays >= ^VIA_A_3_B um2 (except sealring region)
  (VIA2_3stack_S_8.Final INTERACT VIA3_Violate_S_3_B2) NOT INTERACT SEALRING_ALL
}

VIA4.S.8_Array2_3_4_M { @ Minimum space between two VIA4 region >= ^VIA_S_3 um if the overlap area of 3-level
							 @ continuous stacking VIA arrays >= ^VIA_A_3_B um2 (except sealring region)
  (VIA2_3stack_S_8.Final INTERACT VIA4_Violate_S_3_B2) NOT INTERACT SEALRING_ALL
}


VIA3.S.4_Array3_4_5_M { @ Minimum space between two VIAs in 3-level continuous stacking VIA arrays with below condition >=0.49um
                           @ Via3 violate ^VIA_S_3 spacing in Via3/Via4/Via5 array & density large or equal ^VIA_D_1 
  A3 = NET AREA RATIO VIA3_Violate_S_3_A3 VIA3_3stack.Final >= VIA_D_1
  A4 = NET AREA RATIO VIA4_Violate_S_3_A3 VIA3_3stack.Final >= VIA_D_1
  A5 = NET AREA RATIO VIA5_Violate_S_3_A3 VIA3_3stack.Final >= VIA_D_1
  B3 = (A3 OR A4) OR A5
  SIZE B3 BY VIA_Merge OVERUNDER 
}




VIA3.S.8_Array3_4_5_M { @ Minimum space between two VIA3 region >= ^VIA_S_3 um if the overlap area of 3-level
						   @ continuous stacking VIA arrays >= ^VIA_A_3_B um2 (except sealring region)
  (VIA3_3stack_S_8.Final INTERACT VIA3_Violate_S_3_B3) NOT INTERACT SEALRING_ALL
}

VIA4.S.8_Array3_4_5_M { @ Minimum space between two VIA4 region >= ^VIA_S_3 um if the overlap area of 3-level
							@ continuous stacking VIA arrays >= ^VIA_A_3_B um2 (except sealring region)
  (VIA3_3stack_S_8.Final INTERACT VIA4_Violate_S_3_B3) NOT INTERACT SEALRING_ALL
}

VIA5.S.8_Array3_4_5_M { @ Minimum space between two VIA5 region >= ^VIA_S_3 um if the overlap area of 3-level
							 @ continuous stacking VIA arrays >= ^VIA_A_3_B um2 (except sealring region)
  (VIA3_3stack_S_8.Final INTERACT VIA5_Violate_S_3_B3) NOT INTERACT SEALRING_ALL
}
M3_4_5.S.5 { @ Minimum space between two Mx region with below conditions >= ^Mx_S_3_7 um 
			  @ (a1) both of the Mx with the overlap area of 3-level continuous VIA array area >= ^VIA_A_3_B um2
			  @ (a2) Width of 3-level continuous stacking VIA arrays >= ^VIA_W_1 um
  (M3_Reg_4_S_3_C3 OR M4_Reg_4_S_3_C3) OR M5_Reg_4_S_3_C3 
}




//**********************  
// Small 2 stack array
//**********************
// Processing for SAME Array Size Check    
//**************************************
  VIA1_2stack.pre3 = ENCLOSE RECTANGLE VIA1_same_array_2stack.pre2 VIA_S_2L VIA_W_1 // Find at least one width >= VIA_W_1
  M1_2stack.pre3 = ((M1 INTERACT VIA1_2stack.pre3) OR (M2 INTERACT VIA1_2stack.pre3)) OR (M3 INTERACT VIA1_2stack.pre3)  
  VIA1_Reg_3_S_2 = EXT VIA1_2stack.pre3 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90
  VIA1_Reg_3_S_2_pre = VIA1_Reg_3_S_2 NOT M1_2stack.pre3
  VIA1_Reg_3_S_2_1 = ENCLOSE RECTANGLE VIA1_Reg_3_S_2_pre 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L 
  VIA1_2stack.pre4 = VIA1_2stack.pre3 INTERACT (VIA1_Reg_3_S_2 INTERACT VIA1_Reg_3_S_2_1)  // Find parallel run length >= VIA_S_2L
  VIA1ArrayS1_S_2 = EXT VIA1_2stack.pre4 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than >= VIA_S_2
  VIA1ArrayS2_S_2 = ((VIA1ArrayS1_S_2 NOT INSIDE M1) NOT INSIDE M2 ) NOT INSIDE M3
  VIA1_2stack.pre5 = VIA1_2stack.pre4 INTERACT VIA1ArrayS2_S_2

  M1_2stack.pre4 = EXT M1_2stack.pre3 <= VIA_S_2 ABUT < 90 OPPOSITE SINGULAR REGION
  M1_2stack.pre4_edge = M1_2stack.pre3 COIN OUTSIDE EDGE M1_2stack.pre4
  M1_2stack.pre5 = EXPAND EDGE M1_2stack.pre4_edge INSIDE BY VIA_S_4
  M1_2stack.pre5_region_1 = M1_2stack.pre5 INTERACT VIA1_2stack.pre5
  M1_2stack.pre5_region = M1_2stack.pre4 INTERACT M1_2stack.pre5_region_1 >= 2
  M1_2stack.pre6 = M1_2stack.pre5_region OR M1_2stack.pre5_region_1
  M1_2stack.pre7 = M1_2stack.pre6 INTERACT VIA1_2stack.pre5 >= 2
  VIA1_2stack.Final = VIA1_2stack.pre5 INTERACT M1_2stack.pre7

  VIA1_S_2_A1 = VIA1 INTERACT VIA1_2stack.Final 
  VIA1_Reg_4_S_2_A1 = EXT VIA1_S_2_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA1s space smaller than 0.49 (inside small array)  
  VIA1_Violate_S_2_A1= VIA1_S_2_A1 INTERACT VIA1_Reg_4_S_2_A1                 
  VIA2_S_2_A1 = VIA2 INTERACT VIA1_2stack.Final 
  VIA2_Reg_4_S_2_A1 = EXT VIA2_S_2_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_2_A1 = VIA2_S_2_A1 INTERACT VIA2_Reg_4_S_2_A1  


  VIA2_2stack.pre3 = ENCLOSE RECTANGLE VIA2_same_array_2stack.pre2 VIA_S_2L VIA_W_1 // Find at least one width >= VIA_W_1
  M2_2stack.pre3 = ((M2 INTERACT VIA2_2stack.pre3) OR (M3 INTERACT VIA2_2stack.pre3)) OR (M4 INTERACT VIA2_2stack.pre3)  
  VIA2_Reg_3_S_2 = EXT VIA2_2stack.pre3 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90
  VIA2_Reg_3_S_2_pre = VIA2_Reg_3_S_2 NOT M2_2stack.pre3
  VIA2_Reg_3_S_2_1 = ENCLOSE RECTANGLE VIA2_Reg_3_S_2_pre 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L 
  VIA2_2stack.pre4 = VIA2_2stack.pre3 INTERACT (VIA2_Reg_3_S_2 INTERACT VIA2_Reg_3_S_2_1)  // Find parallel run length >= VIA_S_2L
  VIA2ArrayS1_S_2 = EXT VIA2_2stack.pre4 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than >= VIA_S_2
  VIA2ArrayS2_S_2 = ((VIA2ArrayS1_S_2 NOT INSIDE M2) NOT INSIDE M3 ) NOT INSIDE M4
  VIA2_2stack.pre5 = VIA2_2stack.pre4 INTERACT VIA2ArrayS2_S_2

  M2_2stack.pre4 = EXT M2_2stack.pre3 <= VIA_S_2 ABUT < 90 OPPOSITE SINGULAR REGION
  M2_2stack.pre4_edge = M2_2stack.pre3 COIN OUTSIDE EDGE M2_2stack.pre4
  M2_2stack.pre5 = EXPAND EDGE M2_2stack.pre4_edge INSIDE BY VIA_S_4
  M2_2stack.pre5_region_1 = M2_2stack.pre5 INTERACT VIA2_2stack.pre5
  M2_2stack.pre5_region = M2_2stack.pre4 INTERACT M2_2stack.pre5_region_1 >= 2
  M2_2stack.pre6 = M2_2stack.pre5_region OR M2_2stack.pre5_region_1
  M2_2stack.pre7 = M2_2stack.pre6 INTERACT VIA2_2stack.pre5 >= 2
  VIA2_2stack.Final = VIA2_2stack.pre5 INTERACT M2_2stack.pre7

  VIA2_S_2_A2 = VIA2 INTERACT VIA2_2stack.Final 
  VIA2_Reg_4_S_2_A2 = EXT VIA2_S_2_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_2_A2= VIA2_S_2_A2 INTERACT VIA2_Reg_4_S_2_A2                 
  VIA3_S_2_A2 = VIA3 INTERACT VIA2_2stack.Final 
  VIA3_Reg_4_S_2_A2 = EXT VIA3_S_2_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_2_A2 = VIA3_S_2_A2 INTERACT VIA3_Reg_4_S_2_A2  


  VIA3_2stack.pre3 = ENCLOSE RECTANGLE VIA3_same_array_2stack.pre2 VIA_S_2L VIA_W_1 // Find at least one width >= VIA_W_1
  M3_2stack.pre3 = ((M3 INTERACT VIA3_2stack.pre3) OR (M4 INTERACT VIA3_2stack.pre3)) OR (M5 INTERACT VIA3_2stack.pre3)  
  VIA3_Reg_3_S_2 = EXT VIA3_2stack.pre3 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90
  VIA3_Reg_3_S_2_pre = VIA3_Reg_3_S_2 NOT M3_2stack.pre3
  VIA3_Reg_3_S_2_1 = ENCLOSE RECTANGLE VIA3_Reg_3_S_2_pre 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L 
  VIA3_2stack.pre4 = VIA3_2stack.pre3 INTERACT (VIA3_Reg_3_S_2 INTERACT VIA3_Reg_3_S_2_1)  // Find parallel run length >= VIA_S_2L
  VIA3ArrayS1_S_2 = EXT VIA3_2stack.pre4 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than >= VIA_S_2
  VIA3ArrayS2_S_2 = ((VIA3ArrayS1_S_2 NOT INSIDE M3) NOT INSIDE M4 ) NOT INSIDE M5
  VIA3_2stack.pre5 = VIA3_2stack.pre4 INTERACT VIA3ArrayS2_S_2

  M3_2stack.pre4 = EXT M3_2stack.pre3 <= VIA_S_2 ABUT < 90 OPPOSITE SINGULAR REGION
  M3_2stack.pre4_edge = M3_2stack.pre3 COIN OUTSIDE EDGE M3_2stack.pre4
  M3_2stack.pre5 = EXPAND EDGE M3_2stack.pre4_edge INSIDE BY VIA_S_4
  M3_2stack.pre5_region_1 = M3_2stack.pre5 INTERACT VIA3_2stack.pre5
  M3_2stack.pre5_region = M3_2stack.pre4 INTERACT M3_2stack.pre5_region_1 >= 2
  M3_2stack.pre6 = M3_2stack.pre5_region OR M3_2stack.pre5_region_1
  M3_2stack.pre7 = M3_2stack.pre6 INTERACT VIA3_2stack.pre5 >= 2
  VIA3_2stack.Final = VIA3_2stack.pre5 INTERACT M3_2stack.pre7

  VIA3_S_2_A3 = VIA3 INTERACT VIA3_2stack.Final 
  VIA3_Reg_4_S_2_A3 = EXT VIA3_S_2_A3 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_2_A3= VIA3_S_2_A3 INTERACT VIA3_Reg_4_S_2_A3                 
  VIA4_S_2_A3 = VIA4 INTERACT VIA3_2stack.Final 
  VIA4_Reg_4_S_2_A3 = EXT VIA4_S_2_A3 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_2_A3 = VIA4_S_2_A3 INTERACT VIA4_Reg_4_S_2_A3  


  VIA4_2stack.pre3 = ENCLOSE RECTANGLE VIA4_same_array_2stack.pre2 VIA_S_2L VIA_W_1 // Find at least one width >= VIA_W_1
  M4_2stack.pre3 = ((M4 INTERACT VIA4_2stack.pre3) OR (M5 INTERACT VIA4_2stack.pre3)) OR (M6 INTERACT VIA4_2stack.pre3)  
  VIA4_Reg_3_S_2 = EXT VIA4_2stack.pre3 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90
  VIA4_Reg_3_S_2_pre = VIA4_Reg_3_S_2 NOT M4_2stack.pre3
  VIA4_Reg_3_S_2_1 = ENCLOSE RECTANGLE VIA4_Reg_3_S_2_pre 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L 
  VIA4_2stack.pre4 = VIA4_2stack.pre3 INTERACT (VIA4_Reg_3_S_2 INTERACT VIA4_Reg_3_S_2_1)  // Find parallel run length >= VIA_S_2L
  VIA4ArrayS1_S_2 = EXT VIA4_2stack.pre4 <= VIA_S_5 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than >= VIA_S_2
  VIA4ArrayS2_S_2 = ((VIA4ArrayS1_S_2 NOT INSIDE M4) NOT INSIDE M5 ) NOT INSIDE M6
  VIA4_2stack.pre5 = VIA4_2stack.pre4 INTERACT VIA4ArrayS2_S_2

  M4_2stack.pre4 = EXT M4_2stack.pre3 <= VIA_S_2 ABUT < 90 OPPOSITE SINGULAR REGION
  M4_2stack.pre4_edge = M4_2stack.pre3 COIN OUTSIDE EDGE M4_2stack.pre4
  M4_2stack.pre5 = EXPAND EDGE M4_2stack.pre4_edge INSIDE BY VIA_S_4
  M4_2stack.pre5_region_1 = M4_2stack.pre5 INTERACT VIA4_2stack.pre5
  M4_2stack.pre5_region = M4_2stack.pre4 INTERACT M4_2stack.pre5_region_1 >= 2
  M4_2stack.pre6 = M4_2stack.pre5_region OR M4_2stack.pre5_region_1
  M4_2stack.pre7 = M4_2stack.pre6 INTERACT VIA4_2stack.pre5 >= 2
  VIA4_2stack.Final = VIA4_2stack.pre5 INTERACT M4_2stack.pre7

  VIA4_S_2_A4 = VIA4 INTERACT VIA4_2stack.Final 
  VIA4_Reg_4_S_2_A4 = EXT VIA4_S_2_A4 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_2_A4= VIA4_S_2_A4 INTERACT VIA4_Reg_4_S_2_A4                 
  VIA5_S_2_A4 = VIA5 INTERACT VIA4_2stack.Final 
  VIA5_Reg_4_S_2_A4 = EXT VIA5_S_2_A4 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA5s space smaller than 0.49 (inside small array)  
  VIA5_Violate_S_2_A4 = VIA5_S_2_A4 INTERACT VIA5_Reg_4_S_2_A4  






// Processing for VIAx.S.9 Check    
//**************************************
  M1_2stack_S_9.pre3 = ((M1 INTERACT VIA1_same_array_2stack_S_9.pre2) OR (M2 INTERACT VIA1_same_array_2stack_S_9.pre2)) OR (M3 INTERACT VIA1_same_array_2stack_S_9.pre2) 
  VIA1_2stack_S_9.pre3 = SIZE VIA1_same_array_2stack_S_9.pre2 BY VIA_S_4 INSIDE OF M1_2stack_S_9.pre3 STEP 0.28
  VIA1_2stack_S_9.pre4 = VIA1_2stack_S_9.pre3 TOUCH EDGE M1_2stack_S_9.pre3
  VIA1_2stack_S_9.pre5 = VIA1_2stack_S_9.pre3 WITH EDGE VIA1_2stack_S_9.pre4 >= 1
  VIA1_2stack_S_9.Final = VIA1_same_array_2stack_S_9.pre2 INTERACT VIA1_2stack_S_9.pre5

  VIA1_S_2_B1 = VIA1 INTERACT VIA1_2stack_S_9.Final 
  VIA1_Reg_4_S_2_B1 = EXT VIA1_S_2_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA1s space smaller than 0.49 (inside small array)  
  VIA1_Violate_S_2_B1= VIA1_S_2_B1 INTERACT VIA1_Reg_4_S_2_B1                 
  VIA2_S_2_B1 = VIA2 INTERACT VIA1_2stack_S_9.Final 
  VIA2_Reg_4_S_2_B1 = EXT VIA2_S_2_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_2_B1 = VIA2_S_2_B1 INTERACT VIA2_Reg_4_S_2_B1  


  M2_2stack_S_9.pre3 = ((M2 INTERACT VIA2_same_array_2stack_S_9.pre2) OR (M3 INTERACT VIA2_same_array_2stack_S_9.pre2)) OR (M4 INTERACT VIA2_same_array_2stack_S_9.pre2) 
  VIA2_2stack_S_9.pre3 = SIZE VIA2_same_array_2stack_S_9.pre2 BY VIA_S_4 INSIDE OF M2_2stack_S_9.pre3 STEP 0.28
  VIA2_2stack_S_9.pre4 = VIA2_2stack_S_9.pre3 TOUCH EDGE M2_2stack_S_9.pre3
  VIA2_2stack_S_9.pre5 = VIA2_2stack_S_9.pre3 WITH EDGE VIA2_2stack_S_9.pre4 >= 1
  VIA2_2stack_S_9.Final = VIA2_same_array_2stack_S_9.pre2 INTERACT VIA2_2stack_S_9.pre5

  VIA2_S_2_B2 = VIA2 INTERACT VIA2_2stack_S_9.Final 
  VIA2_Reg_4_S_2_B2 = EXT VIA2_S_2_B2 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_2_B2= VIA2_S_2_B2 INTERACT VIA2_Reg_4_S_2_B2                 
  VIA3_S_2_B2 = VIA3 INTERACT VIA2_2stack_S_9.Final 
  VIA3_Reg_4_S_2_B2 = EXT VIA3_S_2_B2 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_2_B2 = VIA3_S_2_B2 INTERACT VIA3_Reg_4_S_2_B2  


  M3_2stack_S_9.pre3 = ((M3 INTERACT VIA3_same_array_2stack_S_9.pre2) OR (M4 INTERACT VIA3_same_array_2stack_S_9.pre2)) OR (M5 INTERACT VIA3_same_array_2stack_S_9.pre2) 
  VIA3_2stack_S_9.pre3 = SIZE VIA3_same_array_2stack_S_9.pre2 BY VIA_S_4 INSIDE OF M3_2stack_S_9.pre3 STEP 0.28
  VIA3_2stack_S_9.pre4 = VIA3_2stack_S_9.pre3 TOUCH EDGE M3_2stack_S_9.pre3
  VIA3_2stack_S_9.pre5 = VIA3_2stack_S_9.pre3 WITH EDGE VIA3_2stack_S_9.pre4 >= 1
  VIA3_2stack_S_9.Final = VIA3_same_array_2stack_S_9.pre2 INTERACT VIA3_2stack_S_9.pre5

  VIA3_S_2_B3 = VIA3 INTERACT VIA3_2stack_S_9.Final 
  VIA3_Reg_4_S_2_B3 = EXT VIA3_S_2_B3 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_2_B3= VIA3_S_2_B3 INTERACT VIA3_Reg_4_S_2_B3                 
  VIA4_S_2_B3 = VIA4 INTERACT VIA3_2stack_S_9.Final 
  VIA4_Reg_4_S_2_B3 = EXT VIA4_S_2_B3 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_2_B3 = VIA4_S_2_B3 INTERACT VIA4_Reg_4_S_2_B3  


  M4_2stack_S_9.pre3 = ((M4 INTERACT VIA4_same_array_2stack_S_9.pre2) OR (M5 INTERACT VIA4_same_array_2stack_S_9.pre2)) OR (M6 INTERACT VIA4_same_array_2stack_S_9.pre2) 
  VIA4_2stack_S_9.pre3 = SIZE VIA4_same_array_2stack_S_9.pre2 BY VIA_S_4 INSIDE OF M4_2stack_S_9.pre3 STEP 0.28
  VIA4_2stack_S_9.pre4 = VIA4_2stack_S_9.pre3 TOUCH EDGE M4_2stack_S_9.pre3
  VIA4_2stack_S_9.pre5 = VIA4_2stack_S_9.pre3 WITH EDGE VIA4_2stack_S_9.pre4 >= 1
  VIA4_2stack_S_9.Final = VIA4_same_array_2stack_S_9.pre2 INTERACT VIA4_2stack_S_9.pre5

  VIA4_S_2_B4 = VIA4 INTERACT VIA4_2stack_S_9.Final 
  VIA4_Reg_4_S_2_B4 = EXT VIA4_S_2_B4 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_2_B4= VIA4_S_2_B4 INTERACT VIA4_Reg_4_S_2_B4                 
  VIA5_S_2_B4 = VIA5 INTERACT VIA4_2stack_S_9.Final 
  VIA5_Reg_4_S_2_B4 = EXT VIA5_S_2_B4 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA5s space smaller than 0.49 (inside small array)  
  VIA5_Violate_S_2_B4 = VIA5_S_2_B4 INTERACT VIA5_Reg_4_S_2_B4  



// Processing for Mx.S.6 Check    
//**************************************
  VIA1_2stack_Mx_S6.pre3 = ENCLOSE RECTANGLE VIA1_same_array_2stack_Mx_S6.pre2 VIA_W_1 VIA_W_1  // Find at least one width >= VIA_W_1

  M1_S_2_C1 = ENC VIA1_2stack_Mx_S6.pre3 [M1] <= VIA_S_4 ABUT < 90 SINGULAR 
  M1_Reg_4_S_2_C1 = EXT M1_S_2_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M1s space smaller than 1.2   
  M2_S_2_C1 = ENC VIA1_2stack_Mx_S6.pre3 [M2] <= VIA_S_4 ABUT < 90 SINGULAR 
  M2_Reg_4_S_2_C1 = EXT M2_S_2_C1 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M2s space smaller than 1.2   


  VIA2_2stack_Mx_S6.pre3 = ENCLOSE RECTANGLE VIA2_same_array_2stack_Mx_S6.pre2 VIA_W_1 VIA_W_1  // Find at least one width >= VIA_W_1

  M2_S_2_C2 = ENC VIA2_2stack_Mx_S6.pre3 [M2] <= VIA_S_4 ABUT < 90 SINGULAR 
  M2_Reg_4_S_2_C2 = EXT M2_S_2_C2 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M2s space smaller than 1.2   
  M3_S_2_C2 = ENC VIA2_2stack_Mx_S6.pre3 [M3] <= VIA_S_4 ABUT < 90 SINGULAR 
  M3_Reg_4_S_2_C2 = EXT M3_S_2_C2 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M3s space smaller than 1.2   


  VIA3_2stack_Mx_S6.pre3 = ENCLOSE RECTANGLE VIA3_same_array_2stack_Mx_S6.pre2 VIA_W_1 VIA_W_1  // Find at least one width >= VIA_W_1

  M3_S_2_C3 = ENC VIA3_2stack_Mx_S6.pre3 [M3] <= VIA_S_4 ABUT < 90 SINGULAR 
  M3_Reg_4_S_2_C3 = EXT M3_S_2_C3 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M3s space smaller than 1.2   
  M4_S_2_C3 = ENC VIA3_2stack_Mx_S6.pre3 [M4] <= VIA_S_4 ABUT < 90 SINGULAR 
  M4_Reg_4_S_2_C3 = EXT M4_S_2_C3 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M4s space smaller than 1.2   


  VIA4_2stack_Mx_S6.pre3 = ENCLOSE RECTANGLE VIA4_same_array_2stack_Mx_S6.pre2 VIA_W_1 VIA_W_1  // Find at least one width >= VIA_W_1

  M4_S_2_C4 = ENC VIA4_2stack_Mx_S6.pre3 [M4] <= VIA_S_4 ABUT < 90 SINGULAR 
  M4_Reg_4_S_2_C4 = EXT M4_S_2_C4 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M4s space smaller than 1.2   
  M5_S_2_C4 = ENC VIA4_2stack_Mx_S6.pre3 [M5] <= VIA_S_4 ABUT < 90 SINGULAR 
  M5_Reg_4_S_2_C4 = EXT M5_S_2_C4 < Mx_S_3_7 SPACE ABUT < 90 OPPOSITE REGION // M5s space smaller than 1.2   




// Rule Check    
//**************************************
  CONNECT VIA1_2stack.Final VIA1_Violate_S_2_A1
  CONNECT VIA1_2stack.Final VIA2_Violate_S_2_A1
  CONNECT VIA2_2stack.Final VIA2_Violate_S_2_A2
  CONNECT VIA2_2stack.Final VIA3_Violate_S_2_A2
  CONNECT VIA3_2stack.Final VIA3_Violate_S_2_A3
  CONNECT VIA3_2stack.Final VIA4_Violate_S_2_A3
  CONNECT VIA4_2stack.Final VIA4_Violate_S_2_A4
  CONNECT VIA4_2stack.Final VIA5_Violate_S_2_A4
  
VIA1.S.5_Array1_2_M { @ Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um
                       @ Via1 violate ^VIA_S_3 spacing in Via1/Via2 array & density large or equal ^VIA_D_1 
  A1 = NET AREA RATIO VIA1_Violate_S_2_A1 VIA1_2stack.Final >= VIA_D_1
  A2 = NET AREA RATIO VIA2_Violate_S_2_A1 VIA1_2stack.Final >= VIA_D_1
  B1 = A1 OR A2
  SIZE B1 BY VIA_Merge OVERUNDER 
}


M1_2.S.6 { @ Minimum space between two Mx region with below conditions >= ^Mx_S_3_7 um 
			  @ (a1) both of the Mx with the overlap area of 2-level continuous VIA array area >= ^VIA_A_2_B um2
			  @ (a2) Width of 2-level continuous stacking VIA arrays >= ^VIA_W_1 um
  M1_Reg_4_S_2_C1 OR M2_Reg_4_S_2_C1
}

VIA2.S.5_Array2_3_M { @ Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um
                       @ Via2 violate ^VIA_S_3 spacing in Via2/Via3 array & density large or equal ^VIA_D_1 
  A2 = NET AREA RATIO VIA2_Violate_S_2_A2 VIA2_2stack.Final >= VIA_D_1
  A3 = NET AREA RATIO VIA3_Violate_S_2_A2 VIA2_2stack.Final >= VIA_D_1
  B2 = A2 OR A3
  SIZE B2 BY VIA_Merge OVERUNDER 
}


M2_3.S.6 { @ Minimum space between two Mx region with below conditions >= ^Mx_S_3_7 um 
			  @ (a1) both of the Mx with the overlap area of 2-level continuous VIA array area >= ^VIA_A_2_B um2
			  @ (a2) Width of 2-level continuous stacking VIA arrays >= ^VIA_W_1 um
  M2_Reg_4_S_2_C2 OR M3_Reg_4_S_2_C2
}

VIA3.S.5_Array3_4_M { @ Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um
                       @ Via3 violate ^VIA_S_3 spacing in Via3/Via4 array & density large or equal ^VIA_D_1 
  A3 = NET AREA RATIO VIA3_Violate_S_2_A3 VIA3_2stack.Final >= VIA_D_1
  A4 = NET AREA RATIO VIA4_Violate_S_2_A3 VIA3_2stack.Final >= VIA_D_1
  B3 = A3 OR A4
  SIZE B3 BY VIA_Merge OVERUNDER 
}


M3_4.S.6 { @ Minimum space between two Mx region with below conditions >= ^Mx_S_3_7 um 
			  @ (a1) both of the Mx with the overlap area of 2-level continuous VIA array area >= ^VIA_A_2_B um2
			  @ (a2) Width of 2-level continuous stacking VIA arrays >= ^VIA_W_1 um
  M3_Reg_4_S_2_C3 OR M4_Reg_4_S_2_C3
}





VIA3.S.9_Array3_4_M { @ Minimum space between two VIA3 region >= ^VIA_S_3 um if the overlap area of 2-level
					   @ continuous stacking VIA arrays >= ^VIA_A_2_B um2 (except sealring region)
  (VIA3_2stack_S_9.Final INTERACT VIA3_Violate_S_2_B3) NOT INTERACT SEALRING_ALL
}

VIA4.S.9_Array3_4_M { @ Minimum space between two VIA4 region >= ^VIA_S_3 um if the overlap area of 2-level
					    @ continuous stacking VIA arrays >= ^VIA_A_2_B um2 (except sealring region)
  (VIA3_2stack_S_9.Final INTERACT VIA4_Violate_S_2_B3) NOT INTERACT SEALRING_ALL
}


VIA4.S.5_Array4_5_M { @ Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um
                       @ Via4 violate ^VIA_S_3 spacing in Via4/Via5 array & density large or equal ^VIA_D_1 
  A4 = NET AREA RATIO VIA4_Violate_S_2_A4 VIA4_2stack.Final >= VIA_D_1
  A5 = NET AREA RATIO VIA5_Violate_S_2_A4 VIA4_2stack.Final >= VIA_D_1
  B4 = A4 OR A5
  SIZE B4 BY VIA_Merge OVERUNDER
}




VIA4.S.9_Array4_5_M { @ Minimum space between two VIA4 region >= ^VIA_S_3 um if the overlap area of 2-level
					   @ continuous stacking VIA arrays >= ^VIA_A_2_B um2 (except sealring region)
  (VIA4_2stack_S_9.Final INTERACT VIA4_Violate_S_2_B4) NOT INTERACT SEALRING_ALL
}

VIA5.S.9_Array4_5_M { @ Minimum space between two VIA5 region >= ^VIA_S_3 um if the overlap area of 2-level
						@ continuous stacking VIA arrays >= ^VIA_A_2_B um2 (except sealring region)
  (VIA4_2stack_S_9.Final INTERACT VIA5_Violate_S_2_B4) NOT INTERACT SEALRING_ALL
}
M4_5.S.6 { @ Minimum space between two Mx region with below conditions >= ^Mx_S_3_7 um 
			  @ (a1) both of the Mx with the overlap area of 2-level continuous VIA array area >= ^VIA_A_2_B um2
			  @ (a2) Width of 2-level continuous stacking VIA arrays >= ^VIA_W_1 um
  M4_Reg_4_S_2_C4 OR M5_Reg_4_S_2_C4
}





//****************************  
// Small single layer array
//****************************
// Processing for VIAx.S.10 Check    
//**************************************
  M1_1stack_S_10.pre2 = (M1 INTERACT VIA1_same_array_1stack_S_10.pre1) OR (M2 INTERACT VIA1_same_array_1stack_S_10.pre1) 
  VIA1_1stack_S_10.pre2 = SIZE VIA1_same_array_1stack_S_10.pre1 BY VIA_S_4 INSIDE OF M1_1stack_S_10.pre2 STEP 0.28
  VIA1_1stack_S_10.pre3 = VIA1_1stack_S_10.pre2 TOUCH EDGE M1_1stack_S_10.pre2
  VIA1_1stack_S_10.pre4 = VIA1_1stack_S_10.pre2 WITH EDGE VIA1_1stack_S_10.pre3 >= 1
  VIA1_1stack_S_10.Final = VIA1_same_array_1stack_S_10.pre1 INTERACT VIA1_1stack_S_10.pre4

  VIA1_S_1_B1 = VIA1 INTERACT VIA1_1stack_S_10.Final 
  VIA1_Reg_4_S_1_B1 = EXT VIA1_S_1_B1 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA1s space smaller than 0.49 (inside small array)  
  VIA1_Violate_S_1_B1= VIA1_S_1_B1 INTERACT VIA1_Reg_4_S_1_B1                 

  M2_1stack_S_10.pre2 = (M2 INTERACT VIA2_same_array_1stack_S_10.pre1) OR (M3 INTERACT VIA2_same_array_1stack_S_10.pre1) 
  VIA2_1stack_S_10.pre2 = SIZE VIA2_same_array_1stack_S_10.pre1 BY VIA_S_4 INSIDE OF M2_1stack_S_10.pre2 STEP 0.28
  VIA2_1stack_S_10.pre3 = VIA2_1stack_S_10.pre2 TOUCH EDGE M2_1stack_S_10.pre2
  VIA2_1stack_S_10.pre4 = VIA2_1stack_S_10.pre2 WITH EDGE VIA2_1stack_S_10.pre3 >= 1
  VIA2_1stack_S_10.Final = VIA2_same_array_1stack_S_10.pre1 INTERACT VIA2_1stack_S_10.pre4

  VIA2_S_1_B2 = VIA2 INTERACT VIA2_1stack_S_10.Final 
  VIA2_Reg_4_S_1_B2 = EXT VIA2_S_1_B2 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_1_B2= VIA2_S_1_B2 INTERACT VIA2_Reg_4_S_1_B2                 

  M3_1stack_S_10.pre2 = (M3 INTERACT VIA3_same_array_1stack_S_10.pre1) OR (M4 INTERACT VIA3_same_array_1stack_S_10.pre1) 
  VIA3_1stack_S_10.pre2 = SIZE VIA3_same_array_1stack_S_10.pre1 BY VIA_S_4 INSIDE OF M3_1stack_S_10.pre2 STEP 0.28
  VIA3_1stack_S_10.pre3 = VIA3_1stack_S_10.pre2 TOUCH EDGE M3_1stack_S_10.pre2
  VIA3_1stack_S_10.pre4 = VIA3_1stack_S_10.pre2 WITH EDGE VIA3_1stack_S_10.pre3 >= 1
  VIA3_1stack_S_10.Final = VIA3_same_array_1stack_S_10.pre1 INTERACT VIA3_1stack_S_10.pre4

  VIA3_S_1_B3 = VIA3 INTERACT VIA3_1stack_S_10.Final 
  VIA3_Reg_4_S_1_B3 = EXT VIA3_S_1_B3 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_1_B3= VIA3_S_1_B3 INTERACT VIA3_Reg_4_S_1_B3                 

  M4_1stack_S_10.pre2 = (M4 INTERACT VIA4_same_array_1stack_S_10.pre1) OR (M5 INTERACT VIA4_same_array_1stack_S_10.pre1) 
  VIA4_1stack_S_10.pre2 = SIZE VIA4_same_array_1stack_S_10.pre1 BY VIA_S_4 INSIDE OF M4_1stack_S_10.pre2 STEP 0.28
  VIA4_1stack_S_10.pre3 = VIA4_1stack_S_10.pre2 TOUCH EDGE M4_1stack_S_10.pre2
  VIA4_1stack_S_10.pre4 = VIA4_1stack_S_10.pre2 WITH EDGE VIA4_1stack_S_10.pre3 >= 1
  VIA4_1stack_S_10.Final = VIA4_same_array_1stack_S_10.pre1 INTERACT VIA4_1stack_S_10.pre4

  VIA4_S_1_B4 = VIA4 INTERACT VIA4_1stack_S_10.Final 
  VIA4_Reg_4_S_1_B4 = EXT VIA4_S_1_B4 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_1_B4= VIA4_S_1_B4 INTERACT VIA4_Reg_4_S_1_B4                 

  M5_1stack_S_10.pre2 = (M5 INTERACT VIA5_same_array_1stack_S_10.pre1) OR (M6 INTERACT VIA5_same_array_1stack_S_10.pre1) 
  VIA5_1stack_S_10.pre2 = SIZE VIA5_same_array_1stack_S_10.pre1 BY VIA_S_4 INSIDE OF M5_1stack_S_10.pre2 STEP 0.28
  VIA5_1stack_S_10.pre3 = VIA5_1stack_S_10.pre2 TOUCH EDGE M5_1stack_S_10.pre2
  VIA5_1stack_S_10.pre4 = VIA5_1stack_S_10.pre2 WITH EDGE VIA5_1stack_S_10.pre3 >= 1
  VIA5_1stack_S_10.Final = VIA5_same_array_1stack_S_10.pre1 INTERACT VIA5_1stack_S_10.pre4

  VIA5_S_1_B5 = VIA5 INTERACT VIA5_1stack_S_10.Final 
  VIA5_Reg_4_S_1_B5 = EXT VIA5_S_1_B5 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA5s space smaller than 0.49 (inside small array)  
  VIA5_Violate_S_1_B5= VIA5_S_1_B5 INTERACT VIA5_Reg_4_S_1_B5                 


// Rule Check    
//**************************************

VIA4.S.10_Array4_M { @ Minimum space between two VIA4 region >= ^VIA_S_3 um if the single layer VIA arrays area >= ^VIA_A_1 um2 (except sealring region)
  (VIA4_1stack_S_10.Final INTERACT VIA4_Violate_S_1_B4) NOT INTERACT SEALRING_ALL
}

VIA5.S.10_Array5_M { @ Minimum space between two VIA5 region >= ^VIA_S_3 um if the single layer VIA arrays area >= ^VIA_A_1 um2 (except sealring region)
  (VIA5_1stack_S_10.Final INTERACT VIA5_Violate_S_1_B5) NOT INTERACT SEALRING_ALL
}














CB_CUP = CB INTERACT WBDMY
notch_CB    = EXT CB <5 NOTCH OPPOSITE REGION    
CB_SINGLE   = CB OR notch_CB

// VIA5 checks
//=============

VIA5R = VIA5 NOT INSIDE CB_SINGLE

VIA5R_CORE = VIA5R NOT SR_VIA5
VIA5.W.1 { @ VIA5 must be ^VIAn_W_1 x ^VIAn_W_1
  A = NOT RECTANGLE VIA5R_CORE == VIAn_W_1 BY == VIAn_W_1 ORTHOGONAL ONLY
  A OUTSIDE RNGX     // exclude from metal fuse protection ring area
}
VIA5.S.1 { @ Min. VIA5 spacing < ^VIAn_S_1
  EXT VIA5R < VIAn_S_1 ABUT < 90 SINGULAR REGION
}
VIA5.E.1 { @ Min. extension of a M5 region beyond a VIA5 region < 0.01
  ENC VIA5R M5 < 0.01 ABUT < 90 SINGULAR REGION
  VIA5R NOT M5    
}
VIA5.E.2 { @ Min. extension of a M5 end-of-line region beyond VIA5 region < 0.06
  X = ENC [VIA5R] M5 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.36 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}
#IFDEF Recommend
VIA5.E.3 { @ Min. extension of M5 beyond the overlap area that VIA5 and VIA4 are fully or partially touching < ^VIA5_E_3
  X = VIA5R AND VIA4
  ENC X M5 < VIA5_E_3 ABUT < 90 SINGULAR REGION	
}
#ENDIF



#IFDEF CHECK_ALRDL
#IFNDEF THICK_20K



#IFNDEF THICK_40K


// VIAD checks
//=============

VIADR = VIAD NOT INSIDE CB_SINGLE

VIADR_CORE = VIADR NOT SR_VIAD
VIAD.W.1 { @ VIAD must be ^VIAD_W_1 x ^VIAD_W_1
  A = NOT RECTANGLE VIADR_CORE == VIAD_W_1 BY == VIAD_W_1 ORTHOGONAL ONLY
  A OUTSIDE RNGX     // exclude from metal fuse protection ring area
}
VIAD.S.1 { @ Min. VIAD spacing < ^VIAD_S_1
  EXT VIADR < VIAD_S_1 ABUT < 90 SINGULAR REGION
}
VIAD.E.1 { @ Min. extension of a M6 region beyond a VIAD region < 0.01
  ENC VIADR M6 < 0.01 ABUT < 90 SINGULAR REGION
  VIADR NOT M6    
}
VIAD.E.2 { @ Min. extension of a M6 end-of-line region beyond VIAD region < 0.06
  X = ENC [VIADR] M6 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.36 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}
#IFDEF Recommend
VIAD.E.3 { @ Min. extension of M6 beyond the overlap area that VIAD and VIA5 are fully or partially touching < ^VIAD_E_3
  X = VIADR AND VIA5R
  ENC X M6 < VIAD_E_3 ABUT < 90 SINGULAR REGION	
}
#ENDIF

#ENDIF
#ENDIF
#ENDIF









#IFNDEF THICK_20K
#IFNDEF THICK_40K



// M6 checks
//=============
M6.W.1 { @ Min. M6 width < 0.44
  INT M6 < 0.44 ABUT < 90 SINGULAR REGION
}
M6.S.1 { @ Min. M6 space < 0.46
  EXT M6 < 0.46 ABUT < 90 SINGULAR REGION
}
M6.S.2 { @ Min. space to wide M6 (>10um) < 0.6
  M6_S5 = SHRINK (SHRINK (SHRINK (SHRINK M6 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_G5 = GROW (GROW (GROW (GROW M6_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_Wide = M6_G5 AND M6
  M6_Exp = SIZE M6_Wide BY 1 INSIDE OF M6 STEP 0.322
  M6_Branch = M6_Exp NOT M6_Wide
  M6_Branch_edge = M6_Branch COIN INSIDE EDGE M6
  M6_Check = M6 AND (SIZE M6_Exp BY 0.6)
  M6_Branch_Check = M6 AND (EXPAND EDGE M6_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
  M6_WideC = STAMP M6_Wide BY M6xd
  M6_CheckC = STAMP M6_Check BY M6xd
  M6_BranchC = STAMP M6_Branch BY M6xd
  M6_Branch_CheckC = STAMP M6_Branch_Check BY M6xd
  EXT M6_WideC M6_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M6_BranchC M6_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
M6.S.2.1.a { @ Min. space betweem wide metal and small piece of metal with parallel run length >= ^M6_S_2_L and same connection >=^M6_S_2_1 um
  M6_S5 = SHRINK (SHRINK (SHRINK (SHRINK M6 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_G5 = GROW (GROW (GROW (GROW M6_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_Wide = M6_G5 AND M6
  M6_Small = M6 NOT M6_Wide
  M6_WideC = STAMP M6_Wide BY M6xd
  M6_SmallC = STAMP M6_Small BY M6xd
  M6_S_REG = EXT M6_WideC M6_SmallC < M6_S_2_1 CONNECTED OPPOSITE REGION MEASURE ALL
  M6_S_REG_CHECK = ENCLOSE RECTANGLE M6_S_REG GRID M6_S_2_L 
  WideEdge1 = M6_S_REG_CHECK COIN OUTSIDE EDGE M6_Wide
  M6_Small_Edge = M6_Small COIN INSIDE EDGE M6
  WideEdge2 = M6_S_REG_CHECK COIN OUTSIDE EDGE M6_Small_Edge
  PATH LENGTH WideEdge1 >= M6_S_2_L
  PATH LENGTH WideEdge2 >= M6_S_2_L
}
M6.S.2.1.b { @ Min. space between two wide metals with parallel run length >= ^M6_S_2_L and same connection >=^M6_S_2_2 um
  M6_S5 = SHRINK (SHRINK (SHRINK (SHRINK M6 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_G5 = GROW (GROW (GROW (GROW M6_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_Wide = M6_G5 AND M6
  M6_WideC = STAMP M6_Wide BY M6xd
  M6_S_REG = EXT M6_WideC < M6_S_2_2 CONNECTED OPPOSITE REGION
  M6_S_REG_CHECK = ENCLOSE RECTANGLE M6_S_REG GRID M6_S_2_L
  WideEdge = M6_S_REG_CHECK COIN OUTSIDE EDGE M6_Wide
  PATH LENGTH WideEdge >= M6_S_2_L
}

M6.E.1 { @ Min. extension of a M6 region beyond a VIA5 region < 0.09
   ENC VIA5 M6 < 0.09 ABUT<90 SINGULAR 
   VIA5 NOT M6    
}
M6.A.1 { @ Min. M6 area region < 0.562
  AREA M6 < 0.562
}



#IFDEF CHECK_ALRDL
// MD checks
//=============
MD.W.1 { @ Min. MD width < 0.44
  INT MD < 0.44 ABUT < 90 SINGULAR REGION
}
MD.S.1 { @ Min. MD space < 0.46
  EXT MD < 0.46 ABUT < 90 SINGULAR REGION
}
MD.S.2 { @ Min. space to wide MD (>10um) < 0.6
  MD_S5 = SHRINK (SHRINK (SHRINK (SHRINK MD RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  MD_G5 = GROW (GROW (GROW (GROW MD_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  MD_Wide = MD_G5 AND MD
  MD_Exp = SIZE MD_Wide BY 1 INSIDE OF MD STEP 0.322
  MD_Branch = MD_Exp NOT MD_Wide
  MD_Branch_edge = MD_Branch COIN INSIDE EDGE MD
  MD_Check = MD AND (SIZE MD_Exp BY 0.6)
  MD_Branch_Check = MD AND (EXPAND EDGE MD_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
  MD_WideC = STAMP MD_Wide BY MDxd
  MD_CheckC = STAMP MD_Check BY MDxd
  MD_BranchC = STAMP MD_Branch BY MDxd
  MD_Branch_CheckC = STAMP MD_Branch_Check BY MDxd
  EXT MD_WideC MD_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT MD_BranchC MD_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
MD.S.2.1.a { @ Min. space betweem wide metal and small piece of metal with parallel run length >= ^MD_S_2_L and same connection >=^MD_S_2_1 um
  MD_S5 = SHRINK (SHRINK (SHRINK (SHRINK MD RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  MD_G5 = GROW (GROW (GROW (GROW MD_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  MD_Wide = MD_G5 AND MD
  MD_Small = MD NOT MD_Wide
  MD_WideC = STAMP MD_Wide BY MDxd
  MD_SmallC = STAMP MD_Small BY MDxd
  MD_S_REG = EXT MD_WideC MD_SmallC < MD_S_2_1 CONNECTED OPPOSITE REGION MEASURE ALL
  MD_S_REG_CHECK = ENCLOSE RECTANGLE MD_S_REG GRID MD_S_2_L 
  WideEdge1 = MD_S_REG_CHECK COIN OUTSIDE EDGE MD_Wide
  MD_Small_Edge = MD_Small COIN INSIDE EDGE MD
  WideEdge2 = MD_S_REG_CHECK COIN OUTSIDE EDGE MD_Small_Edge
  PATH LENGTH WideEdge1 >= MD_S_2_L
  PATH LENGTH WideEdge2 >= MD_S_2_L
}
MD.S.2.1.b { @ Min. space between two wide metals with parallel run length >= ^MD_S_2_L and same connection >=^MD_S_2_2 um
  MD_S5 = SHRINK (SHRINK (SHRINK (SHRINK MD RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  MD_G5 = GROW (GROW (GROW (GROW MD_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  MD_Wide = MD_G5 AND MD
  MD_WideC = STAMP MD_Wide BY MDxd
  MD_S_REG = EXT MD_WideC < MD_S_2_2 CONNECTED OPPOSITE REGION
  MD_S_REG_CHECK = ENCLOSE RECTANGLE MD_S_REG GRID MD_S_2_L
  WideEdge = MD_S_REG_CHECK COIN OUTSIDE EDGE MD_Wide
  PATH LENGTH WideEdge >= MD_S_2_L
}

MD.E.1 { @ Min. extension of a MD region beyond a VIAD region < 0.09
   ENC VIAD MD < 0.09 ABUT<90 SINGULAR 
   VIAD NOT MD    
}
MD.A.1 { @ Min. MD area region < 0.562
  AREA MD < 0.562
}
#ENDIF
#ENDIF
#ENDIF






// METAL RATIO CHECKS
//======================
PO.R.3 {@ Min poly area coverage < 14%
  ALL_POLY = POLYi OR DPO
  DENSITY ALL_POLY < 0.14 PRINT POLY_DENSITY.log
}
M1.R.1 { @ Min M1 area coverage < 30%
  DENSITY M1xd < 0.3 PRINT M1_DENSITY.log
}


M2.R.1 { @ Min M2 area coverage < 30%
  DENSITY M2xd < 0.3 PRINT M2_DENSITY.log
}


M3.R.1 { @ Min M3 area coverage < 30%
  DENSITY M3xd < 0.3 PRINT M3_DENSITY.log
}


M4.R.1 { @ Min M4 area coverage < 30%
  DENSITY M4xd < 0.3 PRINT M4_DENSITY.log
}


M5.R.1 { @ Min M5 area coverage < 30%
  DENSITY M5xd < 0.3 PRINT M5_DENSITY.log
}



#IFNDEF THICK_20K
#IFNDEF THICK_40K



M6.R.1 { @ Min M6 area coverage < 30%
  DENSITY M6xd < 0.3 PRINT M6_DENSITY.log
}
MD.R.1 { @ Min MD area coverage < 30%
  DENSITY MDxd > 0 < 0.3 PRINT MD_DENSITY.log
}  


#ENDIF
#ENDIF






// Dummy Pad
//==========

GROUP DUMMY_PAD_CHECK ADP.S.2g ADP.W.3g ADP.W.4g

DP_V1 = DPDMY AND VIA1
DP_V2 = DPDMY AND VIA2
DP_V3 = DPDMY AND VIA3
DP_V4 = DPDMY AND VIA4
DP_V5 = DPDMY AND VIA5
DP_VD = DPDMY AND VIAD

ADP.R.0A { @ chip corner dummy pad structure should be M1/M2.../M6
  DPDMY NOT M1
  DPDMY NOT M2
  DPDMY NOT M3
  DPDMY NOT M4
  DPDMY NOT M5
  DPDMY NOT M6
}  

ADP.R.0B { @ chip corner dummy pad structure should be VIA1/VIA2.../VIA6
  DPDMY NOT ENCLOSE VIA1
  DPDMY NOT ENCLOSE VIA2
  DPDMY NOT ENCLOSE VIA3
  DPDMY NOT ENCLOSE VIA4
  DPDMY NOT ENCLOSE VIA5
}

ADP.R.0C { @ Via structure in Dummy Pad
  GRP1 = (DP_V2 OR DP_V4) OR DP_VD
  GRP2 = (DP_V1 OR DP_V3) OR DP_V5
  GRP1 AND GRP2
}
ADP.S.1_VIA1 { @ Via1 spacing (the same level) < 0.58um.
  EXT DP_V1 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_VIA2 { @ Via2 spacing (the same level) < 0.58um.
  EXT DP_V2 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_VIA3 { @ Via3 spacing (the same level) < 0.58um.
  EXT DP_V3 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_VIA4 { @ Via4 spacing (the same level) < 0.58um.
  EXT DP_V4 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_VIA5 { @ Via5 spacing (the same level) < 0.58um.
  EXT DP_V5 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_VIAD { @ ViaD spacing (the same level) < 0.58um.
  EXT DP_VD < 0.58 ABUT<90 SINGULAR REGION
}

ADP.C.1_V1_V2 { @ Vias spacing (different level) < 0.23um.
  EXT DP_V1 DP_V2 < 0.23 ABUT<90 SINGULAR REGION
}
ADP.C.1_V2_V3 { @ Vias spacing (different level) < 0.23um.
  EXT DP_V2 DP_V3 < 0.23 ABUT<90 SINGULAR REGION
}
ADP.C.1_V3_V4 { @ Vias spacing (different level) < 0.23um.
  EXT DP_V3 DP_V4 < 0.23 ABUT<90 SINGULAR REGION
}

ADP.C.2_V4_V5 { @ Via4 and Via5 spacing < 0.16um.
  EXT DP_V4 DP_V5 < 0.16 ABUT<90 SINGULAR REGION
}
ADP.C.2_V5_VD { @ Via5 and ViaD spacing < 0.16um.
  EXT DP_V5 DP_VD < 0.16 ABUT<90 SINGULAR REGION
}

ADP.E.1_V1_M1 { @ Metal1 enclose Via1 in dummy pad < 3um.
  ENC DP_V1 M1 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V1_M2 { @ Metal2 enclose Via1 in dummy pad < 3um.
  ENC DP_V1 M2 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V2_M2 { @ Metal2 enclose Via2 in dummy pad < 3um.
  ENC DP_V2 M2 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V2_M3 { @ Metal3 enclose Via2 in dummy pad < 3um.
  ENC DP_V2 M3 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V3_M3 { @ Metal3 enclose Via3 in dummy pad < 3um.
  ENC DP_V3 M3 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V3_M4 { @ Metal4 enclose Via3 in dummy pad < 3um.
  ENC DP_V3 M4 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V4_M4 { @ Metal4 enclose Via4 in dummy pad < 3um.
  ENC DP_V4 M4 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V4_M5 { @ Metal5 enclose Via4 in dummy pad < 3um.
  ENC DP_V4 M5 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V5_M5 { @ Metal5 enclose Via5 in dummy pad < 3um.
  ENC DP_V5 M5 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V5_M6 { @ Metal6 enclose Via5 in dummy pad < 3um.
  ENC DP_V5 M6 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_VD_M6 { @ Meta6l enclose ViaD in dummy pad < 3um.
  ENC DP_VD M6 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_VD_MD { @ MD enclose ViaD in dummy pad < 3um.
  ENC DP_VD MD < 3 ABUT<90 SINGULAR REGION
}

// ADP.W.1 is checked by VIAx.W.1 ( x= 1..4)
// ADP.W.2 is checked by VIA5.W.1

// Guideline

ADP.S.2g { @ dummy pad spacing < 2um.
  EXT DPDMY < 2 ABUT<90 SINGULAR REGION
}

ADP.W.3g { @ dummy pad width > 80um
  DPADG = INT DPDMY <= 80 REGION OPPOSITE ABUT>0<90
  DPDMY NOT DPADG
}

ADP.W.4g { @ dummy pad width < 40um
  INT DPDMY < 40  ABUT>0<90 SINGULAR REGION
}




// Power Line
//===========

PL_V1 = PLDMY AND VIA1
PL_V2 = PLDMY AND VIA2
PL_V3 = PLDMY AND VIA3
PL_V4 = PLDMY AND VIA4
PL_V5 = PLDMY AND VIA5
PL_VD = PLDMY AND VIAD

ADP.R.0D { @ Via structure in Power Line
  GRP1 = (PL_V2 OR PL_V4) OR PL_VD
  GRP2 = (PL_V1 OR PL_V3) OR PL_V5
  GRP1 AND GRP2
}

ADP.S.1_PL_V1 { @ Via1 spacing (the same level) < 0.58um.
  EXT PL_V1 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_PL_V2 { @ Via2 spacing (the same level) < 0.58um.
  EXT PL_V2 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_PL_V3 { @ Via3 spacing (the same level) < 0.58um.
  EXT PL_V3 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_PL_V4 { @ Via4 spacing (the same level) < 0.58um.
  EXT PL_V4 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_PL_V5 { @ Via5 spacing (the same level) < 0.58um.
  EXT PL_V5 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_PL_VD { @ ViaD spacing (the same level) < 0.58um.
  EXT PL_VD < 0.58 ABUT<90 SINGULAR REGION
}

ADP.C.1_PL_V1_V2 { @ Vias spacing (different level) < 0.23um.
  EXT PL_V1 PL_V2 < 0.23 ABUT<90 SINGULAR REGION
}
ADP.C.1_PL_V2_V3 { @ Vias spacing (different level) < 0.23um.
  EXT PL_V2 PL_V3 < 0.23 ABUT<90 SINGULAR REGION
}
ADP.C.1_PL_V3_V4 { @ Vias spacing (different level) < 0.23um.
  EXT PL_V3 PL_V4 < 0.23 ABUT<90 SINGULAR REGION
}
ADP.C.2_PL_V4_V5 { @ Via4 and Via5 spacing < 0.16um.
  EXT PL_V4 PL_V5 < 0.16 ABUT<90 SINGULAR REGION
}
ADP.C.2_PL_V5_VD { @ Via5 and ViaD spacing < 0.16um.
  EXT PL_V5 PL_VD < 0.16 ABUT<90 SINGULAR REGION
}

ADP.E.2_V1_M1 { @ Metal1 enclose Via1 in chip corner power line < 0.2um.
  ENC PL_V1 M1 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V1_M2 { @ Metal2 enclose Via1 in chip corner power line < 0.2um.
  ENC PL_V1 M2 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V2_M2 { @ Metal2 enclose Via2 in chip corner power line < 0.2um.
  ENC PL_V2 M2 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V2_M3 { @ Metal3 enclose Via2 in chip corner power line < 0.2um.
  ENC PL_V2 M3 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V3_M3 { @ Metal3 enclose Via3 in chip corner power line < 0.2um.
  ENC PL_V3 M3 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V3_M4 { @ Metal4 enclose Via3 in chip corner power line < 0.2um.
  ENC PL_V3 M4 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V4_M4 { @ Metal4 enclose Via4 in chip corner power line < 0.2um.
  ENC PL_V4 M4 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V4_M5 { @ Metal5 enclose Via4 in chip corner power line < 0.2um.
  ENC PL_V4 M5 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V5_M5 { @ Metal5 enclose Via5 in chip corner power line < 0.2um.
  ENC PL_V5 M5 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V5_M6 { @ Metal6 enclose Via5 in chip corner power line < 0.2um.
  ENC PL_V5 M6 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_VD_M6 { @ Metal6 enclose ViaD in chip corner power line < 0.2um.
  ENC PL_VD M6 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_VD_MD { @ MD enclose ViaD in chip corner power line < 0.2um.
  ENC PL_VD MD < 0.2 ABUT<90 SINGULAR REGION
}




//METAL SLOT CHECKS
//================
//Bonding pad ,chip corner dummy pad ,and inductor need not put slot

CB_NON_CUP = CBi NOT INTERACT WBDMY
SLT_EXD  = CB_NON_CUP OR DPDMY
SLT_EXDT = CBi OR DPDMY

PAD_EXD = UBMi NOT INTERACT (MDxd OR PPIi)

M1EXD = M1xd NOT SLT_EXD

//M1 SLOT CHECKS
//==============
M1InnerHole = HOLES M1EXD INNER
M1BigHole   = SIZE M1InnerHole BY -MHOLE/2
M1Hole      = M1InnerHole OUTSIDE M1BigHole 
M1HoleSpace = M1Hole NOT M1EXD
FIM1c       = M1EXD OR M1HoleSpace
LM1XA       = (SIZE (SIZE FIM1c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM1c
LM1X        = ENCLOSE RECTANGLE LM1XA 35.005 35.005
M1HoleD    = M1HoleSpace AND LM1X

AMS.1.M1 { @ Wide Metal (>35um) must have slot.
  A = (SIZE ( SIZE M1EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M1EXD
  ENCLOSE RECTANGLE A 35.005 35.005
}


CONNECT M1HoleD LM1X
AMS.DN.M1 { @ Min. Hole density for metal lines that need to apply slot  1.5%
    NET AREA RATIO LM1X M1HoleD < 0.015
	[ AREA(M1HoleD) / AREA(LM1X) ] RDB M1Hole.density2 LM1X M1HoleD 
}
DISCONNECT

M2EXD = M2xd NOT SLT_EXD

//M2 SLOT CHECKS
//==============
M2InnerHole = HOLES M2EXD INNER
M2BigHole   = SIZE M2InnerHole BY -MHOLE/2
M2Hole      = M2InnerHole OUTSIDE M2BigHole 
M2HoleSpace = M2Hole NOT M2EXD
FIM2c       = M2EXD OR M2HoleSpace
LM2XA       = (SIZE (SIZE FIM2c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM2c
LM2X        = ENCLOSE RECTANGLE LM2XA 35.005 35.005
M2HoleD    = M2HoleSpace AND LM2X

AMS.1.M2 { @ Wide Metal (>35um) must have slot.
  A = (SIZE ( SIZE M2EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M2EXD
  ENCLOSE RECTANGLE A 35.005 35.005
}


CONNECT M2HoleD LM2X
AMS.DN.M2 { @ Min. Hole density for metal lines that need to apply slot  1.5%
    NET AREA RATIO LM2X M2HoleD < 0.015
	[ AREA(M2HoleD) / AREA(LM2X) ] RDB M2Hole.density2 LM2X M2HoleD 
}
DISCONNECT

M3EXD = M3xd NOT SLT_EXD

//M3 SLOT CHECKS
//==============
M3InnerHole = HOLES M3EXD INNER
M3BigHole   = SIZE M3InnerHole BY -MHOLE/2
M3Hole      = M3InnerHole OUTSIDE M3BigHole 
M3HoleSpace = M3Hole NOT M3EXD
FIM3c       = M3EXD OR M3HoleSpace
LM3XA       = (SIZE (SIZE FIM3c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM3c
LM3X        = ENCLOSE RECTANGLE LM3XA 35.005 35.005
M3HoleD    = M3HoleSpace AND LM3X

AMS.1.M3 { @ Wide Metal (>35um) must have slot.
  A = (SIZE ( SIZE M3EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M3EXD
  ENCLOSE RECTANGLE A 35.005 35.005
}


CONNECT M3HoleD LM3X
AMS.DN.M3 { @ Min. Hole density for metal lines that need to apply slot  1.5%
    NET AREA RATIO LM3X M3HoleD < 0.015
	[ AREA(M3HoleD) / AREA(LM3X) ] RDB M3Hole.density2 LM3X M3HoleD 
}
DISCONNECT

M4EXD = M4xd NOT SLT_EXD

//M4 SLOT CHECKS
//==============
M4InnerHole = HOLES M4EXD INNER
M4BigHole   = SIZE M4InnerHole BY -MHOLE/2
M4Hole      = M4InnerHole OUTSIDE M4BigHole 
M4HoleSpace = M4Hole NOT M4EXD
FIM4c       = M4EXD OR M4HoleSpace
LM4XA       = (SIZE (SIZE FIM4c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM4c
LM4X        = ENCLOSE RECTANGLE LM4XA 35.005 35.005
M4HoleD    = M4HoleSpace AND LM4X

AMS.1.M4 { @ Wide Metal (>35um) must have slot.
  A = (SIZE ( SIZE M4EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M4EXD
  ENCLOSE RECTANGLE A 35.005 35.005
}


CONNECT M4HoleD LM4X
AMS.DN.M4 { @ Min. Hole density for metal lines that need to apply slot  1.5%
    NET AREA RATIO LM4X M4HoleD < 0.015
	[ AREA(M4HoleD) / AREA(LM4X) ] RDB M4Hole.density2 LM4X M4HoleD 
}
DISCONNECT

M5EXD = M5xd NOT SLT_EXDT
//M5 SLOT CHECKS
//==============
M5InnerHole = HOLES M5EXD INNER
M5BigHole   = SIZE M5InnerHole BY -MHOLE/2
M5Hole      = M5InnerHole OUTSIDE M5BigHole 
M5HoleSpace = M5Hole NOT M5EXD
FIM5c       = M5EXD OR M5HoleSpace
LM5XA       = (SIZE (SIZE FIM5c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM5c
LM5X        = ENCLOSE RECTANGLE LM5XA 35.005 35.005
M5HoleD    = M5HoleSpace AND LM5X

AMS.1.M5 { @ Wide Metal (>35um) must have slot.
  A = (SIZE ( SIZE M5EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M5EXD
  ENCLOSE RECTANGLE A 35.005 35.005
}


CONNECT M5HoleD LM5X
AMS.DN.M5 { @ Min. Hole density for metal lines that need to apply slot  1.5%
    NET AREA RATIO LM5X M5HoleD < 0.015
	[ AREA(M5HoleD) / AREA(LM5X) ] RDB M5Hole.density2 LM5X M5HoleD 
}
DISCONNECT

PAD_EXD6 = SIZE PAD_EXD BY 2 INSIDE OF M6xd STEP 0.32 
M6EXD = M6xd NOT ( SLT_EXDT OR PAD_EXD6 )
//M6 SLOT CHECKS
//==============
M6InnerHole = HOLES M6EXD INNER
M6BigHole   = SIZE M6InnerHole BY -MHOLE/2
M6Hole      = M6InnerHole OUTSIDE M6BigHole 
M6HoleSpace = M6Hole NOT M6EXD
FIM6c       = M6EXD OR M6HoleSpace
LM6XA       = (SIZE (SIZE FIM6c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM6c
LM6X        = ENCLOSE RECTANGLE LM6XA 35.005 35.005
M6HoleD    = M6HoleSpace AND LM6X

AMS.1.M6 { @ Wide Metal (>35um) must have slot.
  A = (SIZE ( SIZE M6EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M6EXD
  ENCLOSE RECTANGLE A 35.005 35.005
}


CONNECT M6HoleD LM6X
AMS.DN.M6 { @ Min. Hole density for metal lines that need to apply slot  1.5%
    NET AREA RATIO LM6X M6HoleD < 0.015
	[ AREA(M6HoleD) / AREA(LM6X) ] RDB M6Hole.density2 LM6X M6HoleD 
}
DISCONNECT



//MD SLOT CHECKS
//==============
// Bonding pad, chip corner dummy pad, and inductor need not put slot

UBM_EXDD    = SIZE UBMi BY 2 INSIDE OF MDxd STEP 0.32 	// For RDL
MDEXD       = MDxd NOT ( DPDMY OR UBM_EXDD )
MDInnerHole = HOLES MDEXD INNER
MDBigHole   = SIZE MDInnerHole BY -5  	// Holes with width less than 10um will be filled back
MDHole      = MDInnerHole OUTSIDE MDBigHole	
MDHoleSpace = MDHole NOT MDEXD
FIMDc       = MDEXD OR MDHoleSpace
LMDXA       = (SIZE (SIZE FIMDc BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIMDc
LMDX        = ENCLOSE RECTANGLE LMDXA 35.005 35.005 
MDHoleD     = MDHoleSpace AND LMDX
AMS.1.MD { @ Wide Metal (>35um) must have slot
  A = (SIZE ( SIZE MDEXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5) AND MDEXD
  ENCLOSE RECTANGLE A 35.005 35.005    
}

CONNECT MDHoleD LMDX
AMS.DN.MD { @ Min. Hole density for metal lines that need to apply slot  1.5%
  NET AREA RATIO LMDX MDHoleD < 0.015
    [ AREA(MDHoleD) / AREA(LMDX) ] RDB MDHole.density2 LMDX MDHoleD 
}
DISCONNECT







//I/O ESD Guidance 
//================

EPACT = (SDI AND PACT) NOT DIODUMMY
ENACT = (SDI AND NACT) NOT DIODUMMY
ECO = ((SDI AND CO) AND OD) NOT DIODUMMY
EPMOS = EPACT ENCLOSE ALL_GATE
ENMOS = ENACT ENCLOSE ALL_GATE
EGTE = (SDI AND ALL_GATE) NOT DIODUMMY
EGTE_W = EGTE INSIDE EDGE OD
EPSD = EPMOS NOT EGTE
ENSD = ENMOS NOT EGTE
ENSD_NCO = (ENSD NOT INTERACT ECO) NOT INTERACT PTAP
EPSD_NCO = (EPSD NOT INTERACT ECO) NOT INTERACT NTAP
ENSD_WCO = ENSD NOT ENSD_NCO
EPSD_WCO = EPSD NOT EPSD_NCO
ENSD_SRC = ENSD_WCO OUTSIDE RPO
PCL_ENMOS = ENMOS NOT INTERACT RPO

CONNECT ENSD NSDi
CONNECT EPSD PSDi
PTAP_real = PTAPi NOT DIODUMMY
NTAP_real = NTAPi NOT DIODUMMY

ENSD_SOURCE_pre = NET AREA RATIO ENSD PTAP_real > 0 INSIDE OF LAYER PWELi [!!AREA(ENSD)*!!AREA(PTAP_real)]
EPSD_SOURCE_pre = NET AREA RATIO EPSD NTAP_real > 0 INSIDE OF LAYER NWELi [!!AREA(EPSD)*!!AREA(NTAP_real)]

ENSD_SOURCE = ENSD_SOURCE_pre OR ((ENSD NOT PCL_ENMOS) OUTSIDE RPO)
EPSD_SOURCE = EPSD_SOURCE_pre OR (EPSD OUTSIDE RPO)
ENSD_DRAIN = ENSD NOT ENSD_SOURCE
EPSD_DRAIN = EPSD NOT EPSD_SOURCE
ENSD_DRAINc = ENSD_DRAIN INTERACT ECO
EPSD_DRAINc = EPSD_DRAIN INTERACT ECO
ENMOSc = STAMP ENMOS BY ENSD_DRAINc
EPMOSc = STAMP EPMOS BY EPSD_DRAINc

ESD_PMOS_GATE_W = EGTE_W INSIDE EDGE PP
ESD_NMOS_GATE_W = ((EGTE NOT INTERACT PCL_ENMOS) INSIDE EDGE OD) INSIDE EDGE NP
ESD_PCL_GATE_W = (((EGTE INTERACT PCL_ENMOS) INSIDE EDGE OD) NOT INSIDE EDGE OD2) INSIDE EDGE NP
ESD_PCL_HV_GATE_W = (((EGTE INTERACT PCL_ENMOS) INSIDE EDGE OD) INSIDE EDGE OD2) INSIDE EDGE NP
ESD_PMOS_GATE_W_EXP = EXPAND EDGE ESD_PMOS_GATE_W OUTSIDE BY GRID
ESD_NMOS_GATE_W_EXP = EXPAND EDGE ESD_NMOS_GATE_W OUTSIDE BY GRID
ESD_PCL_GATE_W_EXP = EXPAND EDGE ESD_PCL_GATE_W OUTSIDE BY GRID
ESD_PCL_HV_GATE_W_EXP = EXPAND EDGE ESD_PCL_HV_GATE_W OUTSIDE BY GRID
ESD_PMOS_GATE_W_EXPc = STAMP ESD_PMOS_GATE_W_EXP BY EPSD_DRAINc
ESD_NMOS_GATE_W_EXPc = STAMP ESD_NMOS_GATE_W_EXP BY ENSD_DRAINc
ESD_PCL_GATE_W_EXPc = STAMP ESD_PCL_GATE_W_EXP BY ENSD_DRAINc
ESD_PCL_HV_GATE_W_EXPc = STAMP ESD_PCL_HV_GATE_W_EXP BY ENSD_DRAINc


ESD1_GATE = EGTE AND ESD1DMY
ESD1_NCS_GATE = ESD1_GATE NOT INTERACT ENSD_NCO
ESD1_TOL = (ENMOS AND ESD1DMY) INTERACT ENSD_NCO
ESD1_NCS = (ENMOS AND ESD1DMY) NOT INTERACT ENSD_NCO
ENSD_NCO_ESD1DMY = ENSD_NCO INTERACT ESD1DMY
ESD1_TOL_GATE = EGTE INTERACT ENSD_NCO_ESD1DMY
ESD1_TOL_GATE1 = ESD1_TOL_GATE NOT INTERACT ENSD_SRC
ESD1_TOL_GATE2 = ESD1_TOL_GATE INTERACT ENSD_SRC
ESD1_NCS_GATE_W = ESD1_NCS_GATE INSIDE EDGE OD
ESD1_TOL_GATE1_W = ESD1_TOL_GATE1 INSIDE EDGE OD
ESD1_TOL_GATE2_W = ESD1_TOL_GATE2 INSIDE EDGE OD

ESD2_GATE = EGTE AND ESD2DMY
ESD2_REG_GATE = ESD2_GATE NOT INTERACT ENSD_NCO
ESD2_TOL_GATE = ESD2_GATE INTERACT ENSD_NCO
ESD2_TOL_GATE1 = ESD2_TOL_GATE NOT INTERACT ENSD_SRC
ESD2_TOL_GATE2 = ESD2_TOL_GATE INTERACT ENSD_SRC
ESD2_TOL = (ENMOS AND ESD2DMY) INTERACT ENSD_NCO
ESD2_REG = (ENMOS AND ESD2DMY) NOT INTERACT ENSD_NCO
ESD2_REG_GATE_W = ESD2_REG_GATE INSIDE EDGE OD
ESD2_TOL_GATE1_W = ESD2_TOL_GATE1 INSIDE EDGE OD
ESD2_TOL_GATE2_W = ESD2_TOL_GATE2 INSIDE EDGE OD

RPO1 = ((RPO AND SDI) OUTSIDE ESD1DMY) OUTSIDE ESD2DMY

EGTE1 = ((EGTE OUTSIDE ESD1DMY) OUTSIDE ESD2DMY) NOT INTERACT ENSD_NCO
EGTE1_W = EGTE1 INSIDE EDGE OD

ERPO = RPO AND SDI
ERPOH = HOLES ERPO
ERPOA = ERPOH OR ERPO
ECOS = ECO OUTSIDE ERPOA
HEGT = EGTE AND OD2
LEGT = EGTE NOT OD2
HEGN = HEGT AND NP
HEGP = HEGT AND PP

#IFDEF GUIDELINE_ESD


// For ESD.1g
//=============
PMOSi = (PACTi INTERACT POLYi) INTERACT COi 
NMOSi = (NACTi INTERACT POLYi) INTERACT COi

NSDk_HVMOS = (NSDk INTERACT NMOSi) INTERACT OD2
NSDk_LVMOS = (NSDk INTERACT NMOSi) NOT INTERACT OD2
PSDk_HVMOS = (PSDk INTERACT PMOSi) INTERACT OD2
PSDk_LVMOS = (PSDk INTERACT PMOSi) NOT INTERACT OD2

NSDk_HVMOS_SDI = NSDk_HVMOS INTERACT SDI 
NSDk_LVMOS_SDI = NSDk_LVMOS INTERACT SDI 
PSDk_HVMOS_SDI = PSDk_HVMOS INTERACT SDI 
PSDk_LVMOS_SDI = PSDk_LVMOS INTERACT SDI

HV_GATEk = STAMP HVGT BY ILP1k
LV_GATEk = STAMP LVGT BY ILP1k


ESD.1g { @ Use thin oxide transistor for thin oxide power clamp and thin oxide I/O buffers; 
		 @ Use thick oxide transistor for the thick oxide Power Clamp and thick oxide I/O buffers.
		 @ DRC only flag ((MOS INTERACT OD2) INTERACT SDI) connected to (MOS NOT INTERACT OD2).
		 @ DRC will exclude D/S/G connected to PWSTRAP.
  NET AREA RATIO NSDk_HVMOS_SDI NSDk_LVMOS PSDk_LVMOS LV_GATEk PTAPk > 0 
	[!!AREA(NSDk_HVMOS_SDI)*!AREA(PTAPk)*(!!AREA(NSDk_LVMOS)+!!AREA(PSDk_LVMOS)+!!AREA(LV_GATEk))] 
	RDB ESD.1g.hv_n.rep NSDk_HVMOS_SDI NSDk_LVMOS PSDk_LVMOS LV_GATEk
  NET AREA RATIO PSDk_HVMOS_SDI NSDk_LVMOS PSDk_LVMOS LV_GATEk PTAPk > 0
	[!!AREA(PSDk_HVMOS_SDI)*!AREA(PTAPk)*(!!AREA(NSDk_LVMOS)+!!AREA(PSDk_LVMOS)+!!AREA(LV_GATEk))]
    RDB ESD.1g.hv_p.rep PSDk_HVMOS_SDI NSDk_LVMOS PSDk_LVMOS LV_GATEk
}


ESD.7g { @ For same type OD of the I/O buffer and Power Clamp should be surrounded by a guard-ring. 
		 @ All other type ODs should be placed outside this guard-ring.
  EPMOS NOT INSIDE NTAP_guard_ring_hole 
  ENMOS NOT INSIDE PTAP_guard_ring_hole 
}

ESD.9g { @ The OD area of the edge side of I/O buffer and Power Clamp should be Source or Bulk rather than Drain 
		 @ to avoid an unwanted parasitic bipolar effect or an abnormal discharge path in ESD zapping.
		 @ DRC only flag (((OD INTERACT SDI) NOT PO) INTERACT one Gate) does not connect to STRAP.
  EDGE_NSD = NSDu INTERACT EGTE == 1
  NET AREA RATIO EDGE_NSD PTAPu > 0 [!!AREA(EDGE_NSD)*!AREA(PTAPu)]
  EDGE_PSD = PSDu INTERACT EGTE == 1
  NET AREA RATIO EDGE_PSD NTAPu > 0 [!!AREA(EDGE_PSD)*!AREA(NTAPu)]
}

VDD_CBk = NET AREA RATIO CBk NTAPk > 0
VSS_CBk = NET AREA RATIO CBk PTAPk > 0
VDD_UBMnk = NET AREA RATIO UBMnk NTAPk > 0
VSS_UBMnk = NET AREA RATIO UBMnk PTAPk > 0
VDD_UBMdk = NET AREA RATIO UBMdk NTAPk > 0
VSS_UBMdk = NET AREA RATIO UBMdk PTAPk > 0

CBk_DUMMY = CBk INTERACT VDD_VSS_DUMMY
UBMnk_DUMMY = UBMnk INTERACT VDD_VSS_DUMMY
UBMdk_DUMMY = UBMdk INTERACT VDD_VSS_DUMMY

IO_CBk  = ((CBk NOT VDD_CBk) NOT VSS_CBk)  NOT CBk_DUMMY 
IO_UBMnk  = ((UBMnk NOT VDD_UBMnk) NOT VSS_UBMnk)  NOT UBMnk_DUMMY
IO_UBMdk  = ((UBMdk NOT VDD_UBMdk) NOT VSS_UBMdk)  NOT UBMdk_DUMMY

PSDk_CB= NET AREA RATIO PSDk IO_CBk IO_UBMnk IO_UBMdk >0[!!AREA(IO_CBk)+AREA(IO_UBMnk)+!!AREA(IO_UBMdk)]
NSDk_CB= NET AREA RATIO NSDk IO_CBk IO_UBMnk IO_UBMdk >0[!!AREA(IO_CBk)+AREA(IO_UBMnk)+!!AREA(IO_UBMdk)]

NWELc = COPY NWEL
CONNECT NWELc
PWELc = COPY PWEL
CONNECT PWELc

ESD.10g { @ Except the ESD device, either of the following two condition must be followed.
		  @ 1. The space of two same type ODs >= ^ESD_10g um. 
		  @ 2. Two same type ODs should be separated by different type OD.    
		  @ The same type ODs are N+OD and N+OD in the same PW, or P+OD and P+OD in the same NW, which connect to two different Pad.
  PACT_CHECK = (PACT INTERACT PSDk_CB) NOT EPMOS 
  PACT_CHECK_CB = STAMP (PACT_CHECK INTERACT PSDk_CB == 1 BY NET) BY PSDk_CB
  P1 = EXT PACT_CHECK_CB < ESD_10g ABUT < 90 SINGULAR REGION NOT CONNECTED
  PACT_CHECK_NW = STAMP (PACT_CHECK INTERACT P1) BY NWELc
  P2 = EXT PACT_CHECK_NW < ESD_10g ABUT < 90 SINGULAR REGION CONNECTED
  ESD_P3 = P1 AND P2
  (ESD_P3 NOT NTAPi) INTERACT PACT_CHECK_CB > 1 BY NET
  PACT_CHECK INTERACT PSDk_CB > 1 BY NET

  NACT_CHECK = (NACT INTERACT NSDk_CB) NOT ENMOS 
  NACT_CHECK_CB = STAMP (NACT_CHECK INTERACT NSDk_CB == 1 BY NET) BY NSDk_CB
  N1 = EXT NACT_CHECK_CB < ESD_10g ABUT < 90 SINGULAR REGION NOT CONNECTED
  NACT_CHECK_PW = STAMP (NACT_CHECK INTERACT N1) BY PWELc
  N2 = EXT NACT_CHECK_PW < ESD_10g ABUT < 90 SINGULAR REGION CONNECTED
  ESD_N3 = N1 AND N2
  (ESD_N3 NOT PTAPi) INTERACT NACT_CHECK_CB > 1 BY NET  
  NACT_CHECK INTERACT NSDk_CB > 1 BY NET
}


ESD.3g { @ Total finger width for 5.0V, 3.3V, 2.5V, 1.8V and 1.5V N/PMOS I/O buffer in same connection of drain >= ^ESD_3g
A =	NET AREA RATIO ESD_PMOS_GATE_W_EXPc >= ESD_3g
		[AREA(ESD_PMOS_GATE_W_EXPc)/GRID]
EPMOS NOT INTERACT A
B =	NET AREA RATIO ESD_NMOS_GATE_W_EXPc >= ESD_3g
		[AREA(ESD_NMOS_GATE_W_EXPc)/GRID]
(ENMOS NOT INTERACT PCL_ENMOS) NOT INTERACT B
}
//ESD.4g is checked by ESD.3g
ESD.5g { @ Total finger width of 1.8V/1.5V NMOS based fully silicided type active Power Clamp in same connection
		 @ of drain. 1.8V/1.5V NMOS BigFET Lg only needs to follow process rules >= ^ESD_5g.
  NET AREA RATIO ESD_PCL_GATE_W_EXPc < ESD_5g
    [AREA(ESD_PCL_GATE_W_EXPc)/GRID]
    RDB ESD.5g.rep ESD_PCL_GATE_W_EXPc
}
ESD.5.1g { @ Total finger width for 3.3V/2.5V NMOS based fully silicided active type Power Clamp in same connection of drain >= ^ESD_5_1g um
		   @ 3.3V/2.5V NMOS BigFET Lg only needs follow process rules.
  NET AREA RATIO ESD_PCL_HV_GATE_W_EXPc < ESD_5_1g
    [AREA(ESD_PCL_HV_GATE_W_EXPc)/GRID]
    RDB ESD.5.1g.rep ESD_PCL_HV_GATE_W_EXPc
}

ESD.6g { @ Unit finger width of NMOS and PMOS for I/O buffer and power clamp device 15um <= width <= 60um.
  PATH LENGTH EGTE_W >0  < 15
  PATH LENGTH EGTE_W >60 < 999
}
// begin of ESD.8, butted or inserted pickup is not allowed
ESD.8g { @ It is strictly prohitibied to butting or inserted substrat/well pickups for ESD N/PMOS.
  
  EAct = EPACT OR ENACT
  DTap = NTAP OR PTAP
  EActUp3 = SIZE EAct BY 3 OUTSIDE OF DTap STEP 0.22*0.7
  D1 = DTap INTERACT EActUp3
  
  D1R1 = SHRINK D1 RIGHT BY 0.001
  D1R2 = D1 NOT D1R1 
  D1R3 = D1 COIN EDGE D1R2
  D1R4 = LENGTH D1R3 > 0.001
  D1R5 = EXT [D1R4] EAct < 3 ABUT < 90 OPPOSITE  
  D1L  = D1 WITH EDGE D1R5 
  D1L1 = SHRINK D1L LEFT BY 0.001
  D1L2 = D1L NOT D1L1 
  D1L3 = D1L COIN EDGE D1L2
  D1L4 = LENGTH D1L3 > 0.001
  D1L5 = EXT [D1L4] EAct < 3 ABUT < 90 OPPOSITE  
  D1X  = D1L WITH EDGE D1L5 
  D1T1 = SHRINK D1 TOP BY 0.001
  D1T2 = D1 NOT D1T1 
  D1T3 = D1 COIN EDGE D1T2
  D1T4 = LENGTH D1T3 > 0.001
  D1T5 = EXT [D1T4] EAct < 3 ABUT < 90 OPPOSITE  
  D1B  = D1 WITH EDGE D1T5 
  D1B1 = SHRINK D1B BOTTOM BY 0.001
  D1B2 = D1B NOT D1B1 
  D1B3 = D1B COIN EDGE D1B2
  D1B4 = LENGTH D1B3 > 0.001
  D1B5 = EXT [D1B4] EAct < 3 ABUT < 90 OPPOSITE  
  D1Y  = D1B WITH EDGE D1B5
  DTap2Check=D1X OR D1Y
  
  DTapHole = HOLES DTap2Check INNER
  DTapSuspect = DTap2Check NOT TOUCH DTapHole
  ENCLOSE RECTANGLE DTapSuspect 0.22 20
}


#IFDEF 1.5V
ESD.18g_1.5V { @ Minimum 1.5V IO ESD NMOS/PMOS gate length >=0.2um
  INT LEGT < 0.2 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFDEF 1.8V
ESD.18g_1.8V { @ Minimum 1.8V IO ESD NMOS/PMOS gate length >=0.25um
  INT LEGT < 0.25 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFDEF 2.5V
ESD.18g_2.5V_N { @ Minimum 2.5V IO ESD NMOS gate length >= 0.3um
  INT HEGN < 0.3 ABUT < 90 SINGULAR REGION
}
ESD.18g_2.5V_P { @ Minimum 2.5V IO ESD PMOS gate length >= 0.26um
  INT HEGP < 0.26 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFDEF 3.3V
ESD.18g_3.3V_N { @ Minimum 3.3V IO ESD NMOS gate length >= 0.4um
  INT HEGN < 0.4 ABUT < 90 SINGULAR REGION
}
ESD.18g_3.3V_P { @ Minimum 3.3V IO ESD PMOS gate length >= 0.3um
  INT HEGP < 0.3 ABUT < 90 SINGULAR REGION
}
#ENDIF

#IFDEF 5V
HEGN1 = HEGN INTERACT ESD
HEGN2 = HEGN NOT HEGN1
ESD.18g_5V_NESD { @ Minimum 5.0V IO ESD NMOS(without ESD implant)/PMOS gate length >= 0.6um
  INT HEGN2 < 0.6 ABUT<90 SINGULAR REGION
}
ESD.18g_5V_P { @ Minimum 5.0V IO ESD NMOS(without ESD implant)/PMOS gate length >= 0.6um
  INT HEGP < 0.6 ABUT<90 SINGULAR REGION
}
ESD.18g_5V_WESD { @ Minimum 5.0V IO ESD NMOS (with ESD implant) gate length >=0.9um
  INT HEGN1 < 0.9 ABUT<90 SINGULAR REGION
}
#ENDIF


ESD.19g { @ NMOS and PMOS of I/O buffer should have a nonsalicide area on drain side, that is, RPO mask should
          @ block drain side of device (except contact region should keep silicided).
   ( EGTE INSIDE EPMOS ) NOT INTERACT ( EPSD INTERACT RPO )
   ( EGTE INSIDE ( ENMOS INTERACT RPO)) NOT INTERACT ( ENSD INTERACT RPO )
}
ESD.20g { @ For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b)
          @ RPO should cover all inactive poly gates and extend to active region (Poly spacing==0.25um). 
          @ Minimum and maximum overlap from RPO to the active poly gate 0.05um or 0.06um
  X = ESD2_TOL_GATE NOT RPO
  ESD2_TOL NOT INTERACT X
  ESD2_TOL_GATE2 OUTSIDE RPO
  ESD2_TOL_GATE1 NOT RPO
  INT ESD2_TOL_GATE2 RPO < 0.05 ABUT < 90 OPPOSITE REGION
  ESD2_TOL_GATE_RPO = ESD2_TOL_GATE CUT RPO
  ESD2_TOL_GATE_RPO_CH = ESD2_TOL_GATE_RPO AND RPO
  A = SIZE ESD2_TOL_GATE_RPO_CH BY 0.025 UNDEROVER
  INT A < 0.06 ABUT < 90 OPPOSITE REGION
  SIZE A BY 0.03 UNDEROVER
}
ESD.20g_A { @ For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b)
          @ RPO should cover all inactive poly gates and extend to active region (Poly spacing==0.25um). 
          @ Minimum and maximum overlap from RPO to the active poly gate by 0.05um
  X = ENSD_NCO INTERACT ESD2DMY
  INT X < 0.25 ABUT < 90 REGION	  
  SIZE X BY 0.25/2 UNDEROVER
}

ESD.21g { @ For regular I/O designed by 5V, 3.3V, 2.5V, 1.8V and 1.5V NMOS (see N3 in Fig.6a)
    	  @ Minimum and maximum overlap from RPO on the drain side to the active poly gate 0.05um or 0.06um
  X = ESD2_REG_GATE NOT RPO
  ESD2_REG NOT INTERACT X
  ESD2_REG_GATE OUTSIDE RPO
  INT ESD2_REG_GATE RPO < 0.05 ABUT < 90 OPPOSITE REGION 
  ESD2_REG_GATE_RPO = ESD2_REG_GATE CUT RPO
  ESD2_REG_GATE_RPO_CH = ESD2_REG_GATE_RPO AND RPO
  A = SIZE ESD2_REG_GATE_RPO_CH BY 0.025 UNDEROVER
  INT A < 0.06 ABUT < 90 OPPOSITE REGION
  SIZE A BY 0.03 UNDEROVER
}
// ESD.22g is checked by ESD.21g
// ESD.23g is checked by ESD.21g
ESD.24g { @ The minimum width of RPO on drain side (X) for 5V,3.3V, 2.5V, 1.8V and 1.5V NMOS and PMOS.
    	  @ exclude 1.8V and 1.5V NMOS when used as power clamp device>=1.95um 
  X = ((ENSD_WCO OR EPSD_WCO ) AND ESD2DMY) AND RPO
  Y = EGTE COIN OUTSIDE EDGE X
  Z = RPO COIN INSIDE EDGE X 
  ENC Y Z < 1.95 ABUT < 90 REGION 
}
ESD.25g { @ The minimum clearance from poly edge to CO edge on source side for NMOS and PMOS (Except ESD.26g)>=0.5um
  X = ECOS AND ((ENMOS OR EPMOS ) INTERACT RPO)     
  EXT X EGTE_W < 0.5 ABUT < 90 OPPOSITE REGION
  Y = ECO AND ESD1_NCS
  EXT Y EGTE_W < 0.5 ABUT < 90 OPPOSITE REGION
}
ESD.26g { @ The minimum clearance of poly edge to CO edge on D/S side for 3.3V/2.5V/1.8V and 1.5V power clamp device>=0.25um 
  X = ECO AND ( ENMOS NOT INTERACT RPO)
  EXT X EGTE_W < 0.25 ABUT < 90 OPPOSITE REGION    
}

ESD.27g { @ For RPO DRC purpose,we need a dummy layers in ESD protection device.layers should cover all ESD protection devices.
          @ ESD2DMY is for the cascade NMOS in high voltage tolerant I/O designed by 3.3V/2.5V NMOS (see Fig.5b), regular IO designed by
	  @ 5V/3.3V/2.5V/1.8V/1.5V NMOS and PMOS (see Fig.6b), power clmap designed by 5V/3.3V/2.5V NMOS.
   X = EGTE CUT RPO
   ( EGTE INSIDE ( ENMOS ENCLOSE X )) NOT ESD2DMY
   ( EGTE INSIDE ( EPMOS ENCLOSE X )) NOT ESD2DMY
}
#IFNDEF 5V
ESD.28g { @ ESD implant is required for High Voltage Tolerant I/O designed by 3.3V NMOS device for 5V signal 
    	  @ input or 2.5V NMOS device for 3.3V signal input at I/O pad. ESD mask (No. 111) can be generated by 
	  @ logical operation. It is not allowed to use ESD mask (No. 111) for 5V NMOS device.
	  @ ESD3DMY or ESDIMP is for the cascade NMOS in high voltage tolerant I/O designed by 3.3V/2.5V NMOS (see Fig.5b). 
	(( ENMOS ENCLOSE LEGT ) INTERACT ESD2DMY) INTERACT (ESD3DMY OR ESDIMP)
	(( ENMOS ENCLOSE (ESD2_TOL_GATE AND OD2 )) NOT ESD3DMY ) NOT INTERACT ESDIMP
	ESD3DMY AND GATE_PP
	ESDIMP INTERACT EPMOS
}
#ENDIF
// ESD.29g is checked by ESD.19g
ESD.30g { @ For regular 1.8V I/O in NMOS region : Minumum clearance from RPO to poly spacing >=0.45um.
  EXT RPO1 EGTE1_W < 0.45 ABUT < 90 OPPOSITE REGION
  EGTE1 AND RPO1
}
//ESD.31g is checked by ESD.30g
ESD.32g { @The minimum width of RPO on drain side (X) for 1.8V NMOS and 5V/3.3V/1.8V/1.5V PMOS.>=1.5um
  Y = RPO1 INSIDE EDGE OD
  INT Y < 1.5 ABUT < 90 REGION
}
//ESD.33g is checked by ESD.25g
ESD.34g { @ 5V, 3.3V and 2.5V NMOS devices when used as power clamp devices, the RPO can fully cover the 
    	  @ uncontacted poly gate, source/drain (except contact region should keep silicided). 
  ( ENMOS INTERACT ESD1DMY ) NOT ERPOA        
}

NCS_SD_1 = ((OD INTERACT EGTE) NOT POLY) AND ESD1DMY
NCS_SD = STAMP NCS_SD_1 BY NSDi
NCS_S  = NET AREA RATIO NCS_SD PTAPi >0
NCS_D  = NCS_SD NOT NCS_S
ESD.35g{ @ Minimum width of RPO on drain side (X) for 5V, 3.3V and 2.5V NMOS devices when used as power clamp 
    	 @ devices. Ncs Drain is defined as (((OD INTERACT GATE) NOT PO) AND ESD1DMY) 
	 @ which not connect to PW Pickup.>=1.95um
  X = NCS_D AND RPO 
  Y = EGTE COIN OUTSIDE EDGE NCS_D
  Z = RPO COIN INSIDE EDGE X 
  ENC Y Z < 1.95 ABUT < 90 REGION 
  
}
//ESD.36g is checked by ESD.25g

ESD.37g { @  For RPO DRC purpose, we need a dummy layers for 5V, 3.3Vand 2.5V NMOS devices when used as power 
    	  @  clamp devices. The layers should cover all ESD protection devices.   
   X = EGTE NOT INSIDE RPO
   Y = ENMOS NOT ENCLOSE X
   Y NOT INTERACT ESD1DMY
   ESD1DMY AND GATE_PP
   ( EGTE INSIDE (ENMOS ENCLOSE ESD1_GATE)) NOT ESD1DMY // ESD1DMY should cover all EGTE in new design rule.
}
//ESD.38g is checked by ESD.3g
//ESD.39g IS checked by ESD.3g


ESD.WARN.1 { @ CO can't inserted between gate and RPO for 1.8V NMOS and all PMOS I/O pattern.
  RED  = (EPSD OR ENSD) INTERACT RPO1
  XRPO = RED NOT RPO1
  XRPG = XRPO TOUCH EGTE1
  XRPG INTERACT ECO
}

#IFDEF 5V
ESD.WARN.2 { @ ESD3DMY OR ESDIMP is not allowed in 5V process.
  COPY ESD3DMY
  COPY ESDIMP
}
#ENDIF
#IFNDEF 5V
ESD.WARN.3 { @ ESD is not allowed in processes except 5V.    
  COPY ESD
}
#ENDIF
#IFDEF FULL_CHIP
ESD.WARN.4 { @ SDI (122;0) needs to be found in each of power, ground, or I/O pad of CB, CB2, and UBM. Exception: SEALRING_ALL   
   ESD_NSDiu = NSDiu AND ((SDI OR HIADMY) OR DIODUMMY)
   ESD_PSDiu = PSDiu AND ((SDI OR HIADMY) OR DIODUMMY)
   ESD_PTAPiu = PTAPiu AND ((SDI OR HIADMY) OR DIODUMMY)
   ESD_NTAPiu = NTAPiu AND ((SDI OR HIADMY) OR DIODUMMY)

   VDD_NSDiu = NSDiu AND SDI
   VDD_PSDiu = PSDiu AND SDI
   VDD_PTAPiu = PTAPiu AND SDI
   VDD_NTAPiu = NTAPiu AND SDI
   CB_NOT_DUMMY = CBiu AND (NET AREA RATIO CBiu OVER COiu > 0)
   UBMn_NOT_DUMMY = UBMniu AND (NET AREA RATIO UBMniu OVER COiu > 0)
   UBMd_NOT_DUMMY = UBMdiu AND (NET AREA RATIO UBMdiu OVER COiu > 0)
#IFDEF CHECK_LATCHUP_BY_TEXT
    PAD_VDD_CB = NET AREA RATIO CB_NOT_DUMMY OVER  PWR_M1iu_BY_TEXT  PWR_M2iu_BY_TEXT  PWR_M3iu_BY_TEXT  PWR_M4iu_BY_TEXT  PWR_M5iu_BY_TEXT  PWR_M6iu_BY_TEXT  PWR_MDiu_BY_TEXT  > 0
    PAD_IOVSS_CB = NET AREA RATIO CB_NOT_DUMMY OVER  IO_M1iu_BY_TEXT  IO_M2iu_BY_TEXT  IO_M3iu_BY_TEXT  IO_M4iu_BY_TEXT  IO_M5iu_BY_TEXT  IO_M6iu_BY_TEXT  GND_M1iu_BY_TEXT  GND_M2iu_BY_TEXT  GND_M3iu_BY_TEXT  GND_M4iu_BY_TEXT  GND_M5iu_BY_TEXT  GND_M6iu_BY_TEXT  IO_MDiu_BY_TEXT GND_MDiu_BY_TEXT > 0
#ELSE
   PAD_VDD_CB = NET AREA RATIO CB_NOT_DUMMY OVER VDD_CB CB_VDD_DUMMY > 0 
   PAD_IOVSS_CB = NET AREA RATIO CB_NOT_DUMMY OVER VDD_CB CB_VDD_DUMMY == 0 
#ENDIF // CHECK_LATCHUP_BY_TEXT
   MERGE ((NET AREA RATIO PAD_VDD_CB OVER VDD_NSDiu VDD_PSDiu VDD_PTAPiu VDD_NTAPiu== 0) NOT SEALRING_ALL)
   MERGE ((NET AREA RATIO PAD_IOVSS_CB OVER ESD_NSDiu ESD_PSDiu ESD_PTAPiu ESD_NTAPiu== 0) NOT SEALRING_ALL)
#IFDEF CHECK_LATCHUP_BY_TEXT
    PAD_VDD_UBMn = NET AREA RATIO UBMn_NOT_DUMMY OVER  PWR_M1iu_BY_TEXT  PWR_M2iu_BY_TEXT  PWR_M3iu_BY_TEXT  PWR_M4iu_BY_TEXT  PWR_M5iu_BY_TEXT  PWR_M6iu_BY_TEXT  PWR_MDiu_BY_TEXT  > 0
    PAD_IOVSS_UBMn = NET AREA RATIO UBMn_NOT_DUMMY OVER  IO_M1iu_BY_TEXT  IO_M2iu_BY_TEXT  IO_M3iu_BY_TEXT  IO_M4iu_BY_TEXT  IO_M5iu_BY_TEXT  IO_M6iu_BY_TEXT  GND_M1iu_BY_TEXT  GND_M2iu_BY_TEXT  GND_M3iu_BY_TEXT  GND_M4iu_BY_TEXT  GND_M5iu_BY_TEXT  GND_M6iu_BY_TEXT  IO_MDiu_BY_TEXT GND_MDiu_BY_TEXT > 0
#ELSE
   PAD_VDD_UBMn = NET AREA RATIO UBMn_NOT_DUMMY OVER VDD_UBMn UBMn_VDD_DUMMY > 0 
   PAD_IOVSS_UBMn = NET AREA RATIO UBMn_NOT_DUMMY OVER VDD_UBMn UBMn_VDD_DUMMY == 0 
#ENDIF // CHECK_LATCHUP_BY_TEXT
   MERGE ((NET AREA RATIO PAD_VDD_UBMn OVER VDD_NSDiu VDD_PSDiu VDD_PTAPiu VDD_NTAPiu== 0) NOT SEALRING_ALL)
   MERGE ((NET AREA RATIO PAD_IOVSS_UBMn OVER ESD_NSDiu ESD_PSDiu ESD_PTAPiu ESD_NTAPiu== 0) NOT SEALRING_ALL)
#IFDEF CHECK_LATCHUP_BY_TEXT
    PAD_VDD_UBMd = NET AREA RATIO UBMd_NOT_DUMMY OVER  PWR_M1iu_BY_TEXT  PWR_M2iu_BY_TEXT  PWR_M3iu_BY_TEXT  PWR_M4iu_BY_TEXT  PWR_M5iu_BY_TEXT  PWR_M6iu_BY_TEXT  PWR_MDiu_BY_TEXT  > 0
    PAD_IOVSS_UBMd = NET AREA RATIO UBMd_NOT_DUMMY OVER  IO_M1iu_BY_TEXT  IO_M2iu_BY_TEXT  IO_M3iu_BY_TEXT  IO_M4iu_BY_TEXT  IO_M5iu_BY_TEXT  IO_M6iu_BY_TEXT  GND_M1iu_BY_TEXT  GND_M2iu_BY_TEXT  GND_M3iu_BY_TEXT  GND_M4iu_BY_TEXT  GND_M5iu_BY_TEXT  GND_M6iu_BY_TEXT  IO_MDiu_BY_TEXT GND_MDiu_BY_TEXT > 0
#ELSE
   PAD_VDD_UBMd = NET AREA RATIO UBMd_NOT_DUMMY OVER VDD_UBMd UBMd_VDD_DUMMY > 0 
   PAD_IOVSS_UBMd = NET AREA RATIO UBMd_NOT_DUMMY OVER VDD_UBMd UBMd_VDD_DUMMY == 0 
#ENDIF // CHECK_LATCHUP_BY_TEXT
   MERGE ((NET AREA RATIO PAD_VDD_UBMd OVER VDD_NSDiu VDD_PSDiu VDD_PTAPiu VDD_NTAPiu== 0) NOT SEALRING_ALL)
   MERGE ((NET AREA RATIO PAD_IOVSS_UBMd OVER ESD_NSDiu ESD_PSDiu ESD_PTAPiu ESD_NTAPiu== 0) NOT SEALRING_ALL)
}
#ENDIF

ESD.WARN.5 { @ SDI encloure of ACTIVE >= 0
  (DACT INTERACT SDI) NOT SDI
}


ESD.40g { @ It is not allowed to use OD resistors or NW resistors connected to IO PAD 
  NWR_T   = (NWELi INTERACT RWDMY) NOT RWDMY
  NWRkT = STAMP NWR_T BY COk
  ODRES_a    = ODRES_ALL AND RPDUMMY
  ODR_T = ((OD NOT POLY) INTERACT ODRES_a) NOT ODRES_a
  ODRkT = STAMP ODR_T BY COk
#IFNDEF CHECK_LATCHUP_BY_TEXT
  NET AREA RATIO ODRkT IO_CBk IO_UBMnk IO_UBMdk > 0 [!!AREA(ODRkT)*(!!AREA(IO_CBk)+!!AREA(IO_UBMnk)+!!AREA(IO_UBMdk))] 
  NET AREA RATIO NWRkT IO_CBk IO_UBMnk IO_UBMdk > 0 [!!AREA(NWRkT)*(!!AREA(IO_CBk)+!!AREA(IO_UBMnk)+!!AREA(IO_UBMdk))]
#ENDIF


#IFDEF CHECK_LATCHUP_BY_TEXT
ODRkT_IOPAD = NET AREA RATIO ODRkT IO_CBk IO_UBMnk IO_UBMdk > 0
[!!AREA(ODRkT)*(!!AREA(IO_CBk)+!!AREA(IO_UBMnk)+!!AREA(IO_UBMdk))]
NWRkT_IOPAD = NET AREA RATIO NWRkT IO_CBk IO_UBMnk IO_UBMdk > 0
[!!AREA(NWRkT)*(!!AREA(IO_CBk)+!!AREA(IO_UBMnk)+!!AREA(IO_UBMdk))]

ODRkT_PAD_TEXT =
   NET AREA RATIO ODRkT OVER   PAD_M1k_BY_TEXT    PAD_M2k_BY_TEXT    PAD_M3k_BY_TEXT    PAD_M4k_BY_TEXT    PAD_M5k_BY_TEXT    PAD_M6k_BY_TEXT    PAD_MDk_BY_TEXT> 0

ODRkT_VDD_VSS_PAD_TEXT =
   NET AREA RATIO ODRkT OVER   PWR_M1k_BY_TEXT    PWR_M2k_BY_TEXT    PWR_M3k_BY_TEXT    PWR_M4k_BY_TEXT    PWR_M5k_BY_TEXT    PWR_M6k_BY_TEXT     GND_M1k_BY_TEXT   GND_M2k_BY_TEXT   GND_M3k_BY_TEXT   GND_M4k_BY_TEXT   GND_M5k_BY_TEXT   GND_M6k_BY_TEXT   PWR_MDk_BY_TEXT GND_MDk_BY_TEXT> 0
ODRkT_VDD_VSS_PAD_DUMMY = NET AREA RATIO ODRkT OVER CBk_DUMMY UBMnk_DUMMY UBMdk_DUMMY >0


NWRkT_PAD_TEXT =
   NET AREA RATIO NWRkT OVER   PAD_M1k_BY_TEXT    PAD_M2k_BY_TEXT    PAD_M3k_BY_TEXT    PAD_M4k_BY_TEXT    PAD_M5k_BY_TEXT    PAD_M6k_BY_TEXT    PAD_MDk_BY_TEXT> 0

NWRkT_VDD_VSS_PAD_TEXT =
   NET AREA RATIO NWRkT OVER   PWR_M1k_BY_TEXT    PWR_M2k_BY_TEXT    PWR_M3k_BY_TEXT    PWR_M4k_BY_TEXT    PWR_M5k_BY_TEXT    PWR_M6k_BY_TEXT     GND_M1k_BY_TEXT   GND_M2k_BY_TEXT   GND_M3k_BY_TEXT   GND_M4k_BY_TEXT   GND_M5k_BY_TEXT   GND_M6k_BY_TEXT   PWR_MDk_BY_TEXT GND_MDk_BY_TEXT> 0
NWRkT_VDD_VSS_PAD_DUMMY = NET AREA RATIO NWRkT OVER CBk_DUMMY UBMnk_DUMMY UBMdk_DUMMY >0


(ODRkT_IOPAD OR ODRkT_PAD_TEXT) NOT (ODRkT_VDD_VSS_PAD_TEXT OR ODRkT_VDD_VSS_PAD_DUMMY)
(NWRkT_IOPAD OR NWRkT_PAD_TEXT) NOT (NWRkT_VDD_VSS_PAD_TEXT OR NWRkT_VDD_VSS_PAD_DUMMY) 

#ENDIF
}
#ENDIF



VARIABLE  HIA_1g   2.0
VARIABLE  HIA_2g   10 
VARIABLE  HIA_3g   300.000
VARIABLE  HIA_4g   0.28 
VARIABLE  HIA_5g   0.28 
#IFDEF GUIDELINE_ESD
// HIA_DIO LAYOUT GUIDELINES
//==========================
HIA_NAnode = PTAP NOT OUTSIDE HIADMY
HIA_PAnode = PACT INSIDE HIADMY
HIA_NCathode = NACT INSIDE HIADMY
HIA_PCathode = NTAP NOT OUTSIDE HIADMY
HIA_Anode = HIA_NAnode OR HIA_PAnode
HIA_Cathode = HIA_NCathode OR HIA_PCathode

HIA.1g { @ Width of N+ Active (N-HIA diode's cathode) and P+ Active (P-HIA diode's anode) inside HIA_DUMMY. (Figure XXX and Figure XXX) <= ^HIA_1g 
  HIA_NCathode WITH WIDTH > HIA_1g
  HIA_PAnode WITH WIDTH > HIA_1g
}
HIA.2g { @ Length of N+ Active (N-HIA diode's cathode) and P+ Active (P-HIA diode's anode) inside HIA_DUMMY. (Figure XXX and Figure XXX) <= ^HIA_2g
  ENCLOSE RECTANGLE HIA_NCathode 0.1 HIA_2g+GRID ORTHOGONAL ONLY
  ENCLOSE RECTANGLE HIA_PAnode 0.1 HIA_2g+GRID ORTHOGONAL ONLY
}
HIA_NCathode_IO_PAD = HIA_NCathode INTERACT SD_IOPAD
HIA_PAnode_IO_PAD = HIA_PAnode INTERACT SD_IOPAD
NHIA_ESD_IO_PAD = STAMP HIA_NCathode_IO_PAD BY NSDi  
PHIA_ESD_IO_PAD = STAMP HIA_PAnode_IO_PAD BY PSDi  
HIA.3g { @ Total perimeter of each N+ or P+ ACTIVE inside HIA_dummy in same connection of I/O PAD. (Figure XXX and Figure XXX). The perimeter counts the drawn anode junction parameter region ex. The drawing OD perimeter dimension of active inside HIA_DUMMY= (A+B)*2*N >= 300 
  NET AREA RATIO NHIA_ESD_IO_PAD < HIA_3g
    [PERIM(NHIA_ESD_IO_PAD)] 
  RDB HIA_3G_N.rep NHIA_ESD_IO_PAD
  NET AREA RATIO PHIA_ESD_IO_PAD < HIA_3g
    [PERIM(PHIA_ESD_IO_PAD)] 
  RDB HIA_3G_P.rep PHIA_ESD_IO_PAD
}

HIA.4g { @ The OD spacing of longer side of anode (P-diode) between anode and cathode, and vice versa for (N-diode). >= ^HIA_4g
  EXT HIA_NCathode HIA_NAnode < HIA_4g ABUT < 90 SINGULAR REGION
  EXT HIA_PCathode HIA_PAnode < HIA_4g ABUT < 90 SINGULAR REGION
}

//HIA.5g is checked by HIA.4g

//HIA.6g is un-checkable 

HIA.9g { @ HIA_DUMMY enclosure of OD >= 0  
  HIADMY INSIDE EDGE OD
}

HIA.17g { @ ALL ACTIVE OD inside same HIA_DUMMY should be in the same net
  HIADMY INTERACT NSDi > 1 BY NET
  HIADMY INTERACT PSDi > 1 BY NET
}

HIA.18g { @ HIA Dummy must be covered by DIODMY
  HIADMY NOT DIODUMMY
}
#ENDIF // GUIDELINE_ESD

#IFDEF 5V

// ESD checks
//===========

ESD.W.1{ @ Minimum esd width < 0.6
  INT ESD < 0.6 SINGULAR ABUT < 90 REGION
}
ESD.S.1{ @ Minimum esd space < 0.6
  EXT ESD < 0.6 ABUT < 90 REGION
}
ESD.S.2{ @ Minimum space between ESD and NP or PP < 0.3
  EXT ESD PP < 0.3 ABUT >0<90 SINGULAR REGION
  EXT ESD NP < 0.3 ABUT <90 SINGULAR REGION
  X = EXT ESD [PP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
}
ESD.C.1{ @ Minimum clearance from an ESD to an NP OD < 0.6
  EXT ESD NPOD < 0.6 SINGULAR ABUT < 90 REGION
}
ESD.C.2{ @ Minimum clearance from an ESD to a N-ch PO gate < 0.45
  ENC GATE_W ESD < 0.45 ABUT REGION
  ALL_GATE CUT ESD    
}
ESD.O.1{ @ Minimum overlap from an ESD edge to an OD region < 0.45
  INT ESD OD < 0.45 SINGULAR ABUT>0 <90 REGION 
}
ESD.C.4 { @ Min. space from ESD to ESD OD < 0.6
  X = NPOD INTERACT ESD
  EXT ESD X < 0.6 ABUT <90 SINGULAR REGION
}
ESD.E.1{ @ Minimum extension of an ESD region beyond an ESD OD < 0.25
  ENC OD ESD < 0.25 SINGULAR ABUT < 90 REGION
  ESD INSIDE OD
}
// ESD.C.5 is not necessary to check
ESD.R.1 { @ ESD and PP not allowed on same POLY region
  A = ESD AND POLY
  A AND PP
}
ESD.R.2 { @ ESD is for 5.0V NMOS only
  ESD AND (ALL_GATE AND PP)
  ESD AND ((ALL_GATE AND NP) NOT OD2)
}

#ENDIF

#IFDEF 3.3V

// ESDIMP checks
//================

ESDIMP.W.1 { @ Minimum esdimp width >= ^ESDIMP_W_1
	INT ESDIMP < ESDIMP_W_1 ABUT < 90 SINGULAR REGION 	
}
ESDIMP.S.1 { @ Minimum esdimp space >= ^ESDIMP_S_1
	EXT ESDIMP < ESDIMP_S_1 ABUT < 90 SINGULAR REGION 
}
ESDIMP.S.2 { @ Minimum space to esd3dmy (Overlap is prohibited) >= ^ESDIMP_S_2
	EXT ESDIMP ESD3DMY < ESDIMP_S_2 ABUT < 90 SINGULAR REGION
	ESDIMP AND ESD3DMY
}
ESDIMP.EN.1 { @ (OD not POLY) enclosure of esdimp (esdimp must be fully inside (OD not POLY)) >= ^ESDIMP_EN_1
	A = OD NOT POLY
	ENC ESDIMP A < ESDIMP_EN_1 ABUT < 90 SINGULAR REGION 
	ESDIMP NOT A
}

#IFDEF Recommend
ESDIMP.EN.1_R { @ (OD not POLY) enclosure of esdimp (esdimp must be fully inside (OD not POLY)) = ^ESDIMP_EN_1
	A = OD NOT POLY
	ENC ESDIMP A < ESDIMP_EN_1 ABUT < 90 SINGULAR REGION
	B = (HOLES ESDIMP INNER) OR ESDIMP
	C = SIZE B BY ESDIMP_EN_1 
	C NOT TOUCH EDGE A    
}
#ENDIF

ESDIMP.A.1 { @ Minimum esdimp area >= ^ESDIMP_A_1
	AREA ESDIMP < ESDIMP_A_1
}
ESDIMP.A.2 { @ Minimum esdimp enclosed area >= ^ESDIMP_A_2
	A = ( HOLES ESDIMP INNER ) NOT ESDIMP
	AREA A < ESDIMP_A_2
}
ESDIMP.R.1 { @ esdimp must be fully inside N+ active
	ESDIMP NOT NACT
}


#ENDIF





EMPTYi = CHIP  NOT BULK

// Latch-Up CHECKS
//================
RWi = PWELi INSIDE DNWi
NWRiT = (NWELi INTERACT RWDMY) NOT RWDMY // NWR terminal
SRM = COPY EXCL
UBMn = (UBMi NOT INTERACT PPIi) NOT INTERACT MDi  // UBM lie on Top Metal
UBMd = UBMi NOT UBMn                             // UBM lie on PPI or MD
CONNECT NWEL DNW
// Wire-Bond
CONNECT M6xd CBi
// Flip-chip
// 1_Ground up
CONNECT M6xd UBMn BY CBDi
// 2_RDL (before passivation)
//CONNECT M6xd MDxd BY VIADi
CONNECT MDxd UBMd
// 3_PPI (After passivation)
CONNECT M6xd PPIi BY CBDi
CONNECT PPIi UBMd

NPODc = NPi AND ODi
PPODc = PPi AND ODi
NTAPc = NPODc AND NONWRi
PTAPc = PPODc NOT NWELi
NACTc = NPODc NOT NWELi
PACTc = PPODc AND NONWRi

NSDc  = NACTc NOT POLYi		// NMOS source/drain
PSDc  = PACTc NOT POLYi		// PMOS source/drain
RPO_RPDMY = RPOi OR RPDUMMY


//Build connection for RES200
//============================
OD_RES_200ohm = (ODi AND RPDUMMY) AND RES200
PO_RES_200ohm = (POLYi AND RPDUMMY) AND RES200
NW_RES_200ohm = (NWELi AND RWDMY) AND RES200

NWELj = NWELi NOT NW_RES_200ohm
ILP1j   = POLYi NOT PO_RES_200ohm
NSDj  = NSDc NOT OD_RES_200ohm
PSDj  = PSDc NOT OD_RES_200ohm
NTAPj = EMPTYi OR (NPODc AND NWELi)
PTAPj = EMPTYi OR PTAPc
PWELj = EMPTYi OR PWELi
RWj = EMPTYi OR RWi
NWRjT = EMPTYi OR NWRiT
COj   = EMPTYi OR COi
M1j   = EMPTYi OR M1x

VIA1j = EMPTYi OR VIA1i
M2j   = EMPTYi OR M2x

VIA2j = EMPTYi OR VIA2i
M3j   = EMPTYi OR M3x

VIA3j = EMPTYi OR VIA3i
M4j   = EMPTYi OR M4x

VIA4j = EMPTYi OR VIA4i
M5j   = EMPTYi OR M5x

VIA5j = EMPTYi OR VIA5i
M6j   = EMPTYi OR M6x

VIADj = EMPTYi OR VIADi
MDj = EMPTYi OR MDx

CTM5j = EMPTYi OR CTM5i
CMM5j = EMPTYi OR CMM5i


CBj = EMPTYi OR CBi
CBDj = EMPTYi OR CBDi
PPIj = EMPTYi OR PPIi
UBMnj = EMPTYi OR UBMn
UBMdj = EMPTYi OR UBMd




//Build connection for CONNECT_ALL_RESISTOR
//============================

NWELu   = COPY NWELi 
ILP1u   = COPY POLYi
NSDu  = COPY NSDc
PSDu  = COPY PSDc
NTAPu = NPODc AND NWELi
PTAPu = COPY PTAPc
PWELu = COPY PWELi
RWu = COPY RWi
NWRuT = COPY NWRiT
COu   = COPY COi
M1u   = COPY M1x

VIA1u = COPY VIA1i
M2u   = COPY M2x

VIA2u = COPY VIA2i
M3u   = COPY M3x

VIA3u = COPY VIA3i
M4u   = COPY M4x

VIA4u = COPY VIA4i
M5u   = COPY M5x

VIA5u = COPY VIA5i
M6u   = COPY M6x

VIADu = COPY VIADi
MDu = COPY MDx

CTM5u = COPY CTM5i
CMM5u = COPY CMM5i



CBu = COPY CBi
CBDu = COPY CBDi
PPIu = COPY PPIi
UBMnu = COPY UBMn
UBMdu = COPY UBMd





//Build connection for DISCONNECT_ALL_RESISTOR
//============================

NWELk   = NWELi NOT EMPTYi

ILP1k   = POLYi NOT RPO_RPDMY	
NSDk  = (NSDc NOT RPO_RPDMY) NOT EMPTYi
PSDk  = (PSDc NOT RPO_RPDMY) NOT EMPTYi
NTAPk = NTAPc NOT EMPTYi
PTAPk =  PTAPc NOT EMPTYi
PWELk = PWELi NOT EMPTYi
RWk = RWi NOT EMPTYi
NWRkT = NWRiT NOT EMPTYi
COk   =  COi NOT EMPTYi
M1k   =  M1x NOT EMPTYi

VIA1k =  VIA1i NOT EMPTYi
M2k   =  M2x NOT EMPTYi

VIA2k =  VIA2i NOT EMPTYi
M3k   =  M3x NOT EMPTYi

VIA3k =  VIA3i NOT EMPTYi
M4k   =  M4x NOT EMPTYi

VIA4k =  VIA4i NOT EMPTYi
M5k   =  M5x NOT EMPTYi

VIA5k =  VIA5i NOT EMPTYi
M6k   =  M6x NOT EMPTYi

VIADk =  VIADi NOT EMPTYi
MDk =  MDx NOT EMPTYi

CTM5k =  CTM5i NOT EMPTYi
CMM5k =  CMM5i NOT EMPTYi


CBk =  CBi NOT EMPTYi
CBDk =  CBDi NOT EMPTYi
PPIk =  PPIi NOT EMPTYi
UBMnk =  UBMn NOT EMPTYi
UBMdk =  UBMd NOT EMPTYi






CONNECT	NTAPj NWELj
CONNECT	NTAPj PSDj
CONNECT	PTAPj NSDj
CONNECT PTAPj RWj	
CONNECT PTAPj PWELj
CONNECT	M1j ILP1j NTAPj PTAPj PSDj NSDj BY COj
CONNECT M1j NWRjT BY COj

CONNECT M1j M2j BY VIA1j

CONNECT M2j M3j BY VIA2j

CONNECT M3j M4j BY VIA3j

CONNECT M4j M5j BY VIA4j

CONNECT M6j CTM5j CMM5j M5j BY VIA5j

CONNECT	M6j  MDj BY VIADj
// Wire-Bond
CONNECT M6j CBj
// Flip-chip
// 1_Ground up
CONNECT M6j UBMnj BY CBDj       
// 2_RDL (before passivation)
CONNECT MDj UBMdj
// 3_PPI (After passivation)
CONNECT M6j PPIj BY CBDj
CONNECT PPIj UBMdj




CONNECT	NTAPu NWELu
CONNECT	NTAPu PSDu
CONNECT	PTAPu NSDu
CONNECT PTAPu RWu  
CONNECT PTAPu PWELu
CONNECT	M1u ILP1u NTAPu PTAPu PSDu NSDu BY COu
CONNECT M1u NWRuT BY COu

CONNECT M1u M2u BY VIA1u

CONNECT M2u M3u BY VIA2u

CONNECT M3u M4u BY VIA3u

CONNECT M4u M5u BY VIA4u

CONNECT M6u CTM5u CMM5u M5u BY VIA5u

CONNECT	M6u  MDu BY VIADu

// Wire-Bond
CONNECT M6u CBu
// Flip-chip
// 1_Ground up
CONNECT M6u UBMnu BY CBDu       
// 2_RDL (before passivation)
CONNECT MDu UBMdu
// 3_PPI (After passivation)
CONNECT M6u PPIu BY CBDu
CONNECT PPIu UBMdu



CONNECT	NTAPk NWELk
CONNECT	NTAPk PSDk
CONNECT	PTAPk NSDk
CONNECT PTAPk RWk    
CONNECT PTAPk PWELk 
CONNECT	M1k ILP1k NTAPk PTAPk PSDk NSDk BY COk
CONNECT M1k NWRkT BY COk


CONNECT M1k M2k BY VIA1k

CONNECT M2k M3k BY VIA2k

CONNECT M3k M4k BY VIA3k

CONNECT M4k M5k BY VIA4k

CONNECT M6k CTM5k CMM5k M5k BY VIA5k


CONNECT	M6k  MDk BY VIADk
// Wire-Bond
CONNECT M6k CBk
// Flip-chip
// 1_Ground up
CONNECT M6k UBMnk BY CBDk       
// 2_RDL (before passivation)
CONNECT MDk UBMdk
// 3_PPI (After passivation)
CONNECT M6k PPIk BY CBDk
CONNECT PPIk UBMdk






#IFDEF DISCONNECT_ALL_RESISTOR
NTAPiu = NTAPk NOT EMPTYi
PTAPiu = PTAPk NOT EMPTYi
NWRiu  = NWRkT NOT EMPTYi
NSDiu  = NSDk  NOT EMPTYi
PSDiu  = PSDk  NOT EMPTYi
ILP1iu = ILP1k NOT EMPTYi
M1iu = M1k NOT EMPTYi
COiu = COk NOT EMPTYi
CBiu   = CBk   NOT EMPTYi 
UBMniu  = UBMnk  NOT EMPTYi
UBMdiu  = UBMdk  NOT EMPTYi


CONNECT NTAPiu NTAPk
CONNECT PTAPiu PTAPk
CONNECT NSDiu NSDk
CONNECT PSDiu PSDk
CONNECT M1iu M1k
CONNECT COiu COk
PWR_M1iu_BY_TEXT = M1k WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_BY_TEXT = M1k WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1k WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_TEXT = EXPAND TEXT VSS_TEXT M1_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M1iu_TEXT = EXPAND TEXT VDD_TEXT M1_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M2iu_BY_TEXT = M2k WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_BY_TEXT = M2k WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2k WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_TEXT = EXPAND TEXT VSS_TEXT M2_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M2iu_TEXT = EXPAND TEXT VDD_TEXT M2_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M3iu_BY_TEXT = M3k WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_BY_TEXT = M3k WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3k WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_TEXT = EXPAND TEXT VSS_TEXT M3_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M3iu_TEXT = EXPAND TEXT VDD_TEXT M3_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M4iu_BY_TEXT = M4k WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_BY_TEXT = M4k WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4k WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_TEXT = EXPAND TEXT VSS_TEXT M4_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M4iu_TEXT = EXPAND TEXT VDD_TEXT M4_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M5iu_BY_TEXT = M5k WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_BY_TEXT = M5k WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5k WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_TEXT = EXPAND TEXT VSS_TEXT M5_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M5iu_TEXT = EXPAND TEXT VDD_TEXT M5_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M6iu_BY_TEXT = M6k WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_BY_TEXT = M6k WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6k WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_TEXT = EXPAND TEXT VSS_TEXT M6_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M6iu_TEXT = EXPAND TEXT VDD_TEXT M6_PIN_TEXT BY 1 PRIMARY ONLY

PWR_MDiu_BY_TEXT = MDk WITH TEXT VDD_TEXT MD_PIN_TEXT PRIMARY ONLY
GND_MDiu_BY_TEXT = MDk WITH TEXT VSS_TEXT MD_PIN_TEXT PRIMARY ONLY
PAD_MDiu_BY_TEXT = MDk WITH TEXT PAD_TEXT MD_PIN_TEXT PRIMARY ONLY
GND_MDiu_TEXT = EXPAND TEXT VSS_TEXT MD_PIN_TEXT BY 1 PRIMARY ONLY
PWR_MDiu_TEXT = EXPAND TEXT VDD_TEXT MD_PIN_TEXT BY 1 PRIMARY ONLY

#ELSE
#IFDEF CONNECT_ALL_RESISTOR


NTAPiu = NTAPu NOT EMPTYi
PTAPiu = PTAPu NOT EMPTYi
NWRiu  = NWRuT NOT EMPTYi
NSDiu  = NSDu  NOT EMPTYi
PSDiu  = PSDu  NOT EMPTYi
ILP1iu = ILP1u NOT EMPTYi
M1iu = M1u NOT EMPTYi
COiu = COu NOT EMPTYi
CBiu   = CBu   NOT EMPTYi 
UBMniu  = UBMnu  NOT EMPTYi
UBMdiu  = UBMdu  NOT EMPTYi



CONNECT NTAPiu NTAPu
CONNECT PTAPiu PTAPu
CONNECT NSDiu NSDu
CONNECT PSDiu PSDu
CONNECT M1iu M1u
CONNECT COiu COu
PWR_M1iu_BY_TEXT = M1u WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_BY_TEXT = M1u WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1u WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_TEXT = EXPAND TEXT VSS_TEXT M1_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M1iu_TEXT = EXPAND TEXT VDD_TEXT M1_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M2iu_BY_TEXT = M2u WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_BY_TEXT = M2u WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2u WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_TEXT = EXPAND TEXT VSS_TEXT M2_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M2iu_TEXT = EXPAND TEXT VDD_TEXT M2_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M3iu_BY_TEXT = M3u WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_BY_TEXT = M3u WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3u WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_TEXT = EXPAND TEXT VSS_TEXT M3_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M3iu_TEXT = EXPAND TEXT VDD_TEXT M3_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M4iu_BY_TEXT = M4u WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_BY_TEXT = M4u WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4u WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_TEXT = EXPAND TEXT VSS_TEXT M4_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M4iu_TEXT = EXPAND TEXT VDD_TEXT M4_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M5iu_BY_TEXT = M5u WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_BY_TEXT = M5u WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5u WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_TEXT = EXPAND TEXT VSS_TEXT M5_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M5iu_TEXT = EXPAND TEXT VDD_TEXT M5_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M6iu_BY_TEXT = M6u WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_BY_TEXT = M6u WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6u WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_TEXT = EXPAND TEXT VSS_TEXT M6_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M6iu_TEXT = EXPAND TEXT VDD_TEXT M6_PIN_TEXT BY 1 PRIMARY ONLY

PWR_MDiu_BY_TEXT = MDu WITH TEXT VDD_TEXT MD_PIN_TEXT PRIMARY ONLY
GND_MDiu_BY_TEXT = MDu WITH TEXT VSS_TEXT MD_PIN_TEXT PRIMARY ONLY
PAD_MDiu_BY_TEXT = MDu WITH TEXT PAD_TEXT MD_PIN_TEXT PRIMARY ONLY
GND_MDiu_TEXT = EXPAND TEXT VSS_TEXT MD_PIN_TEXT BY 1 PRIMARY ONLY
PWR_MDiu_TEXT = EXPAND TEXT VDD_TEXT MD_PIN_TEXT BY 1 PRIMARY ONLY



#ELSE

NTAPiu = NTAPj NOT EMPTYi
PTAPiu = PTAPj NOT EMPTYi
NWRiu  = NWRjT NOT EMPTYi	
NSDiu  = NSDj  NOT EMPTYi
PSDiu  = PSDj  NOT EMPTYi
ILP1iu = ILP1j NOT EMPTYi
M1iu = M1j NOT EMPTYi
COiu = COj NOT EMPTYi

CBiu   = CBj   NOT EMPTYi 
UBMniu  = UBMnj  NOT EMPTYi
UBMdiu  = UBMdj  NOT EMPTYi


CONNECT NTAPiu NTAPj
CONNECT PTAPiu PTAPj
CONNECT NSDiu NSDj
CONNECT PSDiu PSDj
CONNECT M1iu M1j
CONNECT COiu COj
PWR_M1iu_BY_TEXT = M1j WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_BY_TEXT = M1j WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1j WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_TEXT = EXPAND TEXT VSS_TEXT M1_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M1iu_TEXT = EXPAND TEXT VDD_TEXT M1_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M2iu_BY_TEXT = M2j WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_BY_TEXT = M2j WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2j WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_TEXT = EXPAND TEXT VSS_TEXT M2_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M2iu_TEXT = EXPAND TEXT VDD_TEXT M2_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M3iu_BY_TEXT = M3j WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_BY_TEXT = M3j WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3j WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_TEXT = EXPAND TEXT VSS_TEXT M3_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M3iu_TEXT = EXPAND TEXT VDD_TEXT M3_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M4iu_BY_TEXT = M4j WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_BY_TEXT = M4j WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4j WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_TEXT = EXPAND TEXT VSS_TEXT M4_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M4iu_TEXT = EXPAND TEXT VDD_TEXT M4_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M5iu_BY_TEXT = M5j WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_BY_TEXT = M5j WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5j WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_TEXT = EXPAND TEXT VSS_TEXT M5_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M5iu_TEXT = EXPAND TEXT VDD_TEXT M5_PIN_TEXT BY 1 PRIMARY ONLY

PWR_M6iu_BY_TEXT = M6j WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_BY_TEXT = M6j WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6j WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_TEXT = EXPAND TEXT VSS_TEXT M6_PIN_TEXT BY 1 PRIMARY ONLY
PWR_M6iu_TEXT = EXPAND TEXT VDD_TEXT M6_PIN_TEXT BY 1 PRIMARY ONLY

PWR_MDiu_BY_TEXT = MDj WITH TEXT VDD_TEXT MD_PIN_TEXT PRIMARY ONLY
GND_MDiu_BY_TEXT = MDj WITH TEXT VSS_TEXT MD_PIN_TEXT PRIMARY ONLY
PAD_MDiu_BY_TEXT = MDj WITH TEXT PAD_TEXT MD_PIN_TEXT PRIMARY ONLY
GND_MDiu_TEXT = EXPAND TEXT VSS_TEXT MD_PIN_TEXT BY 1 PRIMARY ONLY
PWR_MDiu_TEXT = EXPAND TEXT VDD_TEXT MD_PIN_TEXT BY 1 PRIMARY ONLY


#ENDIF
#ENDIF
IO_M1iu_BY_TEXT = PAD_M1iu_BY_TEXT NOT INTERACT (PWR_M1iu_BY_TEXT OR GND_M1iu_BY_TEXT)
IO_M2iu_BY_TEXT = PAD_M2iu_BY_TEXT NOT INTERACT (PWR_M2iu_BY_TEXT OR GND_M2iu_BY_TEXT)
IO_M3iu_BY_TEXT = PAD_M3iu_BY_TEXT NOT INTERACT (PWR_M3iu_BY_TEXT OR GND_M3iu_BY_TEXT)
IO_M4iu_BY_TEXT = PAD_M4iu_BY_TEXT NOT INTERACT (PWR_M4iu_BY_TEXT OR GND_M4iu_BY_TEXT)
IO_M5iu_BY_TEXT = PAD_M5iu_BY_TEXT NOT INTERACT (PWR_M5iu_BY_TEXT OR GND_M5iu_BY_TEXT)
IO_M6iu_BY_TEXT = PAD_M6iu_BY_TEXT NOT INTERACT (PWR_M6iu_BY_TEXT OR GND_M6iu_BY_TEXT)
IO_MDiu_BY_TEXT = PAD_MDiu_BY_TEXT NOT INTERACT (PWR_MDiu_BY_TEXT OR GND_MDiu_BY_TEXT)


VARIABLE  LUP_2   20.0
VARIABLE  LUP_2_S 8.0
VARIABLE  LUP_3_1 3.0
VARIABLE  LUP_3_2 6.0
VARIABLE  LUP_3_3 12.0
VARIABLE  LUP_3_4 23.0
VARIABLE  LUP_4   0.42
VARIABLE  LUP_5_1 3.0
VARIABLE  LUP_5_2 6.0
VARIABLE  LUP_5_3 12.0
VARIABLE  LUP_5_4 23.0
VARIABLE  LUP_5_4_1 40.0 //limitation
VARIABLE  LUP_6   30.0
VARIABLE  LUP_6_SRAM 40.0
VARIABLE  LUP_10	75.0
VARIABLE  LUP_13	15.0
VARIABLE  LUP_14  0.42
VARIABLE  NW_S_1  0.6

NTAPux = (NTAPiu NOT INTERACT RNWEL) NOT VARDMY
PTAPux = PTAPiu NOT VARDMY


// Power PAD
VDD_CB = NET AREA RATIO CBiu NTAPux > 0
VSS_CB = NET AREA RATIO CBiu PTAPux > 0
VDD_UBMn = NET AREA RATIO UBMniu NTAPux > 0  // VDD_UMBn connect to N+ OD pickup
VSS_UBMn = NET AREA RATIO UBMniu PTAPux > 0  // VSS_UMBn connect to P+ OD pickup
VDD_UBMd = NET AREA RATIO UBMdiu NTAPux > 0  // VDD_UMBd connect to N+ OD pickup
VSS_UBMd = NET AREA RATIO UBMdiu PTAPux > 0  // VSS_UMBd connect to P+ OD pickup

// Signal PAD
IO_CB  = (CBiu NOT VDD_CB) NOT VSS_CB 
IO_UBMn = (UBMniu NOT VDD_UBMn) NOT VSS_UBMn
IO_UBMd = (UBMdiu NOT VDD_UBMd) NOT VSS_UBMd





PSD_PAD = NET AREA RATIO PSDiu CBiu UBMniu UBMdiu > 0 [!!AREA(CBiu) + !!AREA(UBMniu)+ !!AREA(UBMdiu)]       // P+ S/D, and connect to all CB/UBM pad
NSD_PAD = NET AREA RATIO NSDiu CBiu UBMniu UBMdiu > 0 [!!AREA(CBiu) + !!AREA(UBMniu)+ !!AREA(UBMdiu)]
PSD_IOPAD = NET AREA RATIO PSDiu IO_CB IO_UBMn IO_UBMd > 0 [!!AREA(IO_CB) + !!AREA(IO_UBMn)+ !!AREA(IO_UBMd)] // P+ S/D, and connect to I/O pad only
NSD_IOPAD = NET AREA RATIO NSDiu IO_CB IO_UBMn IO_UBMd > 0 [!!AREA(IO_CB) + !!AREA(IO_UBMn)+ !!AREA(IO_UBMd)]
NWR_IOPAD = NET AREA RATIO NWRiu IO_CB IO_UBMn IO_UBMd > 0 [!!AREA(IO_CB) + !!AREA(IO_UBMn)+ !!AREA(IO_UBMd)]





VDD_VSS_DUMMY = VDDDMY OR VSSDMY
CB_DUMMY = CBiu INTERACT VDD_VSS_DUMMY
CB_VDD_DUMMY = CBiu INTERACT VDDDMY
CB_VSS_DUMMY = CBiu INTERACT VSSDMY
UBMn_DUMMY = UBMniu INTERACT VDD_VSS_DUMMY
UBMn_VDD_DUMMY = UBMniu INTERACT VDDDMY
UBMn_VSS_DUMMY = UBMniu INTERACT VSSDMY
UBMd_DUMMY = UBMdiu INTERACT VDD_VSS_DUMMY
UBMd_VDD_DUMMY = UBMdiu INTERACT VDDDMY
UBMd_VSS_DUMMY = UBMdiu INTERACT VSSDMY





PSD_VDD_VSS_PAD_DUMMY = NET AREA RATIO PSDiu OVER CB_DUMMY UBMn_DUMMY UBMd_DUMMY >0
PSD_VDD_PAD_DUMMY = NET AREA RATIO PSDiu OVER CB_VDD_DUMMY UBMn_VDD_DUMMY UBMd_VDD_DUMMY >0
PSD_VSS_PAD_DUMMY = NET AREA RATIO PSDiu OVER CB_VSS_DUMMY UBMn_VSS_DUMMY UBMd_VSS_DUMMY >0
NSD_VDD_VSS_PAD_DUMMY = NET AREA RATIO NSDiu OVER CB_DUMMY UBMn_DUMMY UBMd_DUMMY >0
NWR_VDD_VSS_PAD_DUMMY = NET AREA RATIO NWRiu OVER CB_DUMMY UBMn_DUMMY UBMd_DUMMY >0

NSD_VDD_PAD_DUMMY = NET AREA RATIO NSDiu OVER CB_VDD_DUMMY UBMn_VDD_DUMMY UBMd_VDD_DUMMY >0
NSD_VSS_PAD_DUMMY = NET AREA RATIO NSDiu OVER CB_VSS_DUMMY UBMn_VSS_DUMMY UBMd_VSS_DUMMY >0




 PSD_PAD_TEXT = NET AREA RATIO PSDiu OVER  PAD_M1iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M6iu_BY_TEXT PAD_MDiu_BY_TEXT > 0 
 NSD_PAD_TEXT = NET AREA RATIO NSDiu OVER  PAD_M1iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M6iu_BY_TEXT PAD_MDiu_BY_TEXT > 0 
 NWR_PAD_TEXT = NET AREA RATIO NWRiu OVER  PAD_M1iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M6iu_BY_TEXT PAD_MDiu_BY_TEXT > 0 

 PSD_VDD_VSS_PAD_TEXT = NET AREA RATIO PSDiu OVER  PWR_M1iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M6iu_BY_TEXT GND_M1iu_BY_TEXT GND_M2iu_BY_TEXT GND_M3iu_BY_TEXT GND_M4iu_BY_TEXT GND_M5iu_BY_TEXT GND_M6iu_BY_TEXT PWR_MDiu_BY_TEXT GND_MDiu_BY_TEXT > 0 
 NSD_VDD_VSS_PAD_TEXT = NET AREA RATIO NSDiu OVER  PWR_M1iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M6iu_BY_TEXT GND_M1iu_BY_TEXT GND_M2iu_BY_TEXT GND_M3iu_BY_TEXT GND_M4iu_BY_TEXT GND_M5iu_BY_TEXT GND_M6iu_BY_TEXT PWR_MDiu_BY_TEXT GND_MDiu_BY_TEXT > 0 

 NWR_VDD_VSS_PAD_TEXT = NET AREA RATIO NWRiu OVER  PWR_M1iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M6iu_BY_TEXT GND_M1iu_BY_TEXT GND_M2iu_BY_TEXT GND_M3iu_BY_TEXT GND_M4iu_BY_TEXT GND_M5iu_BY_TEXT GND_M6iu_BY_TEXT PWR_MDiu_BY_TEXT GND_MDiu_BY_TEXT > 0


 PWR_TEXT =  ( ( ( ( ( PWR_M1iu_TEXT OR PWR_M2iu_TEXT ) OR PWR_M3iu_TEXT ) OR PWR_M4iu_TEXT ) OR PWR_M5iu_TEXT ) OR PWR_M6iu_TEXT ) OR PWR_MDiu_TEXT  
 GND_TEXT =  ( ( ( ( ( GND_M1iu_TEXT OR GND_M2iu_TEXT ) OR GND_M3iu_TEXT ) OR GND_M4iu_TEXT ) OR GND_M5iu_TEXT ) OR GND_M6iu_TEXT ) OR GND_MDiu_TEXT  


#IFDEF  CHECK_LATCHUP_BY_TEXT
PSD_IOPAD_ALL = (PSD_IOPAD OR PSD_PAD_TEXT) NOT (PSD_VDD_VSS_PAD_TEXT OR PSD_VDD_VSS_PAD_DUMMY)
NSD_IOPAD_ALL = (NSD_IOPAD OR NSD_PAD_TEXT) NOT (NSD_VDD_VSS_PAD_TEXT OR NSD_VDD_VSS_PAD_DUMMY)
SD_IOPAD = PSD_IOPAD_ALL OR NSD_IOPAD_ALL
NWR_IOPAD_ALL = (NWR_IOPAD OR NWR_PAD_TEXT) NOT (NWR_VDD_VSS_PAD_TEXT OR NWR_VDD_VSS_PAD_DUMMY)

MOS = DACT INTERACT ALL_GATE
PMOS_filter = COPY EMPTYi
NMOS_filter = COPY EMPTYi
#ENDIF

#IFNDEF  CHECK_LATCHUP_BY_TEXT
PSD_IOPAD_ALL = PSD_IOPAD  NOT PSD_VDD_VSS_PAD_DUMMY
NSD_IOPAD_ALL = NSD_IOPAD  NOT NSD_VDD_VSS_PAD_DUMMY
SD_IOPAD = PSD_IOPAD_ALL OR NSD_IOPAD_ALL
NWR_IOPAD_ALL = NWR_IOPAD NOT NWR_VDD_VSS_PAD_DUMMY
MOS = DACT INTERACT ALL_GATE
MOS_filter_DMY = CHIP INTERACT (VDDDMY OR VSSDMY)
PMOS_filter = (MOS INTERACT PSD_PAD == 1 BY NET) NOT MOS_filter_DMY
NMOS_filter = (MOS INTERACT NSD_PAD == 1 BY NET) NOT MOS_filter_DMY
#ENDIF

DUMMY_MOS = (MOS NOT INTERACT CO) NOT INTERACT (POLY INTERACT CO)
DUMMY_DIODE = (DACT NOT INTERACT POLY) NOT INTERACT CO

DACT_real =  (DACT NOT DUMMY_MOS) NOT DUMMY_DIODE
PACT_real = PACT NOT DUMMY_MOS
NACT_real = NACT NOT DUMMY_MOS

POST_DRIVER_ACT = ((((DACT_real NOT PMOS_filter) NOT NMOS_filter) INTERACT SD_IOPAD) OR (OD INTERACT NWR_IOPAD)) NOT INSIDE LUPWDMY


#IFDEF DISCONNECT_ALL_RESISTOR
#IFDEF CONNECT_ALL_RESISTOR
LUP.WARN.1 { @ DRC LUP switch setting conflict detected (refer to section XXX for details): Please follow one of the following LUP switch settings: 0 [Default setting: RES200 usage] Turns off both "DISCONNECT_ALL_RESISTOR", and "CONNECT_ALL_RESISTOR": circuits after RES200 will NOT be recognized as OD injector, or 1 Turns on "DISCONNECT_ALL_RESISTOR" only: circuits after any resistor will NOT recognized as OD injector, or 2 Turns on "CONNECT_ALL_RESISTOR" only: circuits after any resistor will always be recognized as OD injector Please DO NOT turn on both "DISCONNECT_ALL_RESISTOR", and "CONNECT_ALL_RESISTOR" at the same time, otherwise "DISCONNECT_ALL_RESISTOR" will have higher priority   
  MERGE (COPY CHIPx)
}
#ENDIF
#ENDIF

// For LUP.1/LUP.2/LUP.4 - GuardRing
//====================================
NW_inside_guard_ring_pre1 = NWELi NOT NTAPi
NW_inside_guard_ring_pre2 = NW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE NTAPi
NW_inside_guard_ring = NW_inside_guard_ring_pre1 NOT WITH EDGE NW_inside_guard_ring_pre2
PW_inside_guard_ring_pre1 = PWELi NOT PTAPi
PW_inside_guard_ring_pre2 = PW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE PTAPi
PW_inside_guard_ring = PW_inside_guard_ring_pre1 NOT WITH EDGE PW_inside_guard_ring_pre2
NTAP_guard_ring_hole = ((HOLES NTAPi INNER) INSIDE NWELi) OR NW_inside_guard_ring
PTAP_guard_ring_hole = ((HOLES PTAPi INNER) INSIDE PWELi) OR PW_inside_guard_ring



// For LUP.1 - I/O PAD N/P ACTIVE
//=================================
POST_DRIVER_PACT = (POST_DRIVER_ACT INTERACT PSDiu) NOT INSIDE LUPWDMY
POST_DRIVER_NACT = ((POST_DRIVER_ACT INTERACT NSDiu) OR (OD INTERACT NWR_IOPAD_ALL)) NOT INSIDE LUPWDMY
// For LUP.3
//==================
POST_DRIVER_PMOS = POST_DRIVER_PACT INTERACT ALL_GATE
POST_DRIVER_PMOS_NW = STAMP POST_DRIVER_PMOS BY NWEL

POST_DRIVER_PMOS_NW_HV  = POST_DRIVER_PMOS_NW INTERACT HVGT
POST_DRIVER_PMOS_NW_33V = POST_DRIVER_PMOS_NW_HV INTERACT OD2i
POST_DRIVER_PMOS_NW_25V = POST_DRIVER_PMOS_NW_HV INTERACT OD2i

POST_DRIVER_PMOS_NW_50V = POST_DRIVER_PMOS_NW_HV INTERACT OD2i

POST_DRIVER_PMOS_NW_LV  = POST_DRIVER_PMOS_NW NOT POST_DRIVER_PMOS_NW_HV
POST_DRIVER_PMOS_NWi = STAMP POST_DRIVER_PMOS BY NWELi

POST_DRIVER_PMOS_NWi_HV  = POST_DRIVER_PMOS_NWi INTERACT HVGT
POST_DRIVER_PMOS_NWi_33V = POST_DRIVER_PMOS_NWi_HV INTERACT OD2i
POST_DRIVER_PMOS_NWi_25V = POST_DRIVER_PMOS_NWi_HV INTERACT OD2i
POST_DRIVER_PMOS_NWi_50V = POST_DRIVER_PMOS_NWi_HV INTERACT OD2i

POST_DRIVER_PMOS_NWi_LV  = POST_DRIVER_PMOS_NWi NOT POST_DRIVER_PMOS_NWi_HV
POST_DRIVER_PINJ = COPY POST_DRIVER_PACT
POST_DRIVER_PINJ_NW = STAMP POST_DRIVER_PINJ BY NWEL
POST_DRIVER_PINJ_NW_HV  = POST_DRIVER_PINJ_NW INTERACT OD2i
POST_DRIVER_PINJ_NW_LV  = POST_DRIVER_PINJ_NW NOT POST_DRIVER_PINJ_NW_HV
POST_DRIVER_PINJ_NWi = STAMP POST_DRIVER_PINJ BY NWELi
POST_DRIVER_PINJ_NWi_HV  = POST_DRIVER_PINJ_NWi INTERACT OD2i
POST_DRIVER_PINJ_NWi_LV  = POST_DRIVER_PINJ_NWi NOT POST_DRIVER_PINJ_NWi_HV
POST_DRIVER_NINJ = COPY POST_DRIVER_NACT 
POST_DRIVER_NINJ_RW = STAMP (POST_DRIVER_NINJ INSIDE DNW) BY DNW
POST_DRIVER_NINJ_PW = POST_DRIVER_NINJ NOT POST_DRIVER_NINJ_RW
POST_DRIVER_NINJ_RWi = STAMP (POST_DRIVER_NINJ INSIDE DNW) BY DNWc
POST_DRIVER_NMOS = POST_DRIVER_NACT INTERACT ALL_GATE
POST_DRIVER_NMOS_RW = STAMP (POST_DRIVER_NMOS INSIDE DNW) BY DNW
POST_DRIVER_NMOS_PW = POST_DRIVER_NMOS NOT POST_DRIVER_NMOS_RW
POST_DRIVER_NMOS_RW_HV  = POST_DRIVER_NMOS_RW INTERACT HVGT
POST_DRIVER_NMOS_RW_33V = POST_DRIVER_NMOS_RW_HV INTERACT OD2i
POST_DRIVER_NMOS_RW_25V = POST_DRIVER_NMOS_RW_HV INTERACT OD2i
POST_DRIVER_NMOS_RW_50V = POST_DRIVER_NMOS_RW_HV INTERACT OD2i

POST_DRIVER_NMOS_RW_LV  = POST_DRIVER_NMOS_RW NOT POST_DRIVER_NMOS_RW_HV
POST_DRIVER_NMOS_PW_HV  = POST_DRIVER_NMOS_PW INTERACT HVGT
POST_DRIVER_NMOS_PW_33V = POST_DRIVER_NMOS_PW_HV INTERACT OD2i
POST_DRIVER_NMOS_PW_25V = POST_DRIVER_NMOS_PW_HV INTERACT OD2i
POST_DRIVER_NMOS_PW_50V = POST_DRIVER_NMOS_PW_HV INTERACT OD2i

POST_DRIVER_NMOS_PW_LV  = POST_DRIVER_NMOS_PW NOT POST_DRIVER_NMOS_PW_HV
DNWc = STAMP DNW BY NWELi

POST_DRIVER_NMOS_RWi = STAMP (POST_DRIVER_NMOS INSIDE DNWc) BY DNWc
POST_DRIVER_NMOS_RWi_HV  = POST_DRIVER_NMOS_RWi INTERACT HVGT
POST_DRIVER_NMOS_RWi_33V = POST_DRIVER_NMOS_RWi_HV INTERACT OD2i
POST_DRIVER_NMOS_RWi_25V = POST_DRIVER_NMOS_RWi_HV INTERACT OD2i
POST_DRIVER_NMOS_RWi_50V = POST_DRIVER_NMOS_RWi_HV INTERACT OD2i

POST_DRIVER_NMOS_RWi_LV  = POST_DRIVER_NMOS_RWi NOT POST_DRIVER_NMOS_RWi_HV


POST_DRIVER_MOS = POST_DRIVER_NMOS OR POST_DRIVER_PMOS
BESIDE_POST_DRIVER = SIZE POST_DRIVER_MOS BY LUP_2 BEVEL 4
BESIDE_POST_DRIVER_NMOS = (((NACT_real INTERACT ALL_GATE) NOT OUTSIDE BESIDE_POST_DRIVER) NOT POST_DRIVER_NACT) NOT DUMMY_MOS
BESIDE_POST_DRIVER_NACT = ((NACT_real NOT OUTSIDE BESIDE_POST_DRIVER) NOT POST_DRIVER_NACT) NOT DUMMY_MOS
BESIDE_POST_DRIVER_PMOS = (((PACT_real INTERACT ALL_GATE) NOT OUTSIDE BESIDE_POST_DRIVER) NOT POST_DRIVER_PACT) NOT DUMMY_MOS
BESIDE_POST_DRIVER_PACT = ((PACT_real NOT OUTSIDE BESIDE_POST_DRIVER) NOT POST_DRIVER_PACT) NOT DUMMY_MOS

// for LUP.5.4
BESIDE_POST_DRIVER_1 = SIZE POST_DRIVER_MOS BY LUP_5_4_1 BEVEL 4
BESIDE_POST_DRIVER_NMOS_1 = (((NACT_real INTERACT ALL_GATE) NOT OUTSIDE BESIDE_POST_DRIVER_1) NOT POST_DRIVER_NACT) NOT DUMMY_MOS
BESIDE_POST_DRIVER_PMOS_1 = (((PACT_real INTERACT ALL_GATE) NOT OUTSIDE BESIDE_POST_DRIVER_1) NOT POST_DRIVER_PACT) NOT DUMMY_MOS


BESIDE_POST_DRIVER_PMOS_NW = STAMP BESIDE_POST_DRIVER_PMOS BY NWEL

BESIDE_POST_DRIVER_PMOS_NW_HV  = BESIDE_POST_DRIVER_PMOS_NW INTERACT HVGT
BESIDE_POST_DRIVER_PMOS_NW_33V = BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT OD2i
BESIDE_POST_DRIVER_PMOS_NW_25V = BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT OD2i
BESIDE_POST_DRIVER_PMOS_NW_50V = BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT OD2i

BESIDE_POST_DRIVER_PMOS_NW_LV  = BESIDE_POST_DRIVER_PMOS_NW NOT BESIDE_POST_DRIVER_PMOS_NW_HV
BESIDE_POST_DRIVER_PMOS_NWi = STAMP BESIDE_POST_DRIVER_PMOS BY NWELi

BESIDE_POST_DRIVER_PMOS_NWi_HV  = BESIDE_POST_DRIVER_PMOS_NWi INTERACT HVGT
BESIDE_POST_DRIVER_PMOS_NWi_33V = BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT OD2i
BESIDE_POST_DRIVER_PMOS_NWi_25V = BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT OD2i
BESIDE_POST_DRIVER_PMOS_NWi_50V = BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT OD2i

BESIDE_POST_DRIVER_PMOS_NWi_LV  = BESIDE_POST_DRIVER_PMOS_NWi NOT BESIDE_POST_DRIVER_PMOS_NWi_HV
BESIDE_POST_DRIVER_NMOS_RW = STAMP (BESIDE_POST_DRIVER_NMOS INSIDE DNW) BY DNW
BESIDE_POST_DRIVER_NMOS_PW = BESIDE_POST_DRIVER_NMOS NOT BESIDE_POST_DRIVER_NMOS_RW
BESIDE_POST_DRIVER_NMOS_RW_HV  = BESIDE_POST_DRIVER_NMOS_RW INTERACT HVGT
BESIDE_POST_DRIVER_NMOS_RW_33V = BESIDE_POST_DRIVER_NMOS_RW_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_RW_25V = BESIDE_POST_DRIVER_NMOS_RW_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_RW_50V = BESIDE_POST_DRIVER_NMOS_RW_HV INTERACT OD2i

BESIDE_POST_DRIVER_NMOS_RW_LV  = BESIDE_POST_DRIVER_NMOS_RW NOT BESIDE_POST_DRIVER_NMOS_RW_HV
BESIDE_POST_DRIVER_NMOS_PW_HV  = BESIDE_POST_DRIVER_NMOS_PW INTERACT HVGT
BESIDE_POST_DRIVER_NMOS_PW_33V = BESIDE_POST_DRIVER_NMOS_PW_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_PW_25V = BESIDE_POST_DRIVER_NMOS_PW_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_PW_50V = BESIDE_POST_DRIVER_NMOS_PW_HV INTERACT OD2i

BESIDE_POST_DRIVER_NMOS_PW_LV  = BESIDE_POST_DRIVER_NMOS_PW NOT BESIDE_POST_DRIVER_NMOS_PW_HV
BESIDE_POST_DRIVER_NMOS_RWi = STAMP (BESIDE_POST_DRIVER_NMOS INSIDE DNWc) BY DNWc
BESIDE_POST_DRIVER_NMOS_RWi_HV  = BESIDE_POST_DRIVER_NMOS_RWi INTERACT HVGT
BESIDE_POST_DRIVER_NMOS_RWi_33V = BESIDE_POST_DRIVER_NMOS_RWi_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_RWi_25V = BESIDE_POST_DRIVER_NMOS_RWi_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_RWi_50V = BESIDE_POST_DRIVER_NMOS_RWi_HV INTERACT OD2i

BESIDE_POST_DRIVER_NMOS_RWi_LV  = BESIDE_POST_DRIVER_NMOS_RWi NOT BESIDE_POST_DRIVER_NMOS_RWi_HV

// for LUP.5.4
BESIDE_POST_DRIVER_PMOS_NW_1 = STAMP BESIDE_POST_DRIVER_PMOS_1 BY NWEL
BESIDE_POST_DRIVER_PMOS_NW_HV_1 = BESIDE_POST_DRIVER_PMOS_NW_1 INTERACT HVGT
BESIDE_POST_DRIVER_PMOS_NWi_1 = STAMP BESIDE_POST_DRIVER_PMOS_1 BY NWELi
BESIDE_POST_DRIVER_PMOS_NWi_HV_1 = BESIDE_POST_DRIVER_PMOS_NWi_1 INTERACT HVGT



BESIDE_POST_DRIVER_NMOS_RW_1 = STAMP (BESIDE_POST_DRIVER_NMOS_1 INSIDE DNW) BY DNW
BESIDE_POST_DRIVER_NMOS_PW_1 = BESIDE_POST_DRIVER_NMOS_1 NOT BESIDE_POST_DRIVER_NMOS_RW_1
BESIDE_POST_DRIVER_NMOS_RWi_1 = STAMP (BESIDE_POST_DRIVER_NMOS_1 INSIDE DNWc) BY DNWc

#IFDEF GUIDELINE_LUP

LUP.1g { @ Any N+ OD injector or an N+ OD injector cluster connected to an I/O pad must be surrounded by a P+ guard-ring.
        @ Any P+ OD injector or a P+ OD injector cluster connected to an I/O pad must be surrounded by a N+ guard-ring.
   POST_DRIVER_NACT NOT INSIDE PTAP_guard_ring_hole  
   POST_DRIVER_PACT NOT INSIDE NTAP_guard_ring_hole 

}


LUP.2g { @ Within ^LUP_2 um space from the OD injector connected to an I/O pad, a P+ guard-ring is required to surround an NACT or an NACT cluster. And an N+ guard-ring is required to surround a PACT or a PACT cluster.
  X = BESIDE_POST_DRIVER_NMOS_RW INTERACT (DNW INTERACT ((NWEL INTERACT (DNW INTERACT BESIDE_POST_DRIVER_NMOS_RW)) INTERACT POST_DRIVER_PMOS_NW))
  Y = EXT POST_DRIVER_PMOS_NWi [BESIDE_POST_DRIVER_NMOS_RWi] < LUP_2 ABUT < 90 SINGULAR NOT CONNECTED
  BESIDE_POST_DRIVER_NMOS_waive = (BESIDE_POST_DRIVER_NMOS_RWi NOT INTERACT X) NOT WITH EDGE Y
 (BESIDE_POST_DRIVER_NACT NOT BESIDE_POST_DRIVER_NMOS_waive) NOT INSIDE PTAP_guard_ring_hole
  BESIDE_POST_DRIVER_PACT NOT INSIDE NTAP_guard_ring_hole 
}

#IFDEF 1.8V
LUP.3.1g_1.8V {@ For the N/PMOS which connects to an I/O pad, space between the NMOS and the 1.8V PMOS.Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= ^LUP_3_1 um
  EXT POST_DRIVER_PMOS_NW_LV POST_DRIVER_NMOS_PW < LUP_3_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_LV POST_DRIVER_NMOS_RW < LUP_3_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_LV POST_DRIVER_NMOS_RWi < LUP_3_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
#ENDIF




#IFDEF 1.5V
LUP.3.1g_1.5V {@ For the N/PMOS which connects to an I/O pad, space between the NMOS and the 1.5V PMOS.Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= ^LUP_3_1 um
  EXT POST_DRIVER_PMOS_NW_LV POST_DRIVER_NMOS_PW < LUP_3_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PMOS_NW_LV POST_DRIVER_NMOS_RW < LUP_3_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PMOS_NWi_LV POST_DRIVER_NMOS_RWi < LUP_3_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
#ENDIF


#IFDEF 2.5V

LUP.3.2g_2.5V {@ For the N/PMOS which connects to an I/O pad directly, space between the the 2.5V PMOS and NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.>= ^LUP_3_2 um
  EXT POST_DRIVER_NMOS_PW POST_DRIVER_PMOS_NW_HV < LUP_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW POST_DRIVER_PMOS_NW_HV < LUP_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi POST_DRIVER_PMOS_NWi_HV < LUP_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
#ENDIF



#IFDEF 3.3V
LUP.3.3g_3.3V {@ For the N/PMOS which connects to an I/O pad directly, space between the 3.3V PMOS and NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= ^LUP_3_3 um

  EXT POST_DRIVER_NMOS_PW POST_DRIVER_PMOS_NW_HV < LUP_3_3 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW POST_DRIVER_PMOS_NW_HV < LUP_3_3 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi POST_DRIVER_PMOS_NWi_HV < LUP_3_3 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
#ENDIF


#IFDEF 5V 


LUP.3.4g_5V {@ For the N/PMOS which connects to an I/O pad directly, space between the 5V PMOS and NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.  >= ^LUP_3_4 um
EXT POST_DRIVER_NMOS_PW POST_DRIVER_PMOS_NW_HV < LUP_3_4 ABUT < 90 SINGULAR REGION
EXT POST_DRIVER_NMOS_RW POST_DRIVER_PMOS_NW_HV < LUP_3_4 ABUT < 90 SINGULAR REGION CONNECTED
EXT POST_DRIVER_NMOS_RWi POST_DRIVER_PMOS_NWi_HV < LUP_3_4 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
#ENDIF






LUP.4g {@ Width of the N+ guard-ring, P+ guard-ring, N+ STRAP and P+ STRAP for the Active connected to an I/O pad, and also MOS within 20um space from the MOS connected to an I/O pad. >= ^LUP_4 um
  PTAP_guard_ring_holex = PTAP_guard_ring_hole ENCLOSE (POST_DRIVER_NACT OR BESIDE_POST_DRIVER_NMOS)
  NTAP_guard_ring_holex = NTAP_guard_ring_hole ENCLOSE (POST_DRIVER_PACT OR BESIDE_POST_DRIVER_PMOS)
  PTAP_guard_ring_wide = (PTAPi TOUCH PTAP_guard_ring_holex) WITH WIDTH >= LUP_4
  NTAP_guard_ring_wide = (NTAPi TOUCH NTAP_guard_ring_holex) WITH WIDTH >= LUP_4
  PTAP_guard_ring_wide_hole = (HOLES PTAP_guard_ring_wide INNER) INSIDE PWELi
  NTAP_guard_ring_wide_hole = (HOLES NTAP_guard_ring_wide INNER) INSIDE NWELi

  PTAP_guard_ring_hole_check = PTAP_guard_ring_holex NOT INSIDE PTAP_guard_ring_wide_hole
  NTAP_guard_ring_hole_check = NTAP_guard_ring_holex NOT INSIDE NTAP_guard_ring_wide_hole
  PTAP_guard_ring_check = PTAPi COIN OUTSIDE EDGE PTAP_guard_ring_hole_check
  NTAP_guard_ring_check = NTAPi COIN OUTSIDE EDGE NTAP_guard_ring_hole_check
  INT PTAP_guard_ring_check PTAPi < LUP_4 ABUT < 90 REGION
  INT NTAP_guard_ring_check NTAPi < LUP_4 ABUT < 90 REGION
}

#IFDEF 1.8V
LUP.5.1g_1.8V {@ Minimum space >= ^LUP_5_1 um

               @ 1. between N+ OD injector and the the 1.8V PMOS in the internal circuit 
               @ 2. between 1.8V P+ OD injector and the NMOS in the internal circuit  
   EXT POST_DRIVER_PINJ_NW_LV BESIDE_POST_DRIVER_NMOS_PW < LUP_5_1 ABUT < 90 SINGULAR REGION
   EXT POST_DRIVER_PINJ_NW_LV BESIDE_POST_DRIVER_NMOS_RW < LUP_5_1 ABUT < 90 SINGULAR REGION CONNECTED 
   EXT POST_DRIVER_PINJ_NWi_LV BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_LV < LUP_5_1 ABUT < 90 SINGULAR REGION
   EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_LV < LUP_5_1 ABUT < 90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_LV < LUP_5_1 ABUT < 90 SINGULAR REGION NOT CONNECTED

}
#ENDIF



#IFDEF 1.5V
LUP.5.1g_1.5V {@ Minimum space >= ^LUP_5_1 um
               @ 1. between N+ OD injector and the the 1.5V PMOS in the internal circuit 
               @ 2. between 1.5V P+ OD injector and the NMOS in the internal circuit

EXT POST_DRIVER_PINJ_NW_LV BESIDE_POST_DRIVER_NMOS_PW < LUP_5_1 ABUT < 90 SINGULAR REGION
   EXT POST_DRIVER_PINJ_NW_LV BESIDE_POST_DRIVER_NMOS_RW < LUP_5_1 ABUT < 90 SINGULAR REGION CONNECTED 
   EXT POST_DRIVER_PINJ_NWi_LV BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_LV < LUP_5_1 ABUT < 90 SINGULAR REGION
   EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_LV < LUP_5_1 ABUT < 90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_LV < LUP_5_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
   
}
#ENDIF


#IFDEF 2.5V
LUP.5.2g_2.5V {@ Minimum space >= ^LUP_5_2 um
 @ 1. between N+ OD injector and the the 2.5V PMOS in the internal circuit 
               @ 2. between 2.5V P+ OD injector and the NMOS in the internal circuit  
  EXT POST_DRIVER_PINJ_NW_HV BESIDE_POST_DRIVER_NMOS_PW < LUP_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PINJ_NW_HV BESIDE_POST_DRIVER_NMOS_RW < LUP_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PINJ_NWi_HV BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_HV < LUP_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_HV < LUP_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_HV < LUP_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED

}
#ENDIF



#IFDEF 3.3V
LUP.5.3g_3.3V {@ Minimum space >= ^LUP_5_3 um
   @ 1. between N+ OD injector and the the 3.3V PMOS in the internal circuit 
               @ 2. between 3.3V P+ OD injector and the NMOS in the internal circuit  
  EXT POST_DRIVER_PINJ_NW_HV BESIDE_POST_DRIVER_NMOS_PW < LUP_5_3 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PINJ_NW_HV BESIDE_POST_DRIVER_NMOS_RW < LUP_5_3 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PINJ_NWi_HV BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_3 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_HV < LUP_5_3 ABUT < 90 SINGULAR REGION 
  EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_HV < LUP_5_3 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_HV < LUP_5_3 ABUT < 90 SINGULAR REGION NOT CONNECTED

}
#ENDIF


#IFDEF 5V




LUP.5.4g_5V {@ Minimum space >= ^LUP_5_4 um
             @ 1. between N+ OD injector and the the 5V PMOS in the internal circuit 
             @ 2. between 5V P+ OD injector and the NMOS in the internal circuit			  

  EXT POST_DRIVER_PINJ_NW_HV BESIDE_POST_DRIVER_NMOS_PW_1 < LUP_5_4 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_PINJ_NW_HV BESIDE_POST_DRIVER_NMOS_RW_1 < LUP_5_4 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_PINJ_NWi_HV BESIDE_POST_DRIVER_NMOS_RWi_1 < LUP_5_4 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NINJ_PW BESIDE_POST_DRIVER_PMOS_NW_HV_1 < LUP_5_4 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NINJ_RW BESIDE_POST_DRIVER_PMOS_NW_HV_1 < LUP_5_4 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NINJ_RWi BESIDE_POST_DRIVER_PMOS_NWi_HV_1 < LUP_5_4 ABUT < 90 SINGULAR REGION NOT CONNECTED
}



#ENDIF





CO_PACT = COi OR (PSDc NOT OUTSIDE COi)
NPUi = NTAPi INTERACT CO_PACT
NPUi_SRAM = NPUi INSIDE SRM

NSTP_OS = SIZE NPUi BY LUP_6 INSIDE OF NWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
NSTP_OS_SRAM = SIZE NPUi_SRAM BY LUP_6_SRAM INSIDE OF NWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7



PACT_CHECK = ((PACTi INTERACT COi) INTERACT POLYi) NOT POLYi
PACT_CHECK_NON_SRAM = PACT_CHECK NOT INSIDE SRM 
PACT_CHECK_SRAM =  PACT_CHECK INSIDE SRM
CO_NACT = COi OR (NSDc NOT OUTSIDE COi)
PPUi = PTAPi INTERACT CO_NACT
PPUi_SRAM = PPUi INSIDE SRM

PSTP_OS = SIZE PPUi BY LUP_6 INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
PSTP_OS_SRAM = SIZE PPUi_SRAM BY LUP_6_SRAM INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7

NACT_CHECK = ((NACTi INTERACT COi) INTERACT POLYi) NOT POLYi
NACT_CHECK_NON_SRAM = NACT_CHECK NOT INSIDE SRM 
NACT_CHECK_SRAM =  NACT_CHECK INSIDE SRM

LUP.6g { @ Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= ^LUP_6 um
        @ Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= ^LUP_6 um
	@ In SRAM bit cell region, the rule is relaxed to ^LUP_6_SRAM um    
  PACT_CHECK_NON_SRAM NOT NSTP_OS
  PACT_CHECK_SRAM NOT (NSTP_OS OR NSTP_OS_SRAM)
  NACT_CHECK_NON_SRAM NOT PSTP_OS
  NACT_CHECK_SRAM NOT (PSTP_OS OR PSTP_OS_SRAM)

}

// LUP.10 is checked by LUP.10__LUP.13
// LUP.13 is checked by LUP.10__LUP.13
#IFDEF ALL_AREA_IO
LUP.10g__LUP.13g { @ For Area I/O, within ^LUP_10 um from OD injector,
#ELSE
LUP.10g__LUP.13g { @ For Area I/O, within ^LUP_10 um from OD injector (covered by LUPWDMY_2),
#ENDIF
@ Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= ^LUP_13 um
@ Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= ^LUP_13 um
#IFDEF ALL_AREA_IO
  TRIGGER_SOURCE  = COPY POST_DRIVER_ACT 
#ELSE
  TRIGGER_SOURCE  = POST_DRIVER_ACT NOT OUTSIDE LUPWDMY_2
#ENDIF

  CORE_LOGIC_NACT = (NACT_CHECK NOT TRIGGER_SOURCE) NOT INSIDE PTAP_guard_ring_hole
  CORE_LOGIC_PACT = (PACT_CHECK NOT TRIGGER_SOURCE) NOT INSIDE NTAP_guard_ring_hole

  NACT_LUP = CORE_LOGIC_NACT NOT OUTSIDE (SIZE TRIGGER_SOURCE BY LUP_10)
  PACT_LUP = CORE_LOGIC_PACT NOT OUTSIDE (SIZE TRIGGER_SOURCE BY LUP_10)
  
  PSTP_OS = SIZE PPUi BY LUP_13 INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
  NACT_LUP NOT PSTP_OS

  NSTP_OS = SIZE NPUi BY LUP_13 INSIDE OF NWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
  PACT_LUP NOT NSTP_OS
}
// LUP.11 is not necessary to check. It is checked in Calibre PERC.
// LUP.12 is not necessary to check. It is checked in Calibre PERC.
LUP.14g { @ For Area I/O, width of picup ring and guard rings for the OD injector >= ^LUP_14
#IFDEF ALL_AREA_IO
  AREA_IO_NACT = COPY POST_DRIVER_NACT 
  AREA_IO_PACT = COPY POST_DRIVER_PACT
#ELSE
  AREA_IO_NACT = POST_DRIVER_NACT NOT OUTSIDE LUPWDMY_2
  AREA_IO_PACT = POST_DRIVER_PACT NOT OUTSIDE LUPWDMY_2
#ENDIF

  AREA_IO_NACT NOT INSIDE PTAP_guard_ring_hole
  AREA_IO_PACT NOT INSIDE NTAP_guard_ring_hole
  PTAP_guard_ring_2nd = ((HOLES PTAPi INNER) INTERACT AREA_IO_PACT) NOT INTERACT NACT
  NTAP_guard_ring_2nd = ((HOLES NTAPi INNER) INTERACT AREA_IO_NACT) NOT INTERACT PACT
  AREA_IO_NACT NOT INSIDE NTAP_guard_ring_2nd
  AREA_IO_PACT NOT INSIDE PTAP_guard_ring_2nd

  PTAP_guard_ring_hole_edge = PTAPi COIN OUTSIDE EDGE (PTAP_guard_ring_hole INTERACT AREA_IO_NACT)
  NTAP_guard_ring_hole_edge = NTAPi COIN OUTSIDE EDGE (NTAP_guard_ring_hole INTERACT AREA_IO_PACT)
  INT PTAP_guard_ring_hole_edge PTAPi < LUP_14 ABUT < 90 REGION
  INT NTAP_guard_ring_hole_edge NTAPi < LUP_14 ABUT < 90 REGION

  PTAP_guard_ring_2nd_edge = PTAPi COIN OUTSIDE EDGE PTAP_guard_ring_2nd
  NTAP_guard_ring_2nd_edge = NTAPi COIN OUTSIDE EDGE NTAP_guard_ring_2nd
  INT PTAP_guard_ring_2nd_edge PTAPi < LUP_14 ABUT < 90 REGION
  INT NTAP_guard_ring_2nd_edge NTAPi < LUP_14 ABUT < 90 REGION

}
#ENDIF



















// LOGO CHECKS
//============

LOGO.S.1 { @ Min. LOGO space to NW, OD, PO, or Metals >= 3um
  LOGO_EXT = (SIZE LOGO BY 3) NOT LOGO      
  LOGO_EXT AND NWELi


  LOGO_EXT AND ALL_OD 
  LOGO_EXT AND ALL_PO
  LOGO_EXT AND (M1i OR M1DMY)
  LOGO_EXT AND (M2i OR M2DMY)
  LOGO_EXT AND (M3i OR M3DMY)
  LOGO_EXT AND (M4i OR M4DMY)
  LOGO_EXT AND (M5i OR M5DMY)
  LOGO_EXT AND (M6i OR M6DMY)
  LOGO_EXT AND (MD OR MDDMY)
}





LOGO.O.1 { @ LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, PPI or DMx is not allowed.
  LOGO AND CBi
  LOGO AND CBDi
  LOGO AND PPIi
  LOGO AND FWi
  LOGO AND PLMIDEi
  LOGO AND UBMi
  LOGO AND DOD
  LOGO AND DPO
  LOGO AND M1DMY
  LOGO AND M2DMY
  LOGO AND M3DMY
  LOGO AND M4DMY
  LOGO AND M5DMY
  LOGO AND M6DMY
  LOGO AND MDDMY
}
LOGO.R.1 { @ A circuit in LOGO is not allowed.
  LOGO AND ALL_GATE
  LOGO AND PORES
  LOGO AND ODRES
  LOGO AND RNWEL
  LOGO AND BJTDUMMY
  LOGO AND DIODUMMY
  LOGO AND VARDMY

  LOGO AND CTM5i


}


//LOGO.R.2 has been check by other DRC rules




#IFDEF FULL_CHIP
#IFDEF WITH_SEALRING

// Sealring Rulecheck
//=================================
SR.S.1 { @ Minimum width of Assembly isolation >= ^SR_S_1 um
	ASS_REGION AND COi
	ASS_REGION AND DNWi
	ASS_REGION AND NWELi
	ASS_REGION AND POLYi
	ASS_REGION AND DPO
	ASS_REGION AND ODi
	ASS_REGION AND DOD
	ASS_REGION AND VIA1i
	ASS_REGION AND VIA2i
	ASS_REGION AND VIA3i
	ASS_REGION AND VIA4i
	ASS_REGION AND VIA5i
	ASS_REGION AND M1i
	ASS_REGION AND M2i
	ASS_REGION AND M3i
	ASS_REGION AND M4i
	ASS_REGION AND M5i
	ASS_REGION AND M6i
	ASS_REGION AND VIADi
	ASS_REGION AND MDi
	ASS_REGION AND UBMi
	ASS_REGION AND CBDi
	ASS_REGION AND CBi
}

SR.R.1 { @ sealring layer (126;0) is a must if customer adds sealring by thenmselves.
	CHIPx NOT INTERACT SEALRING
}




SR.E.1 { @ Minimum extension of metal to CO/VIA in seal ring. >= ^SR_E_1 um
    ENC SR_CO M1 < SR_E_1 ABUT < 90 SINGULAR REGION
    SR_CO NOT M1
    ENC SR_VIA1 M1 < SR_E_1 ABUT < 90 SINGULAR REGION
    SR_VIA1 NOT M1 
    ENC SR_VIA1 M2 < SR_E_1 ABUT < 90 SINGULAR REGION
    SR_VIA1 NOT M2
    ENC SR_VIA2 M2 < SR_E_1 ABUT < 90 SINGULAR REGION
    SR_VIA2 NOT M2 
    ENC SR_VIA2 M3 < SR_E_1 ABUT < 90 SINGULAR REGION
    SR_VIA2 NOT M3
    ENC SR_VIA3 M3 < SR_E_1 ABUT < 90 SINGULAR REGION
    SR_VIA3 NOT M3 
    ENC SR_VIA3 M4 < SR_E_1 ABUT < 90 SINGULAR REGION
    SR_VIA3 NOT M4
    ENC SR_VIA4 M4 < SR_E_1 ABUT < 90 SINGULAR REGION
    SR_VIA4 NOT M4 
    ENC SR_VIA4 M5 < SR_E_1 ABUT < 90 SINGULAR REGION
    SR_VIA4 NOT M5
    ENC SR_VIA5 M5 < SR_E_1 ABUT < 90 SINGULAR REGION
    SR_VIA5 NOT M5 
    ENC SR_VIA5 M6 < SR_E_1 ABUT < 90 SINGULAR REGION
    SR_VIA5 NOT M6
}

SR.E.2 { @ (OD interact sealring) enclosure of metal with the outer edge of sealring == ^SR_E_2 um
    SR_OD = OD INTERACT SEALRING
    SR_OD_HOLES = HOLES SR_OD
    SR_OD_FULL = SR_OD OR SR_OD_HOLES
    ENC SR_M1 SR_OD_FULL < SR_E_2 REGION
    ENC SR_M2 SR_OD_FULL < SR_E_2 REGION
    ENC SR_M3 SR_OD_FULL < SR_E_2 REGION
    ENC SR_M4 SR_OD_FULL < SR_E_2 REGION
    ENC SR_M5 SR_OD_FULL < SR_E_2 REGION
    ENC SR_M6 SR_OD_FULL < SR_E_2 REGION
	SR_OD_FULL_SIZE = SIZE SR_OD_FULL BY -SR_E_2
	SR_OD_FULL_SIZE NOT COIN INSIDE EDGE SR_M1
	SR_OD_FULL_SIZE NOT COIN INSIDE EDGE SR_M2
	SR_OD_FULL_SIZE NOT COIN INSIDE EDGE SR_M3
	SR_OD_FULL_SIZE NOT COIN INSIDE EDGE SR_M4
	SR_OD_FULL_SIZE NOT COIN INSIDE EDGE SR_M5
	SR_OD_FULL_SIZE NOT COIN INSIDE EDGE SR_M6
}



SR.R.2 { @ It's not allowed that odd VIA bar(VIA1,3,5) overlap even VIA bar(VIA2,4)
	SR_VIA1 AND SR_VIA2
	SR_VIA2 AND SR_VIA3
	SR_VIA3 AND SR_VIA4
	SR_VIA4 AND SR_VIA5
}



CO.W.2 { @ Minimum and maximum width of CO bar. CO bar is only allowed in seal ring. == ^CO_W_2 um
    INT SR_CO < CO_W_2 SINGULAR REGION
    SR_CO WITH WIDTH > CO_W_2
}

VIA1.W.2 { @ Minimum and maximum width of VIAx bar. VIAx bar is only allowed in seal ring. == ^VIA1_W_2 um
    INT SR_VIA1 < VIA1_W_2 SINGULAR REGION
    SR_VIA1 WITH WIDTH > VIA1_W_2
}
VIA2.W.2 { @ Minimum and maximum width of VIAx bar. VIAx bar is only allowed in seal ring. == ^VIA2_W_2 um
    INT SR_VIA2 < VIA2_W_2 SINGULAR REGION
    SR_VIA2 WITH WIDTH > VIA2_W_2
}
VIA3.W.2 { @ Minimum and maximum width of VIAx bar. VIAx bar is only allowed in seal ring. == ^VIA3_W_2 um
    INT SR_VIA3 < VIA3_W_2 SINGULAR REGION
    SR_VIA3 WITH WIDTH > VIA3_W_2
}
VIA4.W.2 { @ Minimum and maximum width of VIAx bar. VIAx bar is only allowed in seal ring. == ^VIA4_W_2 um
    INT SR_VIA4 < VIA4_W_2 SINGULAR REGION
    SR_VIA4 WITH WIDTH > VIA4_W_2
}


VIAn.W.2 { @ Minimum and maximum width of VIAn bar. VIAn bar is only allowed in seal ring. == ^VIAn_W_2 um
    INT SR_VIA5 < VIAn_W_2 SINGULAR REGION
    SR_VIA5 WITH WIDTH > VIAn_W_2
}


#IFDEF Recommend

CB.W.3 { @ Mininum width of CB/CBD bar in seal ring region(butts the outer edge of seal ring) >= 2.0 um
	ALL_PAD = CB OR CBD
    C = SEALRING_ALL OR (HOLES SEALRING_ALL)
	X = ALL_PAD TOUCH (HOLES ALL_PAD)
    INT X < 2.0 ABUT < 90 SINGULAR REGION
    Y = ALL_PAD OR (HOLES ALL_PAD)
    Y XOR C
}
#ENDIF



#ENDIF

#ENDIF





#IFDEF MIX_MODE

//===============================================================================
// Mixed-Singal/RF part
//===============================================================================


// POLY CHECKS
//==============

PO.W.1_HRI { @ Min. width of PO region for HRI poly resistor >= 1.0um
  HREPC = HREP INTERACT RLPPDMY
  INT HREPC < 1.0 ABUT < 90 SINGULAR REGION    
}
_PO.R.1A.MM { @ 90 degree L shape and U shape bent gates are not allowed
  NORM_GATE_W = GATE_W OUTSIDE EDGE VARDMY
  EXT NORM_GATE_W < 0.18 ABUT == 90 INTERSECTING ONLY
  INT NORM_GATE_W < 0.18 ABUT == 90 INTERSECTING ONLY
}

// PP CHECKS
//============

_PP.E.6.MM { @ Min. extension of a PP region beyond a PO as resistor >= ^PP_E_6_2 um
  ENC PORES PP < PP_E_6_2 ABUT < 90 SINGULAR REGION
  ((RPO AND POLY) NOT IMP) NOT HRI
}

// RPO CHECKS
//=============
RPO.O.1_HRI { @ Min. and Max. overlap of a PP region to RPO region for HRI == 0.3um
  X = POLY_ISO INTERACT HRI
  Y = RPO INSIDE EDGE X
  INT PP Y < 0.3 ABUT < 90
  Y OUTSIDE EDGE PP	// not overlap by P+ not allowed.
  Z = EXPAND EDGE Y INSIDE BY 0.30
  PPPO = PP AND POLY
  A = PPPO AND PORES
  B = A INTERACT HRI
  B NOT Z
}



#IFNDEF C0152

// M6 checks
//=============


M6T_NIND = M6xd NOT INDDMY

INDDMYI = SIZE INDDMY BY -7 //exclude M1 substrate pick up node
INDM = INDDMY AND M4
INDME = INDM COINCIDENT INSIDE EDGE INDDMY
INDDMYA = INDDMY WITH EDGE INDME <2
INDDMY3 = INDDMYA ENCLOSE M5 //for 3 terminals inductor(central tap)
INDDMY2 = INDDMY NOT INDDMY3 //for 2 terminals inductor



#IFDEF THICK_20K

UTM20K.W.1 { @ Min. M6 width >= ^UTM20K_W_1 um
  INT M6 < UTM20K_W_1 ABUT < 90 SINGULAR REGION
}
UTM20K.S.1 { @ Min. M6 spacing >= ^UTM20K_S_1 um
  EXT M6 < UTM20K_S_1 ABUT < 90 SINGULAR REGION
}
UTM20K.E.1 { @ Min. extension of a M6 region beyond a VIA5 region >= 0.3 um
  ENC VIA5 M6 < 0.3 ABUT < 90 SINGULAR REGION
  VIA5 NOT M6    
}
UTM20K.E.2 { @ Min. extension of M6 end-of-line region beyond VIA5 region >= 0.45 um
  X = ENC [VIA5] M6 < 0.45 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.36 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}
UTM20K.S.2 { @ Min. space of Wide M6 (>16um) and M6 >= 3.0 um (exclude application for inductor)
  M6T_NIND_S8 = SHRINK (SHRINK (SHRINK (SHRINK M6T_NIND RIGHT BY 8) LEFT BY 8) TOP BY 8) BOTTOM BY 8
  M6T_NIND_G8 = GROW (GROW (GROW (GROW M6T_NIND_S8 RIGHT BY 8) LEFT BY 8) TOP BY 8) BOTTOM BY 8
  M6T_NIND_Wide = M6T_NIND_G8 AND M6T_NIND
  M6T_NIND_Exp = SIZE M6T_NIND_Wide BY 1 INSIDE OF M6T_NIND STEP 1.05
  M6T_NIND_Branch = M6T_NIND_Exp NOT M6T_NIND_Wide
  M6T_NIND_Branch_edge = M6T_NIND_Branch COIN INSIDE EDGE M6T_NIND
  M6T_NIND_Check = M6T_NIND AND (SIZE M6T_NIND_Exp BY 3.0)
  M6T_NIND_Branch_Check = M6T_NIND AND (EXPAND EDGE M6T_NIND_Branch_edge OUTSIDE BY 3.0 CORNER FILL)
  M6T_NIND_WideC = STAMP M6T_NIND_Wide BY M6xd
  M6T_NIND_CheckC = STAMP M6T_NIND_Check BY M6xd
  M6T_NIND_BranchC = STAMP M6T_NIND_Branch BY M6xd
  M6T_NIND_Branch_CheckC = STAMP M6T_NIND_Branch_Check BY M6xd
  EXT M6T_NIND_WideC M6T_NIND_CheckC < 3.0 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M6T_NIND_BranchC M6T_NIND_Branch_CheckC < 3.0 ABUT >0 <89.5 NOT CONNECTED REGION
}
UTM20K.A.1 { @ Min. area of M6 region >= ^UTM20K_A_1 um2
  AREA M6 < UTM20K_A_1
}
UTM20K.R.1 { @ Min. density of M6 area >= 30% (exclude application for inductor)
  CHIP_NIND = CHIP NOT INDDMY
  DENSITY M6T_NIND CHIP_NIND < 0.3 PRINT M6T_DENSITY.log
  [ AREA(M6T_NIND)/AREA(CHIP_NIND) ]
}
#IFDEF Recommend
UTM20K.C.1 { @ Min. clearance from M6 as inductor to M6 >= ^UTM20K_C_1 um



  IND_M6 =  M6 INTERACT ( SIZE INDDMY BY -(UTM20K_C_1 + 0.5) )
  IND_M6V5 = VIA5 INTERACT IND_M6
  IND_M5 = M5 INTERACT IND_M6V5
  IND_M5V5 = VIA5 INTERACT IND_M5
  IND_M6_CONN = M6 INTERACT IND_M5V5
  IND_M6_ALL = IND_M6 OR IND_M6_CONN
  IM6 = IND_M6_ALL AND INDDMY
  RM6 = M6 NOT IND_M6_ALL
  OM6 = IND_M6_ALL NOT IM6
  EXT RM6 IM6 < UTM20K_C_1 ABUT < 90 SINGULAR REGION 
  EXT IM6 OM6 < UTM20K_C_1 ABUT > 0 < 90 PROJ > 0 REGION 
}
#ENDIF

UTM20K.E.3 { @ Min. extension of INDDMY beyond M6 >= ^UTM20K_E_3 um
  ENC M6 INDDMY < UTM20K_E_3 ABUT > 0 < 90 SINGULAR REGION
}
UTM20K.I.1 { @ No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect,
           @ and the M1 substrate pick up node of inductor
  AND INDDMYI M1
  AND INDDMY VIA1	
  AND INDDMY M2
  AND INDDMY VIA2
  AND INDDMY M3
  AND INDDMY VIA3
  AND INDDMY2 M4
  AND INDDMY2 VIA4	    
}
UTM20K.I.2 { @ Both active and passive devices not allow inside INDDMY besides guard ring
  AND INDDMY NWEL
  AND INDDMY POLY
  AND INDDMYI OD //exclude M1 substrate pick up node of inductor
}
#IFDEF Recommend
UTM20K.I.3 { @ It is recommended that NT_N fully overlap the region of inductor to achieve the high quality factor.
	INDDMY NOT NTN
}
#ENDIF
#ENDIF



#IFNDEF C016


#IFDEF THICK_40K
UTM40K.W.1 { @ Min. M6 width >= ^UTM40K_W_1 um
  INT M6 < UTM40K_W_1 ABUT < 90 SINGULAR REGION
}
UTM40K.S.1 { @ Min. M6 space >= ^UTM40K_S_1 um
  EXT M6 < UTM40K_S_1 ABUT < 90 SINGULAR REGION
}
UTM40K.E.1 { @ Min. extension of a M6 region beyond a VIA5 region >= 0.4 um
  ENC VIA5 M6 < 0.4 ABUT < 90 SINGULAR REGION
  VIA5 NOT M6  
}
UTM40K.E.2 { @ Min. extension of M6 end-of-line region beyond VIA5 region >= 0.45 um
  X = ENC [VIA5] M6 < 0.45 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.36 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}
UTM40K.S.2 { @ Min. space of Wide M6 (>16um) and M6 >= 4.0 um (exclude application for inductor)
  M6T_NIND_S8 = SHRINK (SHRINK (SHRINK (SHRINK M6T_NIND RIGHT BY 8) LEFT BY 8) TOP BY 8) BOTTOM BY 8
  M6T_NIND_G8 = GROW (GROW (GROW (GROW M6T_NIND_S8 RIGHT BY 8) LEFT BY 8) TOP BY 8) BOTTOM BY 8
  M6T_NIND_Wide = M6T_NIND_G8 AND M6T_NIND
  M6T_NIND_Exp = SIZE M6T_NIND_Wide BY 1 INSIDE OF M6T_NIND STEP 1.75
  M6T_NIND_Branch = M6T_NIND_Exp NOT M6T_NIND_Wide
  M6T_NIND_Branch_edge = M6T_NIND_Branch COIN INSIDE EDGE M6T_NIND
  M6T_NIND_Check = M6T_NIND AND (SIZE M6T_NIND_Exp BY 4.0)
  M6T_NIND_Branch_Check = M6T_NIND AND (EXPAND EDGE M6T_NIND_Branch_edge OUTSIDE BY 4.0 CORNER FILL)
  M6T_NIND_WideC = STAMP M6T_NIND_Wide BY M6xd
  M6T_NIND_CheckC = STAMP M6T_NIND_Check BY M6xd
  M6T_NIND_BranchC = STAMP M6T_NIND_Branch BY M6xd
  M6T_NIND_Branch_CheckC = STAMP M6T_NIND_Branch_Check BY M6xd
  EXT M6T_NIND_WideC M6T_NIND_CheckC < 4.0 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M6T_NIND_BranchC M6T_NIND_Branch_CheckC < 4.0 ABUT >0 <89.5 NOT CONNECTED REGION
}
UTM40K.A.1 { @ Min. area of M6 region >= ^UTM40K_A_1 um2
  AREA M6 < UTM40K_A_1
}
UTM40K.R.1 { @ Min. density of M6 area >= 30% (exclude application for inductor)
  CHIP_NIND = CHIP NOT INDDMY
  DENSITY M6T_NIND CHIP_NIND < 0.3 PRINT M6T_DENSITY.log
  [ AREA(M6T_NIND)/AREA(CHIP_NIND) ]
}
#IFDEF Recommend
UTM40K.C.1 { @ Min. clearance from M6 as inductor to M6 >= ^UTM40K_C_1 um



  IND_M6 =  M6 INTERACT ( SIZE INDDMY BY -(UTM40K_C_1 + 0.5) )
  IND_M6V5 = VIA5 INTERACT IND_M6
  IND_M5 = M5 INTERACT IND_M6V5
  IND_M5V5 = VIA5 INTERACT IND_M5
  IND_M6_CONN = M6 INTERACT IND_M5V5
  IND_M6_ALL = IND_M6 OR IND_M6_CONN
  IM6 = IND_M6_ALL AND INDDMY
  RM6 = M6 NOT IND_M6_ALL
  OM6 = IND_M6_ALL NOT IM6
  EXT RM6 IM6 < UTM40K_C_1 ABUT < 90 SINGULAR REGION 
  EXT IM6 OM6 < UTM40K_C_1 ABUT > 0 < 90 PROJ > 0 REGION 
}
#ENDIF

UTM40K.E.3 { @ Min. extension of INDDMY beyond M6 >= ^UTM40K_E_3 um
  ENC M6 INDDMY < UTM40K_E_3 ABUT > 0 < 90 SINGULAR REGION
}
UTM40K.I.1 { @ No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect,
           @ and the M1 substrate pick up node of inductor
  AND INDDMYI M1
  AND INDDMY VIA1	
  AND INDDMY M2
  AND INDDMY VIA2
  AND INDDMY M3
  AND INDDMY VIA3
  AND INDDMY2 M4
  AND INDDMY2 VIA4	    
}
UTM40K.I.2 { @ Both active and passive devices not allow inside INDDMY besides guard ring
  AND INDDMY NWEL
  AND INDDMY POLY
  AND INDDMYI OD //exclude M1 substrate pick up node of inductor
}
#IFDEF Recommend
UTM40K.I.3 { @ It is recommended that NT_N fully overlap the region of inductor to achieve the high quality factor.
  INDDMY NOT NTN
}
#ENDIF
UTM40K.R.2 { @ Max. density of {UTM OR dummy UTM} area <= ^UTM40K_R_2% 
			 @ Exclude application for inductor
  CHIP_NIND = CHIP NOT INDDMY
  DENSITY M6T_NIND CHIP_NIND > UTM40K_R_2/100 PRINT M6T_DENSITY_MAX.log
  	[ AREA(M6T_NIND) / AREA(CHIP_NIND) ]
}

UTM40K.R.3 { @ The square number for dummy UTM <= ^UTM40K_R_3 
			 @ DRC only flag rectangle
  M6DMY_REC = RECTANGLE M6DMY ORTHOGONAL ONLY
  NOT RECTANGLE M6DMY_REC ASPECT <= UTM40K_R_3
}
M6_small = AREA M6 < UTM40K_A_2
M6_convex = CONVEX EDGE M6_small == 2

M6_small_R_edge = (GROW M6_small RIGHT BY GRID) NOT M6_small
M6_small_R_end = ANGLE (M6_convex TOUCH EDGE M6_small_R_edge) == 90
M6_small_R_good = EXT [M6_small_R_end] M6 < UTM40K_A_2_S OPPOSITE
M6_small_R_bad = M6_small_R_end NOT TOUCH EDGE M6_small_R_good
M6_small_R_excl = M6_small NOT WITH EDGE M6_small_R_bad

M6_small_T_edge = (GROW M6_small TOP BY GRID) NOT M6_small
M6_small_T_end = ANGLE (M6_convex TOUCH EDGE M6_small_T_edge) == 0
M6_small_T_good = EXT [M6_small_T_end] M6 < UTM40K_A_2_S OPPOSITE
M6_small_T_bad = M6_small_T_end NOT TOUCH EDGE M6_small_T_good
M6_small_T_excl = M6_small NOT WITH EDGE M6_small_T_bad

M6_small_L_edge = (GROW M6_small LEFT BY GRID) NOT M6_small
M6_small_L_end = ANGLE (M6_convex TOUCH EDGE M6_small_L_edge) == 90
M6_small_L_good = EXT [M6_small_L_end] M6 < UTM40K_A_2_S OPPOSITE
M6_small_L_bad = M6_small_L_end NOT TOUCH EDGE M6_small_L_good
M6_small_L_excl = M6_small NOT WITH EDGE M6_small_L_bad

M6_small_B_edge = (GROW M6_small BOTTOM BY GRID) NOT M6_small
M6_small_B_end = ANGLE (M6_convex TOUCH EDGE M6_small_B_edge) == 0
M6_small_B_good = EXT [M6_small_B_end] M6 < UTM40K_A_2_S OPPOSITE
M6_small_B_bad = M6_small_B_end NOT TOUCH EDGE M6_small_B_good
M6_small_B_excl = M6_small NOT WITH EDGE M6_small_B_bad

UTM40K.A.2 { @ Min. area of {UTM OR dummy UTM} island >= ^UTM40K_A_2 um2
			 @ UTM island: space to another adjacent edge of {UTM or dummy UTM} >= ^UTM40K_A_2_S um
  M6_small NOT INTERACT (((M6_small_R_excl OR M6_small_T_excl) OR M6_small_L_excl) OR M6_small_B_excl)
}

#ENDIF

#ENDIF


#ENDIF



// DNW CHECKS
//==============

RW = PWEL INSIDE DNW

#IFNDEF C016
#IFNDEF C0152


DNW.W.1 { @ Min. width of a DNW region >= 3um
  INT DNW < 3.0 ABUT < 90 SINGULAR REGION
}
DNW.S.1 { @ Min. space between two DNW regions >= 5um
  EXT DNW < 5.0 ABUT < 90 SINGULAR REGION
}
#ENDIF
#ENDIF


#IFDEF Recommend
RW_NODAL = STAMP RW BY RWi
PWELx = PWEL NOT INSIDE DNW
PWEL_NODAL = STAMP PWELx BY PWELi
DNW.S.2 { @ Min. space between RW and {RW OR PW} with different potential >= 1.4um
  EXT RW_NODAL < 1.4 ABUT < 90 NOT CONNECTED SINGULAR REGION
  EXT RW_NODAL PWEL_NODAL < 1.4 ABUT < 90 NOT CONNECTED SINGULAR REGION  
}
#ENDIF

DNW.O.1 { @ Min. overlap from a NW edge to a DNW region >= 2.0um
  INT DNW NWEL < 2.0 ABUT < 90 SINGULAR REGION
}
CONNECT NWEL DNW
DNW.C.1 { @ Min. clearance from DNW to NW >= 3.5um
  EXT NWEL DNW < 3.5 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
DNW.C.4 { @ Min. clearance from DNW to N+OD outside NW >= 3.0um
  A = PWEL NOT DNW
  B = NPOD INTERACT A
  EXT B DNW < 3.0 ABUT < 90 SINGULAR REGION
  CUT B DNW
}
#IFDEF Recommend
// DNW.R.3 is a recommended rule and un-checkable.
DNW.E.1 { @ Min. extension of NW beyond DNW for a better noise isolation >= 1.5um
  ENC DNW NWEL < 1.5 ABUT < 90 SINGULAR REGION
  ( DNW NOT INTERACT SBDDMY ) OUTSIDE EDGE NWEL
}
#ENDIF

DNW.E.2 { @ Min. extension of DNW beyond N+OD outside NW >= 1.5um
  A = PWEL AND DNW
  B = NPOD INTERACT A
  ENC B DNW < 1.5 ABUT < 90 SINGULAR REGION
  CUT B DNW
}
DNW.R.4 { @ It is not allowed to use DNW as a resistor
  AND DNW RWDMY
}
DNW.R.5 { @ It is not allowed to use {NW interact DNW} as a resistor
  INTERACT RNWEL DNW
  INTERACT NWRES DNW
}
#IFDEF C016
DNW.W.1 { @ Min. DNW width < 3.3
  INT DNW < 3.3 ABUT<90 SINGULAR REGION
}
DNW.S.1 { @ Min. DNW space < 5.5
  EXT DNW < 5.5 ABUT<90 SINGULAR REGION
}
#ENDIF
#IFNDEF C016
#IFDEF C0152
DNW.W.1 { @ Min. width of a DNW region >= ^DNW_W_1_0152
	INT DNW < DNW_W_1_0152 ABUT < 90 SINGULAR REGION 
}
DNW.S.1 { @ Min. space between two DNW regions >= ^DNW_S_1_0152
	EXT DNW < DNW_S_1_0152 ABUT < 90 SINGULAR REGION 
}

#ENDIF
#ENDIF




//VTM_N
//=====
 
VTM_N.W.1 { @ Min. dimension of a VTM_N region >= 0.74um
  INT VTMN < 0.74 ABUT < 90 SINGULAR REGION
}
VTM_N.W.2 { @ Min. PO gate dimension of a 1.8V medium Vt NMOS >= 0.3um
  Z = GATE_W INSIDE EDGE VTMN
  INT Z < 0.3 ABUT < 90 REGION
}

VTM_N.W.3 { @ Min. PO gate dimension of a 3.3V medium Vt NMOS >= 0.6um
  Z = HV_NGATE_W INSIDE EDGE VTMN
  INT Z < 0.6 ABUT < 90 REGION
}


VTM_N.S.1 { @ Min. space between two VTM_N regions >= 0.44um
  EXT VTMN < 0.44 ABUT < 90 SINGULAR REGION
}
VTM_N.E.1 { @ Min. extension from a VTM_N region beyond an N+OD region >= 0.26um
  ENC NACT VTMN < 0.26 ABUT < 90 SINGULAR REGION
  NACT CUT VTMN    
}
VTM_N.C.1 { @ Min. clearance from a VTM_N region to an N+OD region >= 0.7um
  EXT NACT VTMN < 0.7 ABUT < 90 SINGULAR REGION
}
VTM_N.C.2 { @ Min. clearance from a VTM_N region to an NW edge >= 0.43um
  EXT VTMN NWEL < 0.43 ABUT < 90 SINGULAR REGION
  VTMN AND NWEL    
}

VTM_N.R.2 {@ VTM_N interact NT_N is not allowed (butted is allowed)
  VTMN AND NTN
}


VTM_N.R.3 {@ A P+ Gate is not allowed in VTM_N region
  VTMN AND GATE_PP
}
VTM_N.R.4 {@ A bent PO region is not allowed in VTM_N region
  VTMN_PO = POLY AND VTMN
  VERTEX VTMN_PO != 4
}
VTM_N.R.5 { @ Min. clearance from an OD region in VTM_N region to a PO on field oxide >= 0.26um
  VTMN_OD = VTMN AND OD
  EXT VTMN_OD POLY_ISO < 0.26 ABUT > 0 < 90 SINGULAR REGION
}  


// VTM_P
//======
 
VTM_P.W.1 { @ Min. dimension of a VTM_P region >= 0.74um
  INT VTMP < 0.74 ABUT < 90 SINGULAR REGION
}
VTM_P.W.2 { @ Min. PO gate dimension of a 1.8V medium Vt PMOS >= 0.25um
  Z = GATE_W INSIDE EDGE VTMP
  INT Z < 0.25 ABUT < 90 REGION
}
VTM_P.S.1 { @ Min. space between two VTM_P regions >= 0.44um
  EXT VTMP < 0.44 ABUT < 90 SINGULAR REGION
}
VTM_P.E.1 { @ Min. extension from a VTM_P region beyond a P+OD region >= 0.26um
  ENC PACT VTMP < 0.26 ABUT < 90 SINGULAR REGION
  PACT CUT VTMP    
}
VTM_P.C.1 { @ Min. clearance from a VTM_P region to a P+OD region >= 0.7um
  EXT PACT VTMP < 0.7 ABUT < 90 SINGULAR REGION
}
VTM_P.C.2 { @ Min. clearance from a VTM_P region to a PW edge >= 0.43um
  ENC VTMP NWEL < 0.43 ABUT < 90 SINGULAR REGION
  VTMP NOT NWEL    
}
VTM_P.R.2 {@ VTM_P interact NT_N is not allow, butted is allowed
  VTMP AND NTN
}
VTM_P.R.3 { @ VTM_P interact OD2 is not allowed.
  VTMP AND OD2 
}
VTM_P.R.4 {@ A N+ Gate is not allowed in VTM_P region
  VTMP AND GATE_NP
}
VTM_P.R.5 {@ A bent PO region is not allowed in VTM_P region
  VTMP_PO = POLY AND VTMP
  VERTEX VTMP_PO != 4
}
VTM_P.R.6 { @ Min. clearance from an OD region in VTM_P region to a PO on field oxide >= 0.26um
  VTMP_OD = VTMP AND OD
  EXT VTMP_OD POLY_ISO < 0.26 ABUT > 0 < 90 SINGULAR REGION
}   





//HRI  
//=== 

HRI.W.1 { @ Min. width of a HRI region >= 0.44um
  INT HRI < 0.44 ABUT < 90 SINGULAR REGION
}
HRI.S.1 { @ Min. space between two HRI regions >= 0.44um
  EXT HRI < 0.44 ABUT < 90 SINGULAR REGION
}
HRI.C.1 { @ Min. clearance from an HRI region to an NP region >= 0.26um
  X = EXT HRI NP < 0.26 ABUT < 90 SINGULAR REGION
  X NOT INTERACT BUTT_PTAP
}
HRI.C.2 { @ Min. clearance from an HRI region to a PP region >= 0.26um
  EXT HRI PP < 0.26 ABUT < 90 SINGULAR REGION
}
HRI.C.3_C.4 { @ Min. clearance from an HRI edge to Poly gate >= 0.32um
  EXT HRI ALL_GATE < 0.32 ABUT < 90 SINGULAR REGION
}
HRI.E.1 { @ Min. enclosure from an HRI region beyond a PO resistor region >= 0.26um
  ENC PORES HRI < 0.26 ABUT < 90 SINGULAR REGION
  ( PORES NOT OUTSIDE HRI ) NOT HRI    
}
HRI.R.1 { @ Overlap of NP and HRI is not allowed
  HRI AND NP
}
HRI.R.2 { @ Overlap of OD and HRI is not allowed
  HRI AND OD
}  
HRI.A.1 { @ Min. area of a HRI region >= 0.3844um2
  HRI AREA < 0.3844
}



// CTM CHECK
//============





TCTM  = CTM5 INTERACT VIA5	// True CTM
DCTM  = CTM5 NOT INTERACT VIA5	// Dummy CTM

BPM5  = SIZE (TCTM NOT INTERACT CMM5) BY 2 INSIDE OF M5 STEP 0.28*0.7 TRUNCATE 0.28*0.7	// CBM = TCTM SIZE 2
DPM5  = M5 INTERACT DCTM	// M5 as a dummy CBM
BPM5C = BPM5 COIN EDGE M5


CTM.W.1 { @ Min. width of a CTM region >= ^CTM_W_1 um
  INT TCTM < CTM_W_1 ABUT < 90 SINGULAR REGION
}
CTM.W.2 { @ Min. width of a dummy CTM region >= ^CTM_W_2 um
  INT DCTM < CTM_W_2 ABUT < 90 SINGULAR REGION
}
CTM.S.1 { @ Min. space between two CTM regions >= ^CTM_S_1 um
  EXT TCTM < CTM_S_1 ABUT < 90 SINGULAR REGION
}
CTM.S.2 { @ Min. space between a dummy CTM and a CTM region or two dummy CTM regions >= ^CTM_S_2 um
  EXT DCTM TCTM < CTM_S_2 ABUT < 90 SINGULAR REGION
  EXT DCTM < CTM_S_2 ABUT < 90 SINGULAR REGION
}

CTM.R.2 { @ Min. density of all CTM area >= 3%
  DENSITY CTM5i > 0 < 0.03 PRINT CTM5i.density
}

//CTM.R.3 is not necessary to check

CTM.W.4 { @ Max. dimension (one side) of a CTM region <= ^CTM_W_4 um
  ENCLOSE RECTANGLE TCTM CTM_W_1 CTM_W_4+GRID ORTHOGONAL ONLY // 4um is min TCTM width
  ENCLOSE RECTANGLE DCTM CTM_W_2 CTM_W_4+GRID ORTHOGONAL ONLY // 0.4um is min DCTM width
}

CTM.A.1 { @ Min. area of CTM region >= ^CTM_A_1 um2
  AREA CTM5 < CTM_A_1
}

//CTM.R.1 is checked by MIM_M5.E.3



CTM.R.5 { @ The MIM capacitor must be placed between M6 amd M5

  COPY CTM2
  COPY CTM3
  COPY CTM4


} 
//Build connection for CTM.R.6
//============================

BULK2	= SIZE CHIP BY 2.0
EMPTY2i = CHIP NOT BULK2

M1m   = EMPTY2i OR M1i 
VIA1m = EMPTY2i OR VIA1i
M2m   = EMPTY2i OR M2i
VIA2m = EMPTY2i OR VIA2i
M3m   = EMPTY2i OR M3i
VIA3m = EMPTY2i OR VIA3i
M4m   = EMPTY2i OR M4i
VIA4m = EMPTY2i OR VIA4i
M5m   = EMPTY2i OR M5i
VIA5m = EMPTY2i OR VIA5i
M6m   = EMPTY2i OR M6i
VIADm = EMPTY2i OR VIADi
MDm = EMPTY2i OR MDi



CTM5m = EMPTY2i OR CTM5i
CMM5m = EMPTY2i OR CMM5i


CBm = EMPTY2i OR CBi
CBDm = EMPTY2i OR CBDi
PPIm = EMPTY2i OR PPIi
UBMnm = EMPTY2i OR UBMn
UBMdm = EMPTY2i OR UBMd

CONNECT M1m M2m BY VIA1m
CONNECT M2m M3m BY VIA2m
CONNECT M3m M4m BY VIA3m
CONNECT M4m M5m BY VIA4m

VIAtm	= (VIA5m NOT INTERACT CTM5m) NOT INTERACT CMM5m
VIAcm	= VIA5m AND CTM5m
CONNECT	M5m  M6m BY VIAtm 
CONNECT	M6m VIAcm
CONNECT	M6m  MDm BY VIADm


// Wire-Bond
CONNECT M6m CBm
// Flip-chip
// 1_Ground up
CONNECT M6m UBMnm BY CBDm
// 2_RDL (before passivation)
CONNECT MDm UBMdm
// 3_PPI (After passivation)
CONNECT M6m PPIm BY CBDm
CONNECT PPIm UBMdm


CTM.R.6 { @ Two Mn connect to CTM without same connection is not allowed
    CTM5m INTERACT VIAcm BY NET > 1
}



// MIM_M5 CHECK
//==============

MIM_M5.W.1 { @ Max. dimension (both width and length) of M5 as MIM capacitor bottom metal <= ^MIM_M5_W_1 um
    SIZE BPM5 BY MIM_M5_W_1/2 UNDEROVER
}
MIM_M5.S.1 { @ Min. space between two M5 regions as MIM capacitor bottom metal >= ^MIM_M5_S_1 um
  EXT BPM5C < MIM_M5_S_1 ABUT < 90 REGION
}
MIM_M5.S.2 { @ Min. space between one M5 region as a dummy MIM capacitor bottom metal and 
              @ the other M5 region as MIM capacitor bottom metal >= ^MIM_M5_S_2 um
  EXT BPM5C DPM5 < MIM_M5_S_2 ABUT < 90 REGION
}
MIM_M5.E.3  { @ Minimum extension of an M5 resgion as MIM capacitor bottom metal beyound 
              @ a CTM resgion and dummy CTM region >= ^MIM_M5_E_3 um 
  ENC CTM5 M5 < MIM_M5_E_3 ABUT < 90 SINGULAR REGION
  CTM5 NOT M5  
}



// MIMVIA CHECK
//===============


CTMV5 = VIA5 AND CTM5		// VIA5 locate on CTM

CBMV5 = ((VIA5 AND BPM5) NOT CTM5) NOT CMM5	// VIA5 locate on CBMV




CONNECT CTMV5 TCTM
CONNECT CBMV5 BPM5









MIMVIA.S.1 { @ Min. space between two VIA5 on the same CTM >= ^MIMVIA_S_1 um
  EXT CTMV5 < MIMVIA_S_1 ABUT < 90 SINGULAR REGION CONNECTED   
}
MIMVIA.S.2 { @ Min. space between two VIA5 on the same M5 as MIM capacitor bottom metal >= ^MIMVIA_S_2 um
  EXT CBMV5 < MIMVIA_S_2 ABUT < 90 SINGULAR REGION CONNECTED     
}
MIMVIA.E.1 { @ Min. extension of a CTM region beyond a VIA5 region >= ^MIMVIA_E_1 um
  ENC VIA5 CTM5 < MIMVIA_E_1 ABUT < 90 SINGULAR REGION
  VIA5 CUT CTM5    
}
MIMVIA.E.2 { @ Min. extension of an M5 region as MIM capacitor bottom metal beyond a VIA4 or a VIA5 region >= ^MIMVIA_E_2 um
  ENC VIA4 BPM5C < MIMVIA_E_2 ABUT < 90 REGION
  ENC VIA5 BPM5C < MIMVIA_E_2 ABUT < 90 REGION
}
MIMVIA.C.1 { @ Min. clearance of a VIA4 or a VIA5 to a CTM region >= ^MIMVIA_C_1 um
  EXT VIA4 CTM5 < MIMVIA_C_1 ABUT < 90 SINGULAR REGION
  EXT VIA5 CTM5 < MIMVIA_C_1 ABUT < 90 SINGULAR REGION
}


MIMVIA.R.1 { @ Min. density of VIA5 on CTM >= 1%
  NET AREA RATIO CTMV5 TCTM < 0.01 RDB VIA5_DENSITY.log CTMV5 TCTM
}
MIMVIA.R.3 { @ VIA4 under CTM region is not allowed
  VIA4 AND CTM5
}



//================SBD rules Check================================



PPOD_SBD_H = (HOLES (((PPOD AND PWEL) AND RFDUMMY) NOT DNW) INNER) ENCLOSE SBDOD

SBD.W.1_SBD.W.1.1 { @ Minimum width of an OD region to define the width of the
          @ P+ active OD region of the SBD. >=1.0um <= 16.0um
    LENGTH PPOD_SBD_W > 0 < 1
    PATH LENGTH PPOD_SBD_W > 16 < 999
}
SBD.W.2_SBD.W.2.1 { @ Minimum length of an OD region to define the length of the
          @ P+ active OD region of the SBD. >=1.0um <=4.0um
    LENGTH PPOD_SBD_L > 0 < 1
    PATH LENGTH PPOD_SBD_L > 4 < 999 
}
SBD.W.3 { @ Minimum and Maximum length of an OD region to define
          @ the length of the NP OD region of the SBD.==0.42um
    NOT RECTANGLE NPOD_SBD	      
    INT NPOD_SBD < 0.42 ABUT <90 SINGULAR REGION
    SIZE NPOD_SBD BY 0.42/2 UNDEROVER
}
SBD.W.4 { @ The width of NP OD region of the SBD must be equal to P+
          @ active OD region of the SBD.
    NPOD_SBD_W NOT COIN OUTSIDE EDGE PPOD_SBD_G	      
    PPOD_SBD_W NOT COIN OUTSIDE EDGE NPOD_SBD_G        
}
SBD.S.1 { @ Space between P+ active OD region and NP OD region of the SBD ==0.48um
    EXT PPOD_SBD NPOD_SBD < 0.48 ABUT < 90 SINGULAR REGION
    PPOD_SBD INTERACT NPOD
   
    PPOD_SBD NOT TOUCH PPOD_SBD_G == 2
    
    A = PPOD_SBD TOUCH PPOD_SBD_G == 2
    B = A TOUCH OUTSIDE EDGE PPOD_SBD_G 
    C = INT B < 0.48 ABUT == 90 INTERSECTING ONLY REGION 
    PPOD_SBD INTERACT C 
}
SBD.E.1 { @ Minimum and maximum extension from NW edge to an OD
          @ region used for the SBD. ==0.80um
    X = PPOD_SBD OR NPOD_SBD
    Y = SIZE X BY 0.8
    Y XOR NW_SBD
}
SBD.E.2 { @ Minimum and maximum extension of a PP region beyond
          @ an enclosed P+ active OD region of the SBD.==0.22um
    X = SIZE PPOD_SBD BY 0.22
    X XOR PP_SBD_ALL
}
SBD.O.1 { @ Minimum and maximum overlap from a PP edge to a P+
          @ active OD region of the SBD.==0.22um
    X = SIZE PPOD_SBD BY -0.22
    X XOR PP_SBD_HOLE
}
SBD.E.1.1 { @ Minimum extension of DNW beyond NW for a better noise isolation.>=0.60um
    ENC NW_SBD DNW_SBD < 0.6 ABUT <90 SINGULAR REGION
    NW_SBD CUT DNW_SBD
}

SBD.E.3 { @ Maximum and Minimum extension of SBDDMY beyond NW==0.00um
    SBDDMY XOR NW_SBD
}

//SBD.R.1 is checked by SBD.S.1 

SBD.R.2 { @ Maximum Finger Number of the P+ active OD region of the SBD should be <=16um
    X = SBDDMY INTERACT PPOD_SBD < 17
    Y = SBDDMY NOT X 
    PPOD_SBD INTERACT Y
}
SBD.R.3 { @ The each NW of SBD should be surrounded by the P+ Guard Ring (P+ pickup ring).
    NW_SBD NOT PPOD_SBD_H 
    PPOD_SBD_H INTERACT SBDOD_ALL >1

    PPOD_SBD_H INTERACT NW_SBD > 1
}

SBD.R.4 { @ Use RFDUMMY to fully cover SBD and P+ Guard Ring for LVS to recognize RF Device.
          @// for P+ guard Ring part is checked by SBD.R.3
    SBDDMY NOT RFDUMMY
    NW_SBD NOT RFDUMMY
}
SBD.R.5 { @ PP for SBD must be a rectangle ring. PP rectangle ring must surround OD. Other shape is not allowed.
    NOT RECTANGLE PP_SBD_HOLE	
    NOT RECTANGLE PP_SBD_ALL
}
//SBD.R.7R don't need check. 


#ENDIF



//DUMMY OD RULE
//================
//DOD VARIABLE
VARIABLE  DOD_W_1   2.0
VARIABLE  DOD_S_1   1.2
VARIABLE  DOD_C_1   1.2
VARIABLE  DOD_C_2   1.2
VARIABLE  DOD_C_4   0.6
VARIABLE  DOD_C_5   1.2
VARIABLE  DOD_C_6   1.2
VARIABLE  DOD_C_7   1.2
VARIABLE  DOD_C_8   3.0
VARIABLE  DOD_C_9   1.2



VARIABLE  DOD_C_13  1.2

VARIABLE  DOD_C_14  10.0
VARIABLE  DOD_C_15  10.0
VARIABLE  DOD_E_1   0.6
VARIABLE  DOD_E_2   5.0
VARIABLE  OD_R_1    0.2
VARIABLE  OD_R_2    0.8
VARIABLE  OD_R_W    500.0
VARIABLE  OD_R_S    250.0
VARIABLE  OD_R_A    62500.0
VARIABLE  OD_R_3    0.25
VARIABLE  OD_R_4    0.75
VARIABLE  OD_S_3    0.43
VARIABLE  OD_S_4    0.43

#IFDEF FULL_CHIP
OD_DEN_EXC = ((((RWDMY OR FWi) OR LMARK) OR LOGO) OR INDDMY) OR EMPTY_AREA // exclude check
#ELSE
OD_DEN_EXC = (((RWDMY OR FWi) OR LMARK) OR LOGO) OR INDDMY // exclude check
#ENDIF

#IFDEF DENSITY_IN_BLOCKAGE
OD_EXC = COPY OD_DEN_EXC
#ELSE
OD_EXC = OD_DEN_EXC OR ODBLK
#ENDIF




DOD.W.1 { @Minimum width >= ^DOD_W_1 um
   INT DOD < DOD_W_1 ABUT < 90 SINGULAR REGION
}

DOD.S.1 { @Minimum space between two DOD >= ^DOD_S_1 um
   EXT DOD < DOD_S_1 ABUT < 90 SINGULAR REGION
}

DOD.C.1 { @Minimum clearance from DOD to OD (overlap is not allowed) >= ^DOD_C_1 um
   EXT DOD ODi < DOD_C_1 ABUT < 90 SINGULAR REGION
   DOD AND ODi
}

DOD.C.2 { @Minimum clearance from DOD to PO (overlap is not allowed) >= ^DOD_C_2 um
   EXT DOD POLYi < DOD_C_2 ABUT < 90 SINGULAR REGION
   DOD AND POLYi
}


DOD.C.4 { @Minimum clearance from DOD to NW (cut is not allowed) >= ^DOD_C_4 um
   EXT DOD NWELi < DOD_C_4 ABUT < 90 SINGULAR REGION
   DOD CUT NWELi
}

DOD.C.5 { @Minimum clearance from DOD to FW (overlap is not allowed) >= ^DOD_C_5 um
   EXT DOD FWi < DOD_C_5 ABUT < 90 SINGULAR REGION
   DOD AND FWi
}
DOD.C.6 { @Minimum clearance from DOD to LMARK (overlap is not allowed) >= ^DOD_C_6 um
   EXT DOD LMARK < DOD_C_6 ABUT < 90 SINGULAR REGION
   DOD AND LMARK
}
DOD.C.7 { @Minimum clearance from DOD to RWDMY (overlap is not allowed) >= ^DOD_C_7 um
   EXT DOD RWDMY < DOD_C_7 ABUT < 90 SINGULAR REGION
   DOD AND RWDMY
}

DOD.C.8 { @Minimum clearance from DOD to LOGO (overlap is not allowed) >= ^DOD_C_8 um
   EXT DOD LOGO < DOD_C_8 ABUT < 90 SINGULAR REGION
   DOD AND LOGO
}
DOD.C.9 { @Minimum clearance from DOD to INDDMY (overlap is not allowed) >= ^DOD_C_9 um
   EXT DOD INDDMY < DOD_C_9 ABUT < 90 SINGULAR REGION
   DOD AND INDDMY
}


DOD.C.13 { @Minimum clearance from DOD to DTi (overlap is not allowed) >= ^DOD_C_13 um
   EXT DOD DTi < DOD_C_13 ABUT < 90 SINGULAR REGION
   DOD AND DTi
}
DOD.C.14 { @Minimum clearance from DOD to BJTDUMMY (overlap is not allowed) >= ^DOD_C_14 um
   EXT DOD BJTDUMMY < DOD_C_14 ABUT < 90 SINGULAR REGION
   DOD AND BJTDUMMY
}
DOD.C.15 { @Minimum clearance from DOD to FLASH (overlap is not allowed) >= ^DOD_C_15 um
   EXT DOD FLASH < DOD_C_15 ABUT < 90 SINGULAR REGION
   DOD AND FLASH
}





DOD.E.1 { @Minimum extension of NW beyond DOD >= ^DOD_E_1
   ENC DOD NWELi < DOD_E_1 ABUT < 90 SINGULAR REGION
}

#IFDEF FULL_CHIP
DOD.E.2 { @Minimum extension of chip edge beyond DOD >= ^DOD_E_2
   DOD NOT (SIZE CHIP_CHAMFERED BY -DOD_E_2)
}
#ENDIF

#IFDEF FULL_CHIP
ODx = ALL_OD NOT EMPTY_AREA
CHIP_NOT_OD_EXC = COPY CHIP_CHAMFERED
#ELSE
ODx = COPY ALL_OD
CHIP_NOT_OD_EXC = COPY CHIP
#ENDIF

CHIPU_od25   = SIZE CHIP BY 25
CHIPU_od50   = SIZE CHIP BY 50
CHIPU_od75   = SIZE CHIP BY 75
CHIPU_od100   = SIZE CHIP BY 100
CHIPU_od125   = SIZE CHIP BY 125
CHIPU_od150   = SIZE CHIP BY 150
CHIPU_od175   = SIZE CHIP BY 175
CHIPU_od200   = SIZE CHIP BY 200
CHIPU_od225   = SIZE CHIP BY 225
OD.R.1 { @ {OD or DOD} local density (minimum) over window ^OD_R_W um x ^OD_R_W um stepping OD_R_Sum >= ^OD_R_1
  D0 = DENSITY ODx CHIP_NOT_OD_EXC < OD_R_1 WINDOW OD_R_W STEP OD_R_S BACKUP  
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D = RECTANGLE D0 == OD_R_W
  ERR1 = ( D0 NOT D ) NOT OD_EXC
  F1 = AREA ERR1 >= OD_R_A
  D1 = DENSITY ODx CHIP_NOT_OD_EXC < OD_R_1 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od25
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D2 = DENSITY ODx CHIP_NOT_OD_EXC < OD_R_1 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od50
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D3 = DENSITY ODx CHIP_NOT_OD_EXC < OD_R_1 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od75
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D4 = DENSITY ODx CHIP_NOT_OD_EXC < OD_R_1 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od100
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D5 = DENSITY ODx CHIP_NOT_OD_EXC < OD_R_1 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od125
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D6 = DENSITY ODx CHIP_NOT_OD_EXC < OD_R_1 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od150
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]

  D7 = DENSITY ODx CHIP_NOT_OD_EXC < OD_R_1 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od175
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D8 = DENSITY ODx CHIP_NOT_OD_EXC < OD_R_1 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od200
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D9 = DENSITY ODx CHIP_NOT_OD_EXC < OD_R_1 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od225
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)  
  F2 = AREA ( ERR2 NOT OD_EXC ) >= OD_R_A
  F = F1 OR F2
  DENSITY F ODx CHIP_NOT_OD_EXC < OD_R_1 WINDOW OD_R_W STEP OD_R_S BACKUP PRINT OD_R_1.density 
          [ !AREA(F) + (AREA(ODx)/AREA(CHIP_NOT_OD_EXC)) ]       
}

OD.R.2 { @ {OD or DOD} local density (maximum) over window ^OD_R_W um x ^OD_R_W um stepping OD_R_Sum <= ^OD_R_2 
  D0 = DENSITY ODx CHIP_NOT_OD_EXC > OD_R_2 WINDOW OD_R_W STEP OD_R_S BACKUP  
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D = RECTANGLE D0 == OD_R_W
  ERR1 = ( D0 NOT D ) NOT OD_EXC
  F1 = AREA ERR1 >= OD_R_A
  D1 = DENSITY ODx CHIP_NOT_OD_EXC > OD_R_2 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od25
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D2 = DENSITY ODx CHIP_NOT_OD_EXC > OD_R_2 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od50
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D3 = DENSITY ODx CHIP_NOT_OD_EXC > OD_R_2 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od75
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D4 = DENSITY ODx CHIP_NOT_OD_EXC > OD_R_2 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od100
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D5 = DENSITY ODx CHIP_NOT_OD_EXC > OD_R_2 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od125
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D6 = DENSITY ODx CHIP_NOT_OD_EXC > OD_R_2 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od150
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D7 = DENSITY ODx CHIP_NOT_OD_EXC > OD_R_2 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od175
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D8 = DENSITY ODx CHIP_NOT_OD_EXC > OD_R_2 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od200
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D9 = DENSITY ODx CHIP_NOT_OD_EXC > OD_R_2 WINDOW OD_R_W STEP OD_R_S BACKUP INSIDE OF LAYER CHIPU_od225
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  ERR2 = D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
  F2 = AREA ( ERR2 NOT OD_EXC ) >= OD_R_A
  F = F1 OR F2
  DENSITY F ODx CHIP_NOT_OD_EXC > OD_R_2 WINDOW OD_R_W STEP OD_R_S BACKUP PRINT OD_R_2.density 
          [ !!AREA(F) * ((AREA(ODx)/AREA(CHIP_NOT_OD_EXC))) ]
}

#IFDEF Recommend
DOD.DN.1 { @ {OD OR DOD} local density (minimum) over window  ^DOD_DN_1_W um x ^DOD_DN_1_W stepping DOD_DN_1_S um >= ^DOD_DN_1
   DENSITY ODx CHIP_NOT_OD_EXC < DOD_DN_1 WINDOW DOD_DN_1_W STEP DOD_DN_1_S BACKUP PRINT DOD_DN_1.density 
    [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
}

DOD.DN.2 { @ {OD OR DOD} local density (minimum) over window  ^DOD_DN_2_W um x ^DOD_DN_2_W stepping DOD_DN_2_S um >= ^DOD_DN_2
   DENSITY ODx CHIP_NOT_OD_EXC > DOD_DN_2 WINDOW DOD_DN_2_W STEP DOD_DN_2_S BACKUP PRINT DOD_DN_2.density 
    [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
}

#ENDIF
#IFDEF FULL_CHIP
OD.R.3 { @Minimum {OD or DOD} density across full chip >= ^OD_R_3
  DENSITY ODx < OD_R_3 INSIDE OF LAYER CHIP PRINT OD_R_3.density
}
OD.R.4 { @Maximum {OD or DOD} density across full chip <= ^OD_R_4
  DENSITY ODx > OD_R_4 INSIDE OF LAYER CHIP PRINT OD_R_4.density
}  
#ENDIF

#IFDEF FULL_CHIP

DOD.R.1 { @DOD is required. 
          @The DOD CAD layer (TSMC default, 3:1) must be a different layer from the OD CAD layer.
  CHIP_CHAMFERED NOT INTERACT DOD
}


DOD.R.2 { @DOD inside chip corner stress relief area is not allowed.
  DOD INTERACT EMPTY_AREA
}
#ENDIF

DOD.R.3 { @The only shapes allowed are square(or rectangular) and solid
  HOLES DOD
  NOT RECTANGLE DOD ORTHOGONAL ONLY
}



//DUMMY PO RULE
//================
//DPO VARIABLE
VARIABLE  DPO_W_1   0.6
VARIABLE  DPO_S_1   0.3
VARIABLE  DPO_C_1   1.2
VARIABLE  DPO_C_2   1.2
VARIABLE  DPO_C_4   1.2
VARIABLE  DPO_C_5   1.2
VARIABLE  DPO_C_6   3.0
VARIABLE  DPO_C_7   1.2

VARIABLE  DPO_C_9   0.3

VARIABLE  DPO_C_12  10.0
VARIABLE  DPO_C_13  1.2
VARIABLE  DPO_C_14  10.0
VARIABLE  DPO_E_1   5.0
VARIABLE  DPO_A_1   1.2
VARIABLE  PO_R_5    0.14





DPO.W.1 { @Minimum width >= ^DPO_W_1 um
   INT DPO < DPO_W_1 ABUT < 90 SINGULAR REGION
}

DPO.S.1 { @Minimum space between two DPO >= ^DPO_S_1 um
   EXT DPO < DPO_S_1 ABUT < 90 SINGULAR REGION
}

DPO.C.1 { @Minimum clearance from DPO to OD (overlap is not allowed) >= ^DPO_C_1 um
   EXT DPO ODi < DPO_C_1 ABUT < 90 SINGULAR REGION
   DPO AND ODi
}

DPO.C.2 { @Minimum clearance from DPO to PO (overlap is not allowed) >= ^DPO_C_2 um
   EXT DPO POLYi < DPO_C_2 ABUT < 90 SINGULAR REGION
   DPO AND POLYi
}



DPO.C.4 { @Minimum clearance from DPO to FW (overlap is not allowed) >= ^DPO_C_4 um
   EXT DPO FWi < DPO_C_4 ABUT < 90 SINGULAR REGION
   DPO AND FWi
}
DPO.C.5 { @Minimum clearance from DPO to LMARK (overlap is not allowed) >= ^DPO_C_5 um
   EXT DPO LMARK < DPO_C_5 ABUT < 90 SINGULAR REGION
   DPO AND LMARK
}
DPO.C.6 { @Minimum clearance from DPO to LOGO (overlap is not allowed) >= ^DPO_C_6 um
   EXT DPO LOGO < DPO_C_6 ABUT < 90 SINGULAR REGION
   DPO AND LOGO
}
DPO.C.7 { @Minimum clearance from DPO to INDDMY (overlap is not allowed) >= ^DPO_C_7 um
   EXT DPO INDDMY < DPO_C_7 ABUT < 90 SINGULAR REGION
   DPO AND INDDMY
}


DPO.C.9 { @Minimum clearance from DPO to DOD (overlap is not allowed) >= ^DPO_C_9 um
   EXT DPO DOD < DPO_C_9 ABUT < 90 SINGULAR REGION
   DPO AND DOD
}

DPO.C.12 { @Minimum clearance from DPO to BJTDMY (overlap is not allowed) >= ^DPO_C_12 um
   EXT DPO BJTDUMMY < DPO_C_12 ABUT < 90 SINGULAR REGION
   DPO AND BJTDUMMY
}

DPO.C.13 { @Minimum clearance from DPO to DTi (overlap is not allowed) >= ^DPO_C_13 um
   EXT DPO DTi < DPO_C_13 ABUT < 90 SINGULAR REGION
   DPO AND DTi
}
DPO.C.14 { @Minimum clearance from DPO to FLASH (overlap is not allowed) >= ^DPO_C_14 um
   EXT DPO FLASH < DPO_C_14 ABUT < 90 SINGULAR REGION
   DPO AND FLASH
}



#IFDEF FULL_CHIP
DPO.E.1 { @Minimum extension of chip edge beyond DPO >= ^DPO_E_1
   DPO NOT (SIZE CHIP_CHAMFERED BY -DPO_E_1)   
}
#ENDIF

DPO.A.1 { @Minimum area of DPO >= ^DPO_A_1
   AREA DPO < DPO_A_1
}

#IFDEF FULL_CHIP
PO.R.5 { @Minimum {PO OR DPO} density across full chip >= ^PO_R_5
  DENSITY ALL_PO < PO_R_5 INSIDE OF LAYER CHIP PRINT PO_DN_5.density
}

#IFDEF Recommend

DPO.R.1 { @DPO is required. 
          @The DPO CAD layer (TSMC default, 13:1) must be a different layer from the PO CAD layer.
  CHIP_CHAMFERED NOT INTERACT DPO
}
#ENDIF


DPO.R.2 { @DPO inside chip corner stress relief area is not allowed.
  DPO INTERACT EMPTY_AREA
}
#ENDIF

DPO.R.3 { @The only shapes allowed are square (or rectangular) and solid
  HOLES DPO
  NOT RECTANGLE DPO ORTHOGONAL ONLY
}








// Matching check
//================

POLY_PAIR_CHECK = (POLY INTERACT OD) INTERACT MATCHING
POLY_PAIR_CHECK_G_M1 = POLY_PAIR_CHECK INSIDE M1xd
POLY_PAIR_CHECK_B_M1 = POLY_PAIR_CHECK CUT M1xd
POLY_PAIR_CHECK_O_M1 = POLY_PAIR_CHECK OUTSIDE M1xd
POLY_PAIR_CHECK_G_M2 = POLY_PAIR_CHECK INSIDE M2xd
POLY_PAIR_CHECK_B_M2 = POLY_PAIR_CHECK CUT M2xd
POLY_PAIR_CHECK_O_M2 = POLY_PAIR_CHECK OUTSIDE M2xd
POLY_PAIR_CHECK_G_M3 = POLY_PAIR_CHECK INSIDE M3xd
POLY_PAIR_CHECK_B_M3 = POLY_PAIR_CHECK CUT M3xd
POLY_PAIR_CHECK_O_M3 = POLY_PAIR_CHECK OUTSIDE M3xd
POLY_PAIR_CHECK_G_M4 = POLY_PAIR_CHECK INSIDE M4xd
POLY_PAIR_CHECK_B_M4 = POLY_PAIR_CHECK CUT M4xd
POLY_PAIR_CHECK_O_M4 = POLY_PAIR_CHECK OUTSIDE M4xd
POLY_PAIR_CHECK_G_M5 = POLY_PAIR_CHECK INSIDE M5xd
POLY_PAIR_CHECK_B_M5 = POLY_PAIR_CHECK CUT M5xd
POLY_PAIR_CHECK_O_M5 = POLY_PAIR_CHECK OUTSIDE M5xd
POLY_PAIR_CHECK_G_M6 = POLY_PAIR_CHECK INSIDE M6xd
POLY_PAIR_CHECK_B_M6 = POLY_PAIR_CHECK CUT M6xd
POLY_PAIR_CHECK_O_M6 = POLY_PAIR_CHECK OUTSIDE M6xd
POLY_PAIR_CHECK_G_MD = POLY_PAIR_CHECK INSIDE MDxd
POLY_PAIR_CHECK_B_MD = POLY_PAIR_CHECK CUT MDxd
POLY_PAIR_CHECK_O_MD = POLY_PAIR_CHECK OUTSIDE MDxd

AN.R.40m_M1 { @ For the critical differential pair inside MATCHING layer, asymmetry metal (M1) shielding is not allowed.
		     @ DRC only flag: (1) One of differential pair covered by metal layer but without fully covered.
		  	 @ (2) One device of the differential pair fully covered by metal layer and the other is not fully covered.	  
  MATCHING INTERACT POLY_PAIR_CHECK_B_M1
  (MATCHING INTERACT POLY_PAIR_CHECK_G_M1) INTERACT POLY_PAIR_CHECK_O_M1
}

#IFDEF Recommend
AN.R.41m_M2 { @ For the critical differential pair inside MATCHING layer, asymmetry metal (M2) shielding is not recommended.
		     @ DRC only flag: (1) One of differential pair covered by metal layer but without fully covered.
			 @ (2) One device of the differential pair fully covered by metal layer and the other is not fully covered.	
  MATCHING INTERACT POLY_PAIR_CHECK_B_M2
  (MATCHING INTERACT POLY_PAIR_CHECK_G_M2) INTERACT POLY_PAIR_CHECK_O_M2
}
AN.R.41m_M3 { @ For the critical differential pair inside MATCHING layer, asymmetry metal (M3) shielding is not recommended.
		     @ DRC only flag: (1) One of differential pair covered by metal layer but without fully covered.
			 @ (2) One device of the differential pair fully covered by metal layer and the other is not fully covered.	
  MATCHING INTERACT POLY_PAIR_CHECK_B_M3
  (MATCHING INTERACT POLY_PAIR_CHECK_G_M3) INTERACT POLY_PAIR_CHECK_O_M3
}
AN.R.41m_M4 { @ For the critical differential pair inside MATCHING layer, asymmetry metal (M4) shielding is not recommended.
		     @ DRC only flag: (1) One of differential pair covered by metal layer but without fully covered.
			 @ (2) One device of the differential pair fully covered by metal layer and the other is not fully covered.	
  MATCHING INTERACT POLY_PAIR_CHECK_B_M4
  (MATCHING INTERACT POLY_PAIR_CHECK_G_M4) INTERACT POLY_PAIR_CHECK_O_M4
}
AN.R.41m_M5 { @ For the critical differential pair inside MATCHING layer, asymmetry metal (M5) shielding is not recommended.
		     @ DRC only flag: (1) One of differential pair covered by metal layer but without fully covered.
			 @ (2) One device of the differential pair fully covered by metal layer and the other is not fully covered.	
  MATCHING INTERACT POLY_PAIR_CHECK_B_M5
  (MATCHING INTERACT POLY_PAIR_CHECK_G_M5) INTERACT POLY_PAIR_CHECK_O_M5
}
AN.R.41m_M6 { @ For the critical differential pair inside MATCHING layer, asymmetry metal (M6) shielding is not recommended.
		     @ DRC only flag: (1) One of differential pair covered by metal layer but without fully covered.
			 @ (2) One device of the differential pair fully covered by metal layer and the other is not fully covered.	
  MATCHING INTERACT POLY_PAIR_CHECK_B_M6
  (MATCHING INTERACT POLY_PAIR_CHECK_G_M6) INTERACT POLY_PAIR_CHECK_O_M6
}
#IFDEF CHECK_ALRDL
AN.R.41m_MD { @ For the critical differential pair inside MATCHING layer, asymmetry metal (MD) shielding is not recommended.
			 @ DRC only flag: (1) One of differential pair covered by metal layer but without fully covered.
			 @ (2) One device of the differential pair fully covered by metal layer and the other is not fully covered.	
  MATCHING INTERACT POLY_PAIR_CHECK_B_MD
  (MATCHING INTERACT POLY_PAIR_CHECK_G_MD) INTERACT POLY_PAIR_CHECK_O_MD
}
#ENDIF

#ENDIF



FPAD.R.1 { @ Floating PAD is not allowed . please add protection diode to ground .
           @ Floating PAD in the DRC : {Mn INTERACT CB} don't connect OD or POLY
   A = M6 INTERACT CB
  A1 = STAMP A BY M6xd
  B1 = NET AREA RATIO A1 NTAPi > 0
  B2 = NET AREA RATIO A1 PTAPi > 0
  B3 = NET AREA RATIO A1 NSDi > 0
  B4 = NET AREA RATIO A1 PSDi > 0
  B5 = NET AREA RATIO A1 ILP1i > 0
  A NOT ((((B1 OR B2) OR B3) OR B4) OR B5)

}





//3D MIM CHECK
//============
CMM2	= CMM2i	NOT EXCL_S
CMM3	= CMM3i	NOT EXCL_S
CMM4	= CMM4i	NOT EXCL_S
CMM5	= CMM5i	NOT EXCL_S

#IFDEF MIX_MODE
#IFNDEF C016
#IFNDEF C0152
CTMVIA = CTM5 AND VIA5 
CMMVIA = (CMM5 AND VIA5) NOT CTMVIA
TCMM  = CMM5 INTERACT CMMVIA	// True CMM
BPM5_3D  = SIZE CMM5 BY 2 INSIDE OF M5 STEP 0.28*0.7 TRUNCATE 0.28*0.7	// CBM_3D = TCMM SIZE 2
CBMVIA =((BPM5_3D AND VIA5) NOT CTMVIA ) NOT CMMVIA
DCMM  = CMM5 NOT INTERACT CMMVIA   	// Dummy CMM
DPM5_3D  = (M5 INTERACT DCMM) NOT INTERACT VIA5	// M5 as a dummy CBM
BPM5C_3D =  BPM5_3D COIN EDGE M5
CBMV5_3D =(( VIA5 AND BPM5_3D) NOT CTM5) NOT CMM5
CONNECT CBMV5_3D BPM5_3D


3DMIM.A.2 { @ Min. area of CMM or dummy CMM >= ^3DMIM_A_2
  AREA CMM5 < 3DMIM_A_2
}

3DMIM.DN.1 { @ Min. density of all CMM or dummy CMM area >= 3%
  DENSITY CMM5i > 0 < 0.03 PRINT CMM5i.density
}

3DMIM.EX.1 { @ Minimum and maximum extension of CMM or dummy CMM beyond CTM or dummy CTM == ^3DMIM_EX_1
  A = CMM5 INTERACT CTM5
  B = EXPAND EDGE A INSIDE BY  3DMIM_EX_1 EXTEND BY -0.4
  (B NOT INTERACT  VIA5 )   NOT TOUCH CTM5
}


3DMIM.EX.2 { @ Minimum and maximum extension of CMM beyond CMMVIA (at least one side) (except 2DMIM) == ^3DMIM_EX_2
	PRE = CMM5 INTERACT CTM5
	D = CMMVIA INTERACT PRE
	ENC  D TCMM < 3DMIM_EX_2
    A = SIZE D BY 3DMIM_EX_2
	B = A TOUCH EDGE TCMM
	D NOT INTERACT (A WITH EDGE B)
}


3DMIM.EX.3 { @ Min. extension of Mx region beyond CMM or dummy CMM >= ^3DMIM_EX_3
  ENC CMM5 BPM5_3D  < 3DMIM_EX_3	ABUT < 90 SINGULAR REGION
 
}

3DMIM.EX.4 { @ Min. extension of CMM beyond CMMVIA (for 2DMIM)>= ^3DMIM_EX_4
    PRE = CMM5 NOT INTERACT CTM5
	A = CMMVIA INTERACT PRE
    ENC A TCMM < 3DMIM_EX_4	ABUT < 90 SINGULAR REGION
 }

3DMIM.S.1 { @ Minimum and maximum space of CMMVIA TO CTM == ^3DMIM_S_1
  EXT TCTM CMMVIA < 3DMIM_S_1
  A = CMMVIA INTERACT (TCMM INTERACT TCTM)
  B = EXPAND EDGE TCTM OUTSIDE BY 3DMIM_S_1
  A NOT TOUCH B
}

3DMIM.S.2 { @ Min. CTMVIA space >= ^3DMIM_S_2
	EXT CTMVIA < 3DMIM_S_2  ABUT < 90 SINGULAR REGION
}

3DMIM.S.3 { @ Min. CMMVIA space >= ^3DMIM_S_3
	EXT CMMVIA < 3DMIM_S_3  ABUT < 90 SINGULAR REGION
}



3DMIM.S.4 { @ Min. CMM space >= ^3DMIM_S_4
	EXT TCMM < 3DMIM_S_4  ABUT < 90 SINGULAR REGION
}


3DMIM.S.5  { @ Min. space of CMM TO dummy CMM >= ^3DMIM_S_5
     EXT TCMM  DCMM   < 3DMIM_S_5  ABUT < 90 SINGULAR REGION
}





3DMIM.S.7 { @ Min. space of CBMVIA TO CMM >= ^3DMIM_S_7
     EXT CBMVIA TCMM  < 3DMIM_S_7  ABUT < 90 SINGULAR REGION
}


3DMIM.W.1 { @ Min. width of CTM (At least one side so that would be 2 VIAs for process yield concern)>= ^3DMIM_W_1
   NOT ENCLOSE RECTANGLE  TCTM GRID 3DMIM_W_1
}




3DMIM.W.3 {  @ Min. width of dummy CMM >= ^3DMIM_W_3
	INT DCMM  < 3DMIM_W_3 ABUT < 90 SINGULAR REGION	
}


3DMIM.W.4 { @ Min. width of dummy CBM >= ^3DMIM_W_4
	INT DPM5_3D < 3DMIM_W_4 ABUT < 90 SINGULAR REGION		
}

3DMIM.W.5 { @ Max. dimension (one side) of a CMM region <= ^3DMIM_W_5
  ENCLOSE RECTANGLE TCMM GRID 3DMIM_W_5+GRID ORTHOGONAL ONLY 
  ENCLOSE RECTANGLE DCMM GRID 3DMIM_W_5+GRID ORTHOGONAL ONLY 
}

3DMIM.W.6 { @ Min. width of CMM >= ^3DMIM_W_6
   INT TCMM < 3DMIM_W_6 ABUT < 90 SINGULAR REGION	
}

3DMIM.R.10  { @ CTM and CBM termianls must be connected through Mtop
    BPM5_CHECK = M5xd INTERACT (BPM5_3D INTERACT CMM5)
    VIA5_CHECK = VIA5i NOT CMMVIA
    BPM5_CHECK INTERACT VIA5_CHECK BY NET > 1
}


3DMIM.S.8 { @ Min. space between two Mx regions as MIM capacitor bottom metal >= ^3DMIM_S_8
  EXT BPM5C_3D < 3DMIM_S_8 ABUT < 90 REGION
}
3DMIM.S.9 { @ Min. space between one Mx region as a dummy MIM capacitor bottom metal and 
              @ the other Mx region as MIM capacitor bottom metal >= ^3DMIM_S_9
  EXT BPM5C_3D DPM5_3D < 3DMIM_S_9 ABUT < 90 REGION
}

3DMIM.EX.5 { @ Min. extension of an Mx region as MIM capacitor bottom metal beyond a VIA4 or a VIA5 region >= ^3DMIM_EX_5
  ENC VIA4 BPM5C_3D < 3DMIM_EX_5 ABUT < 90 REGION
  ENC VIA5 BPM5C_3D < 3DMIM_EX_5 ABUT < 90 REGION
}

3DMIM.S.10 {@ Min. space between two VIA5 on the same Mx as MIM capacitor bottom metal >= ^3DMIM_S_10
   	EXT CBMV5_3D  < 3DMIM_S_10  ABUT < 90 SINGULAR REGION CONNECTED
}







// 3DMIM.R.1 is checked by 3DMIM.S.1
// 3DMIM.R.2 is not necessary  to check 

#ENDIF
#ENDIF
#ENDIF

// ANALOGDMY CHECKS
//=============
#IFNDEF C016
#IFNDEF C0152

ANALOGDMY.A.1 { @ Min. area of ANALOGDMY >= ^ANALOGDMY_A_1 
	AREA ANALOGDMY < ANALOGDMY_A_1
}

ANALOGDMY.EX.1 { @ Min. extension of ANALOGDMY beyond OD >= ^ANALOGDMY_EX_1
    ENC OD ANALOGDMY  < ANALOGDMY_EX_1 ABUT < 90 SINGULAR REGION
}

ANALOGDMY.EX.2 { @ Min. extension of ANALOGDMY beyond GATE POLY >= ^ANALOGDMY_EX_2
    PRE = POLY INSIDE EDGE OD 
    ENC PRE ANALOGDMY < ANALOGDMY_EX_2
}

ANALOGDMY.R.1 { @ GATE POLY cut ANALOGDMY is not allowed 
	    ALL_GATE CUT ANALOGDMY
	}

ANALOGDMY.S.1{ @ Min. ANALOGDMY space >= ^ANALOGDMY_S_1
   EXT ANALOGDMY < ANALOGDMY_S_1  ABUT < 90 SINGULAR REGION
}

ANALOGDMY.S.2{ @ Min. space of ANALOGDMY TO active OD >= ^ANALOGDMY_S_2
  EXT ANALOGDMY DACT < ANALOGDMY_S_2 ABUT < 90 SINGULAR REGION
}

ANALOGDMY.S.3{ @ Min. space of ANALOGDMY TO GATE POLY in the same OD >= ^ANALOGDMY_S_3
   A = OD INTERACT ANALOGDMY
   B = ALL_GATE INTERACT A
   EXT ANALOGDMY B < ANALOGDMY_S_3  ABUT < 90 SINGULAR REGION
}

ANALOGDMY.S.4{ @ Min. space of ANALOGDMY TO PO >= ^ANALOGDMY_S_4
   EXT ANALOGDMY POLY < ANALOGDMY_S_4  ABUT < 90 SINGULAR REGION
}

ANALOGDMY.W.1{ @ Min. ANALOGDMY width >= ^ANALOGDMY_W_1
    INT ANALOGDMY < ANALOGDMY_W_1  ABUT < 90 SINGULAR REGION
}



#ENDIF
#ENDIF


// MOM CHECKS
//===========
CHIP_MOM = COPY CHIPx
CONNECT CHIP_MOM

MOM_M1 = MOMDMY_1 AND M1
MOM_M1_EDGE = M1 COIN INSIDE EDGE MOM_M1
MOM_M1_LINE_END = CONVEX EDGE MOM_M1_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M1_SIDE_EDGE = MOM_M1_EDGE NOT COIN INSIDE EDGE MOM_M1_LINE_END
MOM_M1_CAP_EDGE = EXT [MOM_M1_SIDE_EDGE] < (M1_W_1+2*M1_S_1) OPPOSITE SPACE
MOM_M1_CAP_EDGE_EXP = EXPAND EDGE MOM_M1_CAP_EDGE INSIDE BY 0.001
MOM_M1_CAP_EDGE_EXP_C = STAMP MOM_M1_CAP_EDGE_EXP BY CHIP_MOM
MOM_M2 = MOMDMY_2 AND M2
MOM_M2_EDGE = M2 COIN INSIDE EDGE MOM_M2
MOM_M2_LINE_END = CONVEX EDGE MOM_M2_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M2_SIDE_EDGE = MOM_M2_EDGE NOT COIN INSIDE EDGE MOM_M2_LINE_END
MOM_M2_CAP_EDGE = EXT [MOM_M2_SIDE_EDGE] < (M2_W_1+2*M2_S_1) OPPOSITE SPACE
MOM_M2_CAP_EDGE_EXP = EXPAND EDGE MOM_M2_CAP_EDGE INSIDE BY 0.001
MOM_M2_CAP_EDGE_EXP_C = STAMP MOM_M2_CAP_EDGE_EXP BY CHIP_MOM
MOM_M3 = MOMDMY_3 AND M3
MOM_M3_EDGE = M3 COIN INSIDE EDGE MOM_M3
MOM_M3_LINE_END = CONVEX EDGE MOM_M3_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M3_SIDE_EDGE = MOM_M3_EDGE NOT COIN INSIDE EDGE MOM_M3_LINE_END
MOM_M3_CAP_EDGE = EXT [MOM_M3_SIDE_EDGE] < (M3_W_1+2*M3_S_1) OPPOSITE SPACE
MOM_M3_CAP_EDGE_EXP = EXPAND EDGE MOM_M3_CAP_EDGE INSIDE BY 0.001
MOM_M3_CAP_EDGE_EXP_C = STAMP MOM_M3_CAP_EDGE_EXP BY CHIP_MOM
MOM_M4 = MOMDMY_4 AND M4
MOM_M4_EDGE = M4 COIN INSIDE EDGE MOM_M4
MOM_M4_LINE_END = CONVEX EDGE MOM_M4_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M4_SIDE_EDGE = MOM_M4_EDGE NOT COIN INSIDE EDGE MOM_M4_LINE_END
MOM_M4_CAP_EDGE = EXT [MOM_M4_SIDE_EDGE] < (M4_W_1+2*M4_S_1) OPPOSITE SPACE
MOM_M4_CAP_EDGE_EXP = EXPAND EDGE MOM_M4_CAP_EDGE INSIDE BY 0.001
MOM_M4_CAP_EDGE_EXP_C = STAMP MOM_M4_CAP_EDGE_EXP BY CHIP_MOM
MOM_M5 = MOMDMY_5 AND M5
MOM_M5_EDGE = M5 COIN INSIDE EDGE MOM_M5
MOM_M5_LINE_END = CONVEX EDGE MOM_M5_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M5_SIDE_EDGE = MOM_M5_EDGE NOT COIN INSIDE EDGE MOM_M5_LINE_END
MOM_M5_CAP_EDGE = EXT [MOM_M5_SIDE_EDGE] < (M5_W_1+2*M5_S_1) OPPOSITE SPACE
MOM_M5_CAP_EDGE_EXP = EXPAND EDGE MOM_M5_CAP_EDGE INSIDE BY 0.001
MOM_M5_CAP_EDGE_EXP_C = STAMP MOM_M5_CAP_EDGE_EXP BY CHIP_MOM
MOM_M6 = MOMDMY_6 AND M6
MOM_M6_EDGE = M6 COIN INSIDE EDGE MOM_M6
MOM_M6_LINE_END = CONVEX EDGE MOM_M6_EDGE ANGLE1 == 90 ANGLE2 == 90
MOM_M6_SIDE_EDGE = MOM_M6_EDGE NOT COIN INSIDE EDGE MOM_M6_LINE_END
MOM_M6_CAP_EDGE = EXT [MOM_M6_SIDE_EDGE] < (M6_W_1+2*M6_S_1) OPPOSITE SPACE
MOM_M6_CAP_EDGE_EXP = EXPAND EDGE MOM_M6_CAP_EDGE INSIDE BY 0.001
MOM_M6_CAP_EDGE_EXP_C = STAMP MOM_M6_CAP_EDGE_EXP BY CHIP_MOM

MOM.S.2:M1 { @ Space of metal (M1/Mx) line end in MOMDMY_n >= ^MOM_S_2
  EXT MOM_M1_LINE_END M1 < MOM_S_2 ABUT < 90 REGION
}
// MOM.S.2 is checked by MOM.S.2:M1
MOM.S.2:M2 { @ Space of metal (M1/Mx) line end in MOMDMY_n >= ^MOM_S_2
  EXT MOM_M2_LINE_END M2 < MOM_S_2 ABUT < 90 REGION
}
// MOM.S.2 is checked by MOM.S.2:M2
MOM.S.2:M3 { @ Space of metal (M1/Mx) line end in MOMDMY_n >= ^MOM_S_2
  EXT MOM_M3_LINE_END M3 < MOM_S_2 ABUT < 90 REGION
}
// MOM.S.2 is checked by MOM.S.2:M3
MOM.S.2:M4 { @ Space of metal (M1/Mx) line end in MOMDMY_n >= ^MOM_S_2
  EXT MOM_M4_LINE_END M4 < MOM_S_2 ABUT < 90 REGION
}
// MOM.S.2 is checked by MOM.S.2:M4
MOM.S.2:M5 { @ Space of metal (M1/Mx) line end in MOMDMY_n >= ^MOM_S_2
  EXT MOM_M5_LINE_END M5 < MOM_S_2 ABUT < 90 REGION
}
// MOM.S.2 is checked by MOM.S.2:M5

MOM.A.1 { @ Maximum sidewall area of total metals in MOM without Via <= ^MOM_A_1
    NET AREA RATIO CHIP_MOM MOM_M1_CAP_EDGE_EXP_C MOM_M2_CAP_EDGE_EXP_C MOM_M3_CAP_EDGE_EXP_C MOM_M4_CAP_EDGE_EXP_C MOM_M5_CAP_EDGE_EXP_C MOM_M6_CAP_EDGE_EXP_C > MOM_A_1
  [
    ( PERIMETER(MOM_M1_CAP_EDGE_EXP_C) * M1_THICKNESS + PERIMETER(MOM_M2_CAP_EDGE_EXP_C) * M2_THICKNESS + PERIMETER(MOM_M3_CAP_EDGE_EXP_C) * M3_THICKNESS + PERIMETER(MOM_M4_CAP_EDGE_EXP_C) * M4_THICKNESS + PERIMETER(MOM_M5_CAP_EDGE_EXP_C) * M5_THICKNESS + PERIMETER(MOM_M6_CAP_EDGE_EXP_C) * M6_THICKNESS  )/4
  ] RDB MOM.A.1.rep
}

MOM.R.1 { @ VIA in MOMDMY is not allowed.
  MOMDMY_1 AND VIA1
  MOMDMY_2 AND VIA1
  MOMDMY_2 AND VIA2
  MOMDMY_3 AND VIA2
  MOMDMY_3 AND VIA3
  MOMDMY_4 AND VIA3
  MOMDMY_4 AND VIA4
  MOMDMY_5 AND VIA4
  MOMDMY_5 AND VIA5
  MOMDMY_6 AND VIA5
}

#IFDEF FULL_CHIP
MOM.R.2 { @ Each MOM cell must be covered by MOMDMY_n (n=145;1~6/100). DRC only flags no MOMDMY_n (n=145;1~6/100) in the chip. But if there is no MOM cell in your chip, the violation can be waived.
  MERGE (CHIP NOT INTERACT MOMDMY_ALL)
}
#ENDIF



DRM.R.1 { @ DRM.R.1 is a warning message to remind the users to check the related DRMs. Please refer to DRM.R.1 in the DRM for details.
	COPY CHIPx
}




